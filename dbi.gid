{"functions":[{"name":"SQL_Connect","docStart":18604,"docEnd":19033,"docs":{"brief":"Creates an SQL connection from a named configuration.","tags":[{"tag":"","text":"Creates an SQL connection from a named configuration."},{"tag":"param:confname","text":"Named configuration."},{"tag":"param:persistent","text":"True to re-use a previous persistent connection if\npossible, false otherwise."},{"tag":"param:error","text":"Error buffer."},{"tag":"param:maxlength","text":"Maximum length of the error buffer."},{"tag":"return","text":"A database connection Handle, or INVALID_HANDLE on failure."}]},"kind":"native","returnType":"Database","arguments":[{"type":"const char[]","name":"confname","decl":"const char[] confname"},{"type":"bool","name":"persistent","decl":"bool persistent"},{"type":"char[]","name":"error","decl":"char[] error"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"SQL_DefConnect","docStart":19136,"docEnd":19583,"docs":{"brief":"Creates a default SQL connection.","tags":[{"tag":"","text":"Creates a default SQL connection."},{"tag":"param:error","text":"Error buffer."},{"tag":"param:maxlength","text":"Maximum length of the error buffer."},{"tag":"param:persistent","text":"True to re-use a previous persistent connection\nif possible, false otherwise."},{"tag":"return","text":"A database connection Handle, or INVALID_HANDLE on failure.\nOn failure the error buffer will be filled with a message."}]},"kind":"stock","returnType":"Database","arguments":[{"type":"char[]","name":"error","decl":"char[] error"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"bool","name":"persistent","decl":"bool persistent"}]},{"name":"SQL_ConnectCustom","docStart":19738,"docEnd":20848,"docs":{"brief":"Connects to a database using key value pairs containing the database info.\nThe key/value pairs should match what would be in databases.cfg.\n\nI.e. \"driver\" should be \"default\" or a driver name (or omitted for\nthe default).  For SQLite, only the \"database\" parameter is needed in addition.\nFor drivers which require external connections, more of the parameters may be\nneeded.\n\nIn general it is discouraged to use this function.  Connections should go through\ndatabases.cfg for greatest flexibility on behalf of users.","tags":[{"tag":"","text":"Connects to a database using key value pairs containing the database info.\nThe key/value pairs should match what would be in databases.cfg.\n\nI.e. \"driver\" should be \"default\" or a driver name (or omitted for\nthe default).  For SQLite, only the \"database\" parameter is needed in addition.\nFor drivers which require external connections, more of the parameters may be\nneeded.\n\nIn general it is discouraged to use this function.  Connections should go through\ndatabases.cfg for greatest flexibility on behalf of users."},{"tag":"param:keyvalues","text":"Key/value pairs from a KeyValues handle, describing the connection."},{"tag":"param:error","text":"Error buffer."},{"tag":"param:maxlength","text":"Maximum length of the error buffer."},{"tag":"param:persistent","text":"True to re-use a previous persistent connection if\npossible, false otherwise."},{"tag":"return","text":"A database connection Handle, or INVALID_HANDLE on failure.\nOn failure the error buffer will be filled with a message."},{"tag":"error","text":"Invalid KeyValues handle."}]},"kind":"native","returnType":"Database","arguments":[{"type":"Handle","name":"keyvalues","decl":"Handle keyvalues"},{"type":"char[]","name":"error","decl":"char[] error"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"bool","name":"persistent","decl":"bool persistent"}]},{"name":"SQLite_UseDatabase","docStart":20985,"docEnd":21771,"docs":{"brief":"Grabs a handle to an SQLite database, creating one if it does not exist.\n\nUnless there are extenuating circumstances, you should consider using \"sourcemod-local\" as the\ndatabase name.  This provides some unification between plugins on behalf of users.\n\nAs a precaution, you should always create some sort of unique prefix to your table names so\nthere are no conflicts, and you should never drop or modify tables that you do not own.","tags":[{"tag":"","text":"Grabs a handle to an SQLite database, creating one if it does not exist.\n\nUnless there are extenuating circumstances, you should consider using \"sourcemod-local\" as the\ndatabase name.  This provides some unification between plugins on behalf of users.\n\nAs a precaution, you should always create some sort of unique prefix to your table names so\nthere are no conflicts, and you should never drop or modify tables that you do not own."},{"tag":"param:database","text":"Database name."},{"tag":"param:error","text":"Error buffer."},{"tag":"param:maxlength","text":"Maximum length of the error buffer."},{"tag":"return","text":"A database connection Handle, or INVALID_HANDLE on failure.\nOn failure the error buffer will be filled with a message."}]},"kind":"stock","returnType":"Database","arguments":[{"type":"const char[]","name":"database","decl":"const char[] database"},{"type":"char[]","name":"error","decl":"char[] error"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"SQL_ConnectEx","docStart":0,"docEnd":0,"docs":null,"kind":"native","returnType":"Handle","arguments":[{"type":"Handle","name":"driver","decl":"Handle driver"},{"type":"const char[]","name":"host","decl":"const char[] host"},{"type":"const char[]","name":"user","decl":"const char[] user"},{"type":"const char[]","name":"pass","decl":"const char[] pass"},{"type":"const char[]","name":"database","decl":"const char[] database"},{"type":"char[]","name":"error","decl":"char[] error"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"bool","name":"persistent","decl":"bool persistent"},{"type":"int","name":"port","decl":"int port"},{"type":"int","name":"maxTimeout","decl":"int maxTimeout"}]},{"name":"SQL_CheckConfig","docStart":22527,"docEnd":22711,"docs":{"brief":"Returns if a named configuration is present in databases.cfg.","tags":[{"tag":"","text":"Returns if a named configuration is present in databases.cfg."},{"tag":"param:name","text":"Configuration name."},{"tag":"return","text":"True if it exists, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"}]},{"name":"SQL_GetDriver","docStart":22764,"docEnd":23138,"docs":{"brief":"Returns a driver Handle from a name string.\n\nIf the driver is not found, SourceMod will attempt\nto load an extension named dbi.<name>.ext.[dll|so].","tags":[{"tag":"","text":"Returns a driver Handle from a name string.\n\nIf the driver is not found, SourceMod will attempt\nto load an extension named dbi.<name>.ext.[dll|so]."},{"tag":"param:name","text":"Driver identification string, or an empty\nstring to return the default driver."},{"tag":"return","text":"Driver Handle, or INVALID_HANDLE on failure."}]},"kind":"native","returnType":"DBDriver","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"}]},{"name":"SQL_ReadDriver","docStart":23196,"docEnd":23464,"docs":{"brief":"Reads the driver of an opened database.","tags":[{"tag":"","text":"Reads the driver of an opened database."},{"tag":"param:database","text":"Database Handle."},{"tag":"param:ident","text":"Option buffer to store the identification string."},{"tag":"param:ident_length","text":"Maximum length of the buffer."},{"tag":"return","text":"Driver Handle."}]},"kind":"native","returnType":"DBDriver","arguments":[{"type":"Handle","name":"database","decl":"Handle database"},{"type":"char[]","name":"ident","decl":"char[] ident"},{"type":"int","name":"ident_length","decl":"int ident_length"}]},{"name":"SQL_GetDriverIdent","docStart":23555,"docEnd":23909,"docs":{"brief":"Retrieves a driver's identification string.\n\nExample: \"mysql\", \"sqlite\"","tags":[{"tag":"","text":"Retrieves a driver's identification string.\n\nExample: \"mysql\", \"sqlite\""},{"tag":"param:driver","text":"Driver Handle, or INVALID_HANDLE for the default driver."},{"tag":"param:ident","text":"Identification string buffer."},{"tag":"param:maxlength","text":"Maximum length of the buffer."},{"tag":"error","text":"Invalid Handle other than INVALID_HANDLE."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"driver","decl":"Handle driver"},{"type":"char[]","name":"ident","decl":"char[] ident"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"SQL_GetDriverProduct","docStart":23990,"docEnd":24330,"docs":{"brief":"Retrieves a driver's product string.\n\nExample: \"MySQL\", \"SQLite\"","tags":[{"tag":"","text":"Retrieves a driver's product string.\n\nExample: \"MySQL\", \"SQLite\""},{"tag":"param:driver","text":"Driver Handle, or INVALID_HANDLE for the default driver."},{"tag":"param:product","text":"Product string buffer."},{"tag":"param:maxlength","text":"Maximum length of the buffer."},{"tag":"error","text":"Invalid Handle other than INVALID_HANDLE."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"driver","decl":"Handle driver"},{"type":"char[]","name":"product","decl":"char[] product"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"SQL_SetCharset","docStart":24415,"docEnd":24770,"docs":{"brief":"Sets the character set of the current connection.\nLike SET NAMES .. in mysql, but stays after connection problems.\n\nExample: \"utf8\", \"latin1\"","tags":[{"tag":"","text":"Sets the character set of the current connection.\nLike SET NAMES .. in mysql, but stays after connection problems.\n\nExample: \"utf8\", \"latin1\""},{"tag":"param:database","text":"Database Handle."},{"tag":"param:characterset","text":"The character set string to change to."},{"tag":"return","text":"True, if character set was changed, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"database","decl":"Handle database"},{"type":"const char[]","name":"charset","decl":"const char[] charset"}]},{"name":"SQL_GetAffectedRows","docStart":24842,"docEnd":25103,"docs":{"brief":"Returns the number of affected rows from the last query.","tags":[{"tag":"","text":"Returns the number of affected rows from the last query."},{"tag":"param:hndl","text":"A database OR statement Handle."},{"tag":"return","text":"Number of rows affected by the last query."},{"tag":"error","text":"Invalid database or statement Handle."}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"hndl","decl":"Handle hndl"}]},{"name":"SQL_GetInsertId","docStart":25153,"docEnd":25396,"docs":{"brief":"Returns the last query's insertion id.","tags":[{"tag":"","text":"Returns the last query's insertion id."},{"tag":"param:hndl","text":"A database, query, OR statement Handle."},{"tag":"return","text":"Last query's insertion id."},{"tag":"error","text":"Invalid database, query, or statement Handle."}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"hndl","decl":"Handle hndl"}]},{"name":"SQL_GetError","docStart":25442,"docEnd":25804,"docs":{"brief":"Returns the error reported by the last query.","tags":[{"tag":"","text":"Returns the error reported by the last query."},{"tag":"param:hndl","text":"A database, query, OR statement Handle."},{"tag":"param:error","text":"Error buffer."},{"tag":"param:maxlength","text":"Maximum length of the buffer."},{"tag":"return","text":"True if there was an error, false otherwise."},{"tag":"error","text":"Invalid database, query, or statement Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"hndl","decl":"Handle hndl"},{"type":"char[]","name":"error","decl":"char[] error"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"SQL_EscapeString","docStart":25877,"docEnd":27032,"docs":{"brief":"Escapes a database string for literal insertion.  This is not needed\nfor binding strings in prepared statements.\n\nGenerally, database strings are inserted into queries enclosed in\nsingle quotes (').  If user input has a single quote in it, the\nquote needs to be escaped.  This function ensures that any unsafe\ncharacters are safely escaped according to the database engine and\nthe database's character set.\n\nNOTE: SourceMod only guarantees properly escaped strings when the query\nencloses the string in ''. While drivers tend to allow \" instead, the string\nmay be not be escaped (for example, on SQLite)!","tags":[{"tag":"","text":"Escapes a database string for literal insertion.  This is not needed\nfor binding strings in prepared statements.\n\nGenerally, database strings are inserted into queries enclosed in\nsingle quotes (').  If user input has a single quote in it, the\nquote needs to be escaped.  This function ensures that any unsafe\ncharacters are safely escaped according to the database engine and\nthe database's character set.\n\nNOTE: SourceMod only guarantees properly escaped strings when the query\nencloses the string in ''. While drivers tend to allow \" instead, the string\nmay be not be escaped (for example, on SQLite)!"},{"tag":"param:database","text":"A database Handle."},{"tag":"param:string","text":"String to quote."},{"tag":"param:buffer","text":"Buffer to store quoted string in."},{"tag":"param:maxlength","text":"Maximum length of the buffer."},{"tag":"param:written","text":"Optionally returns the number of bytes written."},{"tag":"return","text":"True on success, false if buffer is not big enough.\nThe buffer must be at least 2*strlen(string)+1."},{"tag":"error","text":"Invalid database or statement Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"database","decl":"Handle database"},{"type":"const char[]","name":"string","decl":"const char[] string"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"int&","name":"written","decl":"int& written"}]},{"name":"SQL_FormatQuery","docStart":27191,"docEnd":27692,"docs":{"brief":"Formats a string according to the SourceMod format rules (see documentation).\nAll format specifiers are escaped (see SQL_EscapeString) unless the '!' flag is used.","tags":[{"tag":"","text":"Formats a string according to the SourceMod format rules (see documentation).\nAll format specifiers are escaped (see SQL_EscapeString) unless the '!' flag is used."},{"tag":"param:database","text":"A database Handle."},{"tag":"param:buffer","text":"Destination string buffer."},{"tag":"param:maxlength","text":"Maximum length of output string buffer."},{"tag":"param:format","text":"Formatting rules."},{"tag":"param:...","text":"Variable number of format parameters."},{"tag":"return","text":"Number of cells written."}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"database","decl":"Handle database"},{"type":"const char[]","name":"buffer","decl":"const char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"SQL_QuoteString","docStart":0,"docEnd":0,"docs":null,"kind":"stock","returnType":"bool","arguments":[{"type":"Handle","name":"database","decl":"Handle database"},{"type":"const char[]","name":"string","decl":"const char[] string"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"int&","name":"written","decl":"int& written"}]},{"name":"SQL_FastQuery","docStart":28181,"docEnd":28719,"docs":{"brief":"Executes a query and ignores the result set.","tags":[{"tag":"","text":"Executes a query and ignores the result set."},{"tag":"param:database","text":"A database Handle."},{"tag":"param:query","text":"Query string."},{"tag":"param:len","text":"Optional parameter to specify the query length, in\nbytes.  This can be used to send binary queries that\nhave a premature terminator."},{"tag":"return","text":"True if query succeeded, false otherwise.  Use\nSQL_GetError to find the last error."},{"tag":"error","text":"Invalid database Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"database","decl":"Handle database"},{"type":"const char[]","name":"query","decl":"const char[] query"},{"type":"int","name":"len","decl":"int len"}]},{"name":"SQL_Query","docStart":28800,"docEnd":29398,"docs":{"brief":"Executes a simple query and returns a new query Handle for\nreceiving the results.","tags":[{"tag":"","text":"Executes a simple query and returns a new query Handle for\nreceiving the results."},{"tag":"param:database","text":"A database Handle."},{"tag":"param:query","text":"Query string."},{"tag":"param:len","text":"Optional parameter to specify the query length, in\nbytes.  This can be used to send binary queries that\nhave a premature terminator."},{"tag":"return","text":"A new Query Handle on success, INVALID_HANDLE\notherwise.  The Handle must be freed with CloseHandle()."},{"tag":"error","text":"Invalid database Handle."}]},"kind":"native","returnType":"DBResultSet","arguments":[{"type":"Handle","name":"database","decl":"Handle database"},{"type":"const char[]","name":"query","decl":"const char[] query"},{"type":"int","name":"len","decl":"int len"}]},{"name":"SQL_PrepareQuery","docStart":29482,"docEnd":30237,"docs":{"brief":"Creates a new prepared statement query.  Prepared statements can\nbe executed any number of times.  They can also have placeholder\nparameters, similar to variables, which can be bound safely and\nsecurely (for example, you do not need to quote bound strings).\n\nStatement handles will work in any function that accepts a Query handle.","tags":[{"tag":"","text":"Creates a new prepared statement query.  Prepared statements can\nbe executed any number of times.  They can also have placeholder\nparameters, similar to variables, which can be bound safely and\nsecurely (for example, you do not need to quote bound strings).\n\nStatement handles will work in any function that accepts a Query handle."},{"tag":"param:database","text":"A database Handle."},{"tag":"param:query","text":"Query string."},{"tag":"param:error","text":"Error buffer."},{"tag":"param:maxlength","text":"Maximum size of the error buffer."},{"tag":"return","text":"A new statement Handle on success, INVALID_HANDLE\notherwise.  The Handle must be freed with CloseHandle()."},{"tag":"error","text":"Invalid database Handle."}]},"kind":"native","returnType":"DBStatement","arguments":[{"type":"Handle","name":"database","decl":"Handle database"},{"type":"const char[]","name":"query","decl":"const char[] query"},{"type":"char[]","name":"error","decl":"char[] error"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"SQL_FetchMoreResults","docStart":30345,"docEnd":30824,"docs":{"brief":"Advances to the next set of results.\n\nIn some SQL implementations, multiple result sets can exist on one query.\nThis is possible in MySQL with simple queries when executing a CALL\nquery.  If this is the case, all result sets must be processed before\nanother query is made.","tags":[{"tag":"","text":"Advances to the next set of results.\n\nIn some SQL implementations, multiple result sets can exist on one query.\nThis is possible in MySQL with simple queries when executing a CALL\nquery.  If this is the case, all result sets must be processed before\nanother query is made."},{"tag":"param:query","text":"A query Handle."},{"tag":"return","text":"True if there was another result set, false otherwise."},{"tag":"error","text":"Invalid query Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"query","decl":"Handle query"}]},{"name":"SQL_HasResultSet","docStart":30877,"docEnd":31230,"docs":{"brief":"Returns whether or not a result set exists.  This will\nreturn true even if 0 results were returned, but false\non queries like UPDATE, INSERT, or DELETE.","tags":[{"tag":"","text":"Returns whether or not a result set exists.  This will\nreturn true even if 0 results were returned, but false\non queries like UPDATE, INSERT, or DELETE."},{"tag":"param:query","text":"A query (or statement) Handle."},{"tag":"return","text":"True if there is a result set, false otherwise."},{"tag":"error","text":"Invalid query Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"query","decl":"Handle query"}]},{"name":"SQL_GetRowCount","docStart":31279,"docEnd":31519,"docs":{"brief":"Retrieves the number of rows in the last result set.","tags":[{"tag":"","text":"Retrieves the number of rows in the last result set."},{"tag":"param:query","text":"A query (or statement) Handle."},{"tag":"return","text":"Number of rows in the current result set."},{"tag":"error","text":"Invalid query Handle."}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"query","decl":"Handle query"}]},{"name":"SQL_GetFieldCount","docStart":31566,"docEnd":31810,"docs":{"brief":"Retrieves the number of fields in the last result set.","tags":[{"tag":"","text":"Retrieves the number of fields in the last result set."},{"tag":"param:query","text":"A query (or statement) Handle."},{"tag":"return","text":"Number of fields in the current result set."},{"tag":"error","text":"Invalid query Handle."}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"query","decl":"Handle query"}]},{"name":"SQL_FieldNumToName","docStart":31859,"docEnd":32246,"docs":{"brief":"Retrieves the name of a field by index.","tags":[{"tag":"","text":"Retrieves the name of a field by index."},{"tag":"param:query","text":"A query (or statement) Handle."},{"tag":"param:field","text":"Field number (starting from 0)."},{"tag":"param:name","text":"Name buffer."},{"tag":"param:maxlength","text":"Maximum length of the name buffer."},{"tag":"error","text":"Invalid query Handle, invalid field index, or\nno current result set."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"query","decl":"Handle query"},{"type":"int","name":"field","decl":"int field"},{"type":"char[]","name":"name","decl":"char[] name"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"SQL_FieldNameToNum","docStart":32336,"docEnd":32694,"docs":{"brief":"Retrieves a field index by name.","tags":[{"tag":"","text":"Retrieves a field index by name."},{"tag":"param:query","text":"A query (or statement) Handle."},{"tag":"param:name","text":"Name of the field (case sensitive)."},{"tag":"param:field","text":"Variable to store field index in."},{"tag":"return","text":"True if found, false if not found."},{"tag":"error","text":"Invalid query Handle or no current result set."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"query","decl":"Handle query"},{"type":"const char[]","name":"name","decl":"const char[] name"},{"type":"int&","name":"field","decl":"int& field"}]},{"name":"SQL_FetchRow","docStart":32776,"docEnd":33206,"docs":{"brief":"Fetches a row from the current result set.  This must be\nsuccessfully called before any results are fetched.\n\nIf this function fails, SQL_MoreResults() can be used to\ntell if there was an error or the result set is finished.","tags":[{"tag":"","text":"Fetches a row from the current result set.  This must be\nsuccessfully called before any results are fetched.\n\nIf this function fails, SQL_MoreResults() can be used to\ntell if there was an error or the result set is finished."},{"tag":"param:query","text":"A query (or statement) Handle."},{"tag":"return","text":"True if a row was fetched, false otherwise."},{"tag":"error","text":"Invalid query Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"query","decl":"Handle query"}]},{"name":"SQL_MoreRows","docStart":33251,"docEnd":33474,"docs":{"brief":"Returns if there are more rows.","tags":[{"tag":"","text":"Returns if there are more rows."},{"tag":"param:query","text":"A query (or statement) Handle."},{"tag":"return","text":"True if there are more rows, false otherwise."},{"tag":"error","text":"Invalid query Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"query","decl":"Handle query"}]},{"name":"SQL_Rewind","docStart":33519,"docEnd":33770,"docs":{"brief":"Rewinds a result set back to the first result.","tags":[{"tag":"","text":"Rewinds a result set back to the first result."},{"tag":"param:query","text":"A query (or statement) Handle."},{"tag":"return","text":"True on success, false otherwise."},{"tag":"error","text":"Invalid query Handle or no current result set."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"query","decl":"Handle query"}]},{"name":"SQL_FetchString","docStart":33813,"docEnd":34580,"docs":{"brief":"Fetches a string from a field in the current row of a result set.\nIf the result is NULL, an empty string will be returned.  A NULL\ncheck can be done with the result parameter, or SQL_IsFieldNull().","tags":[{"tag":"","text":"Fetches a string from a field in the current row of a result set.\nIf the result is NULL, an empty string will be returned.  A NULL\ncheck can be done with the result parameter, or SQL_IsFieldNull()."},{"tag":"param:query","text":"A query (or statement) Handle."},{"tag":"param:field","text":"The field index (starting from 0)."},{"tag":"param:buffer","text":"String buffer."},{"tag":"param:maxlength","text":"Maximum size of the string buffer."},{"tag":"param:result","text":"Optional variable to store the status of the return value."},{"tag":"return","text":"Number of bytes written."},{"tag":"error","text":"Invalid query Handle or field index, invalid\ntype conversion requested from the database,\nor no current result set."}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"query","decl":"Handle query"},{"type":"int","name":"field","decl":"int field"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"DBResult&","name":"result","decl":"DBResult& result"}]},{"name":"SQL_FetchFloat","docStart":34698,"docEnd":35353,"docs":{"brief":"Fetches a float from a field in the current row of a result set.\nIf the result is NULL, a value of 0.0 will be returned.  A NULL\ncheck can be done with the result parameter, or SQL_IsFieldNull().","tags":[{"tag":"","text":"Fetches a float from a field in the current row of a result set.\nIf the result is NULL, a value of 0.0 will be returned.  A NULL\ncheck can be done with the result parameter, or SQL_IsFieldNull()."},{"tag":"param:query","text":"A query (or statement) Handle."},{"tag":"param:field","text":"The field index (starting from 0)."},{"tag":"param:result","text":"Optional variable to store the status of the return value."},{"tag":"return","text":"A float value."},{"tag":"error","text":"Invalid query Handle or field index, invalid\ntype conversion requested from the database,\nor no current result set."}]},"kind":"native","returnType":"float","arguments":[{"type":"Handle","name":"query","decl":"Handle query"},{"type":"int","name":"field","decl":"int field"},{"type":"DBResult&","name":"result","decl":"DBResult& result"}]},{"name":"SQL_FetchInt","docStart":35442,"docEnd":36101,"docs":{"brief":"Fetches an integer from a field in the current row of a result set.\nIf the result is NULL, a value of 0 will be returned.  A NULL\ncheck can be done with the result parameter, or SQL_IsFieldNull().","tags":[{"tag":"","text":"Fetches an integer from a field in the current row of a result set.\nIf the result is NULL, a value of 0 will be returned.  A NULL\ncheck can be done with the result parameter, or SQL_IsFieldNull()."},{"tag":"param:query","text":"A query (or statement) Handle."},{"tag":"param:field","text":"The field index (starting from 0)."},{"tag":"param:result","text":"Optional variable to store the status of the return value."},{"tag":"return","text":"An integer value."},{"tag":"error","text":"Invalid query Handle or field index, invalid\ntype conversion requested from the database,\nor no current result set."}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"query","decl":"Handle query"},{"type":"int","name":"field","decl":"int field"},{"type":"DBResult&","name":"result","decl":"DBResult& result"}]},{"name":"SQL_IsFieldNull","docStart":36186,"docEnd":36627,"docs":{"brief":"Returns whether a field's data in the current row of a result set is\nNULL or not.  NULL is an SQL type which means \"no data.\"","tags":[{"tag":"","text":"Returns whether a field's data in the current row of a result set is\nNULL or not.  NULL is an SQL type which means \"no data.\""},{"tag":"param:query","text":"A query (or statement) Handle."},{"tag":"param:field","text":"The field index (starting from 0)."},{"tag":"return","text":"True if data is NULL, false otherwise."},{"tag":"error","text":"Invalid query Handle or field index, or no\ncurrent result set."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"query","decl":"Handle query"},{"type":"int","name":"field","decl":"int field"}]},{"name":"SQL_FetchSize","docStart":36686,"docEnd":37228,"docs":{"brief":"Returns the length of a field's data in the current row of a result\nset.  This only needs to be called for strings to determine how many\nbytes to use.  Note that the return value does not include the null\nterminator.","tags":[{"tag":"","text":"Returns the length of a field's data in the current row of a result\nset.  This only needs to be called for strings to determine how many\nbytes to use.  Note that the return value does not include the null\nterminator."},{"tag":"param:query","text":"A query (or statement) Handle."},{"tag":"param:field","text":"The field index (starting from 0)."},{"tag":"return","text":"Number of bytes for the field's data size."},{"tag":"error","text":"Invalid query Handle or field index or no\ncurrent result set."}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"query","decl":"Handle query"},{"type":"int","name":"field","decl":"int field"}]},{"name":"SQL_BindParamInt","docStart":37284,"docEnd":37765,"docs":{"brief":"Binds a parameter in a prepared statement to a given integer value.","tags":[{"tag":"","text":"Binds a parameter in a prepared statement to a given integer value."},{"tag":"param:statement","text":"A statement (prepared query) Handle."},{"tag":"param:param","text":"The parameter index (starting from 0)."},{"tag":"param:number","text":"The number to bind."},{"tag":"param:signed","text":"True to bind the number as signed, false to\nbind it as unsigned."},{"tag":"error","text":"Invalid statement Handle or parameter index, or\nSQL error."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"statement","decl":"Handle statement"},{"type":"int","name":"param","decl":"int param"},{"type":"int","name":"number","decl":"int number"},{"type":"bool","name":"signed","decl":"bool signed"}]},{"name":"SQL_BindParamFloat","docStart":37859,"docEnd":38228,"docs":{"brief":"Binds a parameter in a prepared statement to a given float value.","tags":[{"tag":"","text":"Binds a parameter in a prepared statement to a given float value."},{"tag":"param:statement","text":"A statement (prepared query) Handle."},{"tag":"param:param","text":"The parameter index (starting from 0)."},{"tag":"param:value","text":"The float number to bind."},{"tag":"error","text":"Invalid statement Handle or parameter index, or\nSQL error."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"statement","decl":"Handle statement"},{"type":"int","name":"param","decl":"int param"},{"type":"float","name":"value","decl":"float value"}]},{"name":"SQL_BindParamString","docStart":38307,"docEnd":38950,"docs":{"brief":"Binds a parameter in a prepared statement to a given string value.","tags":[{"tag":"","text":"Binds a parameter in a prepared statement to a given string value."},{"tag":"param:statement","text":"A statement (prepared query) Handle."},{"tag":"param:param","text":"The parameter index (starting from 0)."},{"tag":"param:value","text":"The string to bind."},{"tag":"param:copy","text":"Whether or not SourceMod should copy the value\nlocally if necessary.  If the string contents\nwon't change before calling SQL_Execute(), this\ncan be set to false for optimization."},{"tag":"error","text":"Invalid statement Handle or parameter index, or\nSQL error."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"statement","decl":"Handle statement"},{"type":"int","name":"param","decl":"int param"},{"type":"const char[]","name":"value","decl":"const char[] value"},{"type":"bool","name":"copy","decl":"bool copy"}]},{"name":"SQL_Execute","docStart":39048,"docEnd":39310,"docs":{"brief":"Executes a prepared statement.  All parameters must be bound beforehand.","tags":[{"tag":"","text":"Executes a prepared statement.  All parameters must be bound beforehand."},{"tag":"param:statement","text":"A statement (prepared query) Handle."},{"tag":"return","text":"True on success, false on failure."},{"tag":"error","text":"Invalid statement Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"statement","decl":"Handle statement"}]},{"name":"SQL_LockDatabase","docStart":39358,"docEnd":40036,"docs":{"brief":"Locks a database so threading operations will not interrupt.\n\nIf you are using a database Handle for both threading and non-threading,\nthis MUST be called before doing any set of non-threading DB operations.\nOtherwise you risk corrupting the database driver's memory or network\nconnection.\n\nLeaving a lock on a database and then executing a threaded query results\nin a dead lock! Make sure to call SQL_UnlockDatabase()!\n\nIf the lock cannot be acquired, the main thread will pause until the\nthreaded operation has concluded.","tags":[{"tag":"","text":"Locks a database so threading operations will not interrupt.\n\nIf you are using a database Handle for both threading and non-threading,\nthis MUST be called before doing any set of non-threading DB operations.\nOtherwise you risk corrupting the database driver's memory or network\nconnection.\n\nLeaving a lock on a database and then executing a threaded query results\nin a dead lock! Make sure to call SQL_UnlockDatabase()!\n\nIf the lock cannot be acquired, the main thread will pause until the\nthreaded operation has concluded."},{"tag":"param:database","text":"A database Handle."},{"tag":"error","text":"Invalid database Handle."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"database","decl":"Handle database"}]},{"name":"SQL_UnlockDatabase","docStart":40088,"docEnd":40255,"docs":{"brief":"Unlocks a database so threading operations may continue.","tags":[{"tag":"","text":"Unlocks a database so threading operations may continue."},{"tag":"param:database","text":"A database Handle."},{"tag":"error","text":"Invalid database Handle."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"database","decl":"Handle database"}]},{"name":"SQL_IsSameConnection","docStart":40944,"docEnd":41300,"docs":{"brief":"Tells whether two database handles both point to the same database\nconnection.","tags":[{"tag":"","text":"Tells whether two database handles both point to the same database\nconnection."},{"tag":"param:hndl1","text":"First database Handle."},{"tag":"param:hndl2","text":"Second database Handle."},{"tag":"return","text":"True if the Handles point to the same\nconnection, false otherwise."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"hndl1","decl":"Handle hndl1"},{"type":"Handle","name":"hndl2","decl":"Handle hndl2"}]},{"name":"SQL_TConnect","docStart":41367,"docEnd":41957,"docs":{"brief":"Connects to a database via a thread.  This can be used instead of\nSQL_Connect() if you wish for non-blocking functionality.\n\nIt is not necessary to use this to use threaded queries.  However, if you\ndon't (or you mix threaded/non-threaded queries), you should see\nSQL_LockDatabase().","tags":[{"tag":"","text":"Connects to a database via a thread.  This can be used instead of\nSQL_Connect() if you wish for non-blocking functionality.\n\nIt is not necessary to use this to use threaded queries.  However, if you\ndon't (or you mix threaded/non-threaded queries), you should see\nSQL_LockDatabase()."},{"tag":"param:callback","text":"Callback; new Handle will be in hndl, owner is the driver.\nIf no driver was found, the owner is INVALID_HANDLE."},{"tag":"param:name","text":"Database name."},{"tag":"param:data","text":"Extra data value to pass to the callback."}]},"kind":"native","returnType":"void","arguments":[{"type":"SQLTCallback","name":"callback","decl":"SQLTCallback callback"},{"type":"const char[]","name":"name","decl":"const char[] name"},{"type":"any","name":"data","decl":"any data"}]},{"name":"SQL_TQuery","docStart":42052,"docEnd":42878,"docs":{"brief":"Executes a simple query via a thread.  The query Handle is passed through\nthe callback.\n\nThe database Handle returned through the callback is always a new Handle,\nand if necessary, SQL_IsSameConnection() should be used to test against\nother connections.\n\nThe query Handle returned through the callback is temporary and destroyed\nat the end of the callback.  If you need to hold onto it, use CloneHandle().","tags":[{"tag":"","text":"Executes a simple query via a thread.  The query Handle is passed through\nthe callback.\n\nThe database Handle returned through the callback is always a new Handle,\nand if necessary, SQL_IsSameConnection() should be used to test against\nother connections.\n\nThe query Handle returned through the callback is temporary and destroyed\nat the end of the callback.  If you need to hold onto it, use CloneHandle()."},{"tag":"param:database","text":"A database Handle."},{"tag":"param:callback","text":"Callback; database is in \"owner\" and the query Handle\nis passed in \"hndl\"."},{"tag":"param:query","text":"Query string."},{"tag":"param:data","text":"Extra data value to pass to the callback."},{"tag":"param:prio","text":"Priority queue to use."},{"tag":"error","text":"Invalid database Handle."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"database","decl":"Handle database"},{"type":"SQLTCallback","name":"callback","decl":"SQLTCallback callback"},{"type":"const char[]","name":"query","decl":"const char[] query"},{"type":"any","name":"data","decl":"any data"},{"type":"DBPriority","name":"prio","decl":"DBPriority prio"}]},{"name":"SQL_CreateTransaction","docStart":43010,"docEnd":43231,"docs":{"brief":"Creates a new transaction object. A transaction object is a list of queries\nthat can be sent to the database thread and executed as a single transaction.","tags":[{"tag":"","text":"Creates a new transaction object. A transaction object is a list of queries\nthat can be sent to the database thread and executed as a single transaction."},{"tag":"return","text":"A transaction handle."}]},"kind":"native","returnType":"Transaction","arguments":[]},{"name":"SQL_AddQuery","docStart":43280,"docEnd":43627,"docs":{"brief":"Adds a query to a transaction object.","tags":[{"tag":"","text":"Adds a query to a transaction object."},{"tag":"param:txn","text":"A transaction handle."},{"tag":"param:query","text":"Query string."},{"tag":"param:data","text":"Extra data value to pass to the final callback."},{"tag":"return","text":"The index of the query in the transaction's query list."},{"tag":"error","text":"Invalid transaction handle."}]},"kind":"native","returnType":"int","arguments":[{"type":"Transaction","name":"txn","decl":"Transaction txn"},{"type":"const char[]","name":"query","decl":"const char[] query"},{"type":"any","name":"data","decl":"any data"}]},{"name":"SQL_ExecuteTransaction","docStart":43706,"docEnd":44294,"docs":{"brief":"Sends a transaction to the database thread. The transaction handle is\nautomatically closed. When the transaction completes, the optional\ncallback is invoked.","tags":[{"tag":"","text":"Sends a transaction to the database thread. The transaction handle is\nautomatically closed. When the transaction completes, the optional\ncallback is invoked."},{"tag":"param:db","text":"A database handle."},{"tag":"param:txn","text":"A transaction handle."},{"tag":"param:onSuccess","text":"An optional callback to receive a successful transaction."},{"tag":"param:onError","text":"An optional callback to receive an error message."},{"tag":"param:data","text":"An optional value to pass to callbacks."},{"tag":"param:prio","text":"Priority queue to use."},{"tag":"error","text":"An invalid handle."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"db","decl":"Handle db"},{"type":"Transaction","name":"txn","decl":"Transaction txn"},{"type":"SQLTxnSuccess","name":"onSuccess","decl":"SQLTxnSuccess onSuccess"},{"type":"SQLTxnFailure","name":"onError","decl":"SQLTxnFailure onError"},{"type":"any","name":"data","decl":"any data"},{"type":"DBPriority","name":"priority","decl":"DBPriority priority"}]}],"methodmaps":[{"name":"DBDriver","docStart":2409,"docEnd":2519,"docs":{"brief":"A Driver represents a database backend, currently MySQL or SQLite.\n\nDriver handles cannot be closed.","tags":[{"tag":"","text":"A Driver represents a database backend, currently MySQL or SQLite.\n\nDriver handles cannot be closed."}]},"methods":[{"name":"Find","docStart":2554,"docEnd":2859,"docs":{"brief":"Finds the driver associated with a name.\n\nSupported driver strings:\nmysql\nsqlite","tags":[{"tag":"","text":"Finds the driver associated with a name.\n\nSupported driver strings:\nmysql\nsqlite"},{"tag":"param:name","text":"Driver identification string, or an empty string\nto return the default driver."},{"tag":"return","text":"Driver handle, or null on failure."}]},"kind":null,"returnType":"DBDriver","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"}]},{"name":"GetIdentifier","docStart":2926,"docEnd":3126,"docs":{"brief":"Retrieves a driver's identification string.\n\nExample: \"mysql\", \"sqlite\"","tags":[{"tag":"","text":"Retrieves a driver's identification string.\n\nExample: \"mysql\", \"sqlite\""},{"tag":"param:ident","text":"Identification string buffer."},{"tag":"param:maxlength","text":"Maximum length of the buffer."}]},"kind":null,"returnType":"void","arguments":[{"type":"char[]","name":"ident","decl":"char[] ident"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"GetProduct","docStart":3196,"docEnd":3382,"docs":{"brief":"Retrieves a driver's product string.\n\nExample: \"MySQL\", \"SQLite\"","tags":[{"tag":"","text":"Retrieves a driver's product string.\n\nExample: \"MySQL\", \"SQLite\""},{"tag":"param:product","text":"Product string buffer."},{"tag":"param:maxlength","text":"Maximum length of the buffer."}]},"kind":null,"returnType":"void","arguments":[{"type":"char[]","name":"product","decl":"char[] product"},{"type":"int","name":"maxlength","decl":"int maxlength"}]}],"properties":[]},{"name":"DBResultSet","docStart":3454,"docEnd":3517,"docs":{"brief":"Represents a set of results returned from executing a query.","tags":[{"tag":"","text":"Represents a set of results returned from executing a query."}]},"methods":[{"name":"FetchMoreResults","docStart":3555,"docEnd":3942,"docs":{"brief":"Advances to the next set of results.\n\nIn some SQL implementations, multiple result sets can exist on one query.\nThis is possible in MySQL with simple queries when executing a CALL\nquery.  If this is the case, all result sets must be processed before\nanother query is made.","tags":[{"tag":"","text":"Advances to the next set of results.\n\nIn some SQL implementations, multiple result sets can exist on one query.\nThis is possible in MySQL with simple queries when executing a CALL\nquery.  If this is the case, all result sets must be processed before\nanother query is made."},{"tag":"return","text":"True if there was another result set, false otherwise."}]},"kind":null,"returnType":"bool","arguments":[]},{"name":"FieldNumToName","docStart":4859,"docEnd":5134,"docs":{"brief":"Retrieves the name of a field by index.","tags":[{"tag":"","text":"Retrieves the name of a field by index."},{"tag":"param:field","text":"Field number (starting from 0)."},{"tag":"param:name","text":"Name buffer."},{"tag":"param:maxlength","text":"Maximum length of the name buffer."},{"tag":"error","text":"Invalid field index, or no current result set."}]},"kind":null,"returnType":"void","arguments":[{"type":"int","name":"field","decl":"int field"},{"type":"char[]","name":"name","decl":"char[] name"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"FieldNameToNum","docStart":5215,"docEnd":5484,"docs":{"brief":"Retrieves a field index by name.","tags":[{"tag":"","text":"Retrieves a field index by name."},{"tag":"param:name","text":"Name of the field (case sensitive)."},{"tag":"param:field","text":"Variable to store field index in."},{"tag":"return","text":"True if found, false if not found."},{"tag":"error","text":"No current result set."}]},"kind":null,"returnType":"bool","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"},{"type":"int&","name":"field","decl":"int& field"}]},{"name":"FetchRow","docStart":5557,"docEnd":5874,"docs":{"brief":"Fetches a row from the current result set.  This must be\nsuccessfully called before any results are fetched.\n\nIf this function fails, _MoreResults can be used to\ntell if there was an error or the result set is finished.","tags":[{"tag":"","text":"Fetches a row from the current result set.  This must be\nsuccessfully called before any results are fetched.\n\nIf this function fails, _MoreResults can be used to\ntell if there was an error or the result set is finished."},{"tag":"return","text":"True if a row was fetched, false otherwise."}]},"kind":null,"returnType":"bool","arguments":[]},{"name":"Rewind","docStart":6083,"docEnd":6245,"docs":{"brief":"Rewinds a result set back to the first result.","tags":[{"tag":"","text":"Rewinds a result set back to the first result."},{"tag":"return","text":"True on success, false otherwise."},{"tag":"error","text":"No current result set."}]},"kind":null,"returnType":"bool","arguments":[]},{"name":"FetchString","docStart":6281,"docEnd":6944,"docs":{"brief":"Fetches a string from a field in the current row of a result set.\nIf the result is NULL, an empty string will be returned.  A NULL\ncheck can be done with the result parameter, or SQL_IsFieldNull().","tags":[{"tag":"","text":"Fetches a string from a field in the current row of a result set.\nIf the result is NULL, an empty string will be returned.  A NULL\ncheck can be done with the result parameter, or SQL_IsFieldNull()."},{"tag":"param:field","text":"The field index (starting from 0)."},{"tag":"param:buffer","text":"String buffer."},{"tag":"param:maxlength","text":"Maximum size of the string buffer."},{"tag":"param:result","text":"Optional variable to store the status of the return value."},{"tag":"return","text":"Number of bytes written."},{"tag":"error","text":"Invalid field index, invalid type conversion requested\nfrom the database, or no current result set."}]},"kind":null,"returnType":"int","arguments":[{"type":"int","name":"field","decl":"int field"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"DBResult&","name":"result","decl":"DBResult& result"}]},{"name":"FetchFloat","docStart":7053,"docEnd":7604,"docs":{"brief":"Fetches a float from a field in the current row of a result set.\nIf the result is NULL, a value of 0.0 will be returned.  A NULL\ncheck can be done with the result parameter, or SQL_IsFieldNull().","tags":[{"tag":"","text":"Fetches a float from a field in the current row of a result set.\nIf the result is NULL, a value of 0.0 will be returned.  A NULL\ncheck can be done with the result parameter, or SQL_IsFieldNull()."},{"tag":"param:field","text":"The field index (starting from 0)."},{"tag":"param:result","text":"Optional variable to store the status of the return value."},{"tag":"return","text":"A float value."},{"tag":"error","text":"Invalid field index, invalid type conversion requested\nfrom the database, or no current result set."}]},"kind":null,"returnType":"float","arguments":[{"type":"int","name":"field","decl":"int field"},{"type":"DBResult&","name":"result","decl":"DBResult& result"}]},{"name":"FetchInt","docStart":7684,"docEnd":8239,"docs":{"brief":"Fetches an integer from a field in the current row of a result set.\nIf the result is NULL, a value of 0 will be returned.  A NULL\ncheck can be done with the result parameter, or SQL_IsFieldNull().","tags":[{"tag":"","text":"Fetches an integer from a field in the current row of a result set.\nIf the result is NULL, a value of 0 will be returned.  A NULL\ncheck can be done with the result parameter, or SQL_IsFieldNull()."},{"tag":"param:field","text":"The field index (starting from 0)."},{"tag":"param:result","text":"Optional variable to store the status of the return value."},{"tag":"return","text":"An integer value."},{"tag":"error","text":"Invalid field index, invalid type conversion requested\nfrom the database, or no current result set."}]},"kind":null,"returnType":"int","arguments":[{"type":"int","name":"field","decl":"int field"},{"type":"DBResult&","name":"result","decl":"DBResult& result"}]},{"name":"IsFieldNull","docStart":8315,"docEnd":8651,"docs":{"brief":"Returns whether a field's data in the current row of a result set is\nNULL or not.  NULL is an SQL type which means \"no data.\"","tags":[{"tag":"","text":"Returns whether a field's data in the current row of a result set is\nNULL or not.  NULL is an SQL type which means \"no data.\""},{"tag":"param:field","text":"The field index (starting from 0)."},{"tag":"return","text":"True if data is NULL, false otherwise."},{"tag":"error","text":"Invalid field index, or no current result set."}]},"kind":null,"returnType":"bool","arguments":[{"type":"int","name":"field","decl":"int field"}]},{"name":"FetchSize","docStart":8701,"docEnd":9140,"docs":{"brief":"Returns the length of a field's data in the current row of a result\nset.  This only needs to be called for strings to determine how many\nbytes to use.  Note that the return value does not include the null\nterminator.","tags":[{"tag":"","text":"Returns the length of a field's data in the current row of a result\nset.  This only needs to be called for strings to determine how many\nbytes to use.  Note that the return value does not include the null\nterminator."},{"tag":"param:field","text":"The field index (starting from 0)."},{"tag":"return","text":"Number of bytes for the field's data size."},{"tag":"error","text":"Invalid field index or no current result set."}]},"kind":null,"returnType":"int","arguments":[{"type":"int","name":"field","decl":"int field"}]}],"properties":[{"name":"HasResults","docStart":3988,"docEnd":4153,"docs":{"brief":"Returns whether or not a result set exists.  This will\nreturn true even if 0 results were returned, but false\non queries like UPDATE, INSERT, or DELETE.","tags":[{"tag":"","text":"Returns whether or not a result set exists.  This will\nreturn true even if 0 results were returned, but false\non queries like UPDATE, INSERT, or DELETE."}]},"type":"bool","getter":true,"setter":false},{"name":"RowCount","docStart":4215,"docEnd":4399,"docs":{"brief":"Retrieves the number of rows in the last result set.","tags":[{"tag":"","text":"Retrieves the number of rows in the last result set."},{"tag":"param:query","text":"A query (or statement) Handle."},{"tag":"return","text":"Number of rows in the current result set."}]},"type":"int","getter":true,"setter":false},{"name":"FieldCount","docStart":4458,"docEnd":4515,"docs":{"brief":"Retrieves the number of fields in the last result set.","tags":[{"tag":"","text":"Retrieves the number of fields in the last result set."}]},"type":"int","getter":true,"setter":false},{"name":"AffectedRows","docStart":4576,"docEnd":4666,"docs":{"brief":"Returns the number of affected rows from the query that generated this\nresult set.","tags":[{"tag":"","text":"Returns the number of affected rows from the query that generated this\nresult set."}]},"type":"int","getter":true,"setter":false},{"name":"InsertId","docStart":4729,"docEnd":4800,"docs":{"brief":"Returns the insert id from the query that generated this result set.","tags":[{"tag":"","text":"Returns the insert id from the query that generated this result set."}]},"type":"int","getter":true,"setter":false},{"name":"MoreRows","docStart":5912,"docEnd":6023,"docs":{"brief":"Returns if there are more rows.","tags":[{"tag":"","text":"Returns if there are more rows."},{"tag":"return","text":"True if there are more rows, false otherwise."}]},"type":"bool","getter":true,"setter":false}]},{"name":"Transaction","docStart":10863,"docEnd":10967,"docs":{"brief":"A Transaction is a collection of SQL statements that must all execute\nsuccessfully or not at all.","tags":[{"tag":"","text":"A Transaction is a collection of SQL statements that must all execute\nsuccessfully or not at all."}]},"methods":[{"name":"Transaction","docStart":11005,"docEnd":11033,"docs":{"brief":"Create a new transaction.","tags":[{"tag":"","text":"Create a new transaction."}]},"kind":null,"returnType":"Transaction","arguments":[]},{"name":"AddQuery","docStart":11069,"docEnd":11302,"docs":{"brief":"Adds a query to the transaction.","tags":[{"tag":"","text":"Adds a query to the transaction."},{"tag":"param:query","text":"Query string."},{"tag":"param:data","text":"Extra data value to pass to the final callback."},{"tag":"return","text":"The index of the query in the transaction's query list."}]},"kind":null,"returnType":"int","arguments":[{"type":"const char[]","name":"query","decl":"const char[] query"},{"type":"any","name":"data","decl":"any data"}]}],"properties":[]},{"name":"DBStatement","docStart":11372,"docEnd":11553,"docs":{"brief":"A DBStatement is a pre-compiled SQL query that may be executed multiple\ntimes with different parameters. A DBStatement holds a reference to the\nDatabase that prepared it.","tags":[{"tag":"","text":"A DBStatement is a pre-compiled SQL query that may be executed multiple\ntimes with different parameters. A DBStatement holds a reference to the\nDatabase that prepared it."}]},"methods":[{"name":"BindInt","docStart":11591,"docEnd":11961,"docs":{"brief":"Binds a parameter in a prepared statement to a given integer value.","tags":[{"tag":"","text":"Binds a parameter in a prepared statement to a given integer value."},{"tag":"param:param","text":"The parameter index (starting from 0)."},{"tag":"param:number","text":"The number to bind."},{"tag":"param:signed","text":"True to bind the number as signed, false to\nbind it as unsigned."},{"tag":"error","text":"Invalid parameter index, or SQL error."}]},"kind":null,"returnType":"void","arguments":[{"type":"int","name":"param","decl":"int param"},{"type":"int","name":"number","decl":"int number"},{"type":"bool","name":"signed","decl":"bool signed"}]},{"name":"BindFloat","docStart":12037,"docEnd":12293,"docs":{"brief":"Binds a parameter in a prepared statement to a given float value.","tags":[{"tag":"","text":"Binds a parameter in a prepared statement to a given float value."},{"tag":"param:param","text":"The parameter index (starting from 0)."},{"tag":"param:value","text":"The float number to bind."},{"tag":"error","text":"Invalid parameter index, or SQL error."}]},"kind":null,"returnType":"void","arguments":[{"type":"int","name":"param","decl":"int param"},{"type":"float","name":"value","decl":"float value"}]},{"name":"BindString","docStart":12354,"docEnd":12888,"docs":{"brief":"Binds a parameter in a prepared statement to a given string value.","tags":[{"tag":"","text":"Binds a parameter in a prepared statement to a given string value."},{"tag":"param:param","text":"The parameter index (starting from 0)."},{"tag":"param:value","text":"The string to bind."},{"tag":"param:copy","text":"Whether or not SourceMod should copy the value\nlocally if necessary.  If the string contents\nwon't change before calling SQL_Execute(), this\ncan be set to false for optimization."},{"tag":"error","text":"Invalid parameter index, or SQL error."}]},"kind":null,"returnType":"void","arguments":[{"type":"int","name":"param","decl":"int param"},{"type":"const char[]","name":"value","decl":"const char[] value"},{"type":"bool","name":"copy","decl":"bool copy"}]}],"properties":[]},{"name":"Database","docStart":14140,"docEnd":14275,"docs":{"brief":"A Database represents a live connection to a database, either over the\nwire, through a unix domain socket, or over an open file.","tags":[{"tag":"","text":"A Database represents a live connection to a database, either over the\nwire, through a unix domain socket, or over an open file."}]},"methods":[{"name":"Connect","docStart":14310,"docEnd":14593,"docs":{"brief":"Connects to a database asynchronously, so the game thread is not blocked.","tags":[{"tag":"","text":"Connects to a database asynchronously, so the game thread is not blocked."},{"tag":"param:callback","text":"Callback. If no driver was found, the owner is null."},{"tag":"param:name","text":"Database configuration name."},{"tag":"param:data","text":"Extra data value to pass to the callback."}]},"kind":null,"returnType":"void","arguments":[{"type":"SQLConnectCallback","name":"callback","decl":"SQLConnectCallback callback"},{"type":"const char[]","name":"name","decl":"const char[] name"},{"type":"any","name":"data","decl":"any data"}]},{"name":"SetCharset","docStart":14818,"docEnd":15119,"docs":{"brief":"Sets the character set of the connection.\nLike SET NAMES .. in mysql, but stays after connection problems.\n\nExample: \"utf8\", \"latin1\"","tags":[{"tag":"","text":"Sets the character set of the connection.\nLike SET NAMES .. in mysql, but stays after connection problems.\n\nExample: \"utf8\", \"latin1\""},{"tag":"param:characterset","text":"The character set string to change to."},{"tag":"return","text":"True, if character set was changed, false otherwise."}]},"kind":null,"returnType":"bool","arguments":[{"type":"const char[]","name":"charset","decl":"const char[] charset"}]},{"name":"Escape","docStart":15179,"docEnd":16235,"docs":{"brief":"Escapes a database string for literal insertion.  This is not needed\nfor binding strings in prepared statements.\n\nGenerally, database strings are inserted into queries enclosed in\nsingle quotes (').  If user input has a single quote in it, the\nquote needs to be escaped.  This function ensures that any unsafe\ncharacters are safely escaped according to the database engine and\nthe database's character set.\n\nNOTE: SourceMod only guarantees properly escaped strings when the query\nencloses the string in ''. While drivers tend to allow \" instead, the string\nmay be not be escaped (for example, on SQLite)!","tags":[{"tag":"","text":"Escapes a database string for literal insertion.  This is not needed\nfor binding strings in prepared statements.\n\nGenerally, database strings are inserted into queries enclosed in\nsingle quotes (').  If user input has a single quote in it, the\nquote needs to be escaped.  This function ensures that any unsafe\ncharacters are safely escaped according to the database engine and\nthe database's character set.\n\nNOTE: SourceMod only guarantees properly escaped strings when the query\nencloses the string in ''. While drivers tend to allow \" instead, the string\nmay be not be escaped (for example, on SQLite)!"},{"tag":"param:string","text":"String to quote."},{"tag":"param:buffer","text":"Buffer to store quoted string in."},{"tag":"param:maxlength","text":"Maximum length of the buffer."},{"tag":"param:written","text":"Optionally returns the number of bytes written."},{"tag":"return","text":"True on success, false if buffer is not big enough.\nThe buffer must be at least 2*strlen(string)+1."}]},"kind":null,"returnType":"bool","arguments":[{"type":"const char[]","name":"string","decl":"const char[] string"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"int&","name":"written","decl":"int& written"}]},{"name":"Format","docStart":16336,"docEnd":16790,"docs":{"brief":"Formats a string according to the SourceMod format rules (see documentation).\nAll format specifiers are escaped (see SQL_EscapeString) unless the '!' flag is used.","tags":[{"tag":"","text":"Formats a string according to the SourceMod format rules (see documentation).\nAll format specifiers are escaped (see SQL_EscapeString) unless the '!' flag is used."},{"tag":"param:buffer","text":"Destination string buffer."},{"tag":"param:maxlength","text":"Maximum length of output string buffer."},{"tag":"param:format","text":"Formatting rules."},{"tag":"param:...","text":"Variable number of format parameters."},{"tag":"return","text":"Number of cells written."}]},"kind":null,"returnType":"int","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"IsSameConnection","docStart":16889,"docEnd":16962,"docs":{"brief":"Returns whether a database is the same connection as another database.","tags":[{"tag":"","text":"Returns whether a database is the same connection as another database."}]},"kind":null,"returnType":"bool","arguments":[{"type":"Database","name":"other","decl":"Database other"}]},{"name":"Query","docStart":17022,"docEnd":17612,"docs":{"brief":"Executes a query via a thread. The result handle is passed through the\ncallback.\n\nThe database handle returned through the callback is always a new Handle,\nand if necessary, IsSameConnection() should be used to test against other\nconnections.\n\nThe result handle returned through the callback is temporary and destroyed\nat the end of the callback.","tags":[{"tag":"","text":"Executes a query via a thread. The result handle is passed through the\ncallback.\n\nThe database handle returned through the callback is always a new Handle,\nand if necessary, IsSameConnection() should be used to test against other\nconnections.\n\nThe result handle returned through the callback is temporary and destroyed\nat the end of the callback."},{"tag":"param:callback","text":"Callback."},{"tag":"param:query","text":"Query string."},{"tag":"param:data","text":"Extra data value to pass to the callback."},{"tag":"param:prio","text":"Priority queue to use."}]},"kind":null,"returnType":"void","arguments":[{"type":"SQLQueryCallback","name":"callback","decl":"SQLQueryCallback callback"},{"type":"const char[]","name":"query","decl":"const char[] query"},{"type":"any","name":"data","decl":"any data"},{"type":"DBPriority","name":"prio","decl":"DBPriority prio"}]},{"name":"Execute","docStart":17793,"docEnd":18296,"docs":{"brief":"Sends a transaction to the database thread. The transaction handle is\nautomatically closed. When the transaction completes, the optional\ncallback is invoked.","tags":[{"tag":"","text":"Sends a transaction to the database thread. The transaction handle is\nautomatically closed. When the transaction completes, the optional\ncallback is invoked."},{"tag":"param:txn","text":"A transaction handle."},{"tag":"param:onSuccess","text":"An optional callback to receive a successful transaction."},{"tag":"param:onError","text":"An optional callback to receive an error message."},{"tag":"param:data","text":"An optional value to pass to callbacks."},{"tag":"param:prio","text":"Priority queue to use."}]},"kind":null,"returnType":"void","arguments":[{"type":"Transaction","name":"txn","decl":"Transaction txn"},{"type":"SQLTxnSuccess","name":"onSuccess","decl":"SQLTxnSuccess onSuccess"},{"type":"SQLTxnFailure","name":"onError","decl":"SQLTxnFailure onError"},{"type":"any","name":"data","decl":"any data"},{"type":"DBPriority","name":"priority","decl":"DBPriority priority"}]}],"properties":[{"name":"Driver","docStart":14705,"docEnd":14756,"docs":{"brief":"Returns the driver for this database connection.","tags":[{"tag":"","text":"Returns the driver for this database connection."}]},"type":"DBDriver","getter":true,"setter":false}]}],"constants":[],"enums":[{"name":"DBResult","docStart":1649,"docEnd":1702,"docs":{"brief":"Describes a database field fetch status.","tags":[{"tag":"","text":"Describes a database field fetch status."}]},"entries":[{"name":"DBVal_Error","docStart":1747,"docEnd":1786,"docs":{"brief":"Column number/field is invalid.","tags":[{"tag":"","text":"Column number/field is invalid."}]}},{"name":"DBVal_TypeMismatch","docStart":1813,"docEnd":1866,"docs":{"brief":"You cannot retrieve this data with this type.","tags":[{"tag":"","text":"You cannot retrieve this data with this type."}]}},{"name":"DBVal_Null","docStart":1893,"docEnd":1925,"docs":{"brief":"Field has no data (NULL)","tags":[{"tag":"","text":"Field has no data (NULL)"}]}},{"name":"DBVal_Data","docStart":1952,"docEnd":1974,"docs":{"brief":"Field has data","tags":[{"tag":"","text":"Field has data"}]}}]},{"name":"DBBindType","docStart":1982,"docEnd":2019,"docs":{"brief":"Describes binding types.","tags":[{"tag":"","text":"Describes binding types."}]},"entries":[{"name":"DBBind_Int","docStart":2066,"docEnd":2090,"docs":{"brief":"Bind an integer.","tags":[{"tag":"","text":"Bind an integer."}]}},{"name":"DBBind_Float","docStart":2117,"docEnd":2138,"docs":{"brief":"Bind a float.","tags":[{"tag":"","text":"Bind a float."}]}},{"name":"DBBind_String","docStart":2165,"docEnd":2187,"docs":{"brief":"Bind a string.","tags":[{"tag":"","text":"Bind a string."}]}}]},{"name":"DBPriority","docStart":2195,"docEnd":2233,"docs":{"brief":"Threading priority level.","tags":[{"tag":"","text":"Threading priority level."}]},"entries":[{"name":"DBPrio_High","docStart":2280,"docEnd":2302,"docs":{"brief":"High priority.","tags":[{"tag":"","text":"High priority."}]}},{"name":"DBPrio_Normal","docStart":2329,"docEnd":2353,"docs":{"brief":"Normal priority.","tags":[{"tag":"","text":"Normal priority."}]}},{"name":"DBPrio_Low","docStart":2380,"docEnd":2401,"docs":{"brief":"Low priority.","tags":[{"tag":"","text":"Low priority."}]}}]}],"typesets":[{"name":"SQLTxnSuccess","docStart":0,"docEnd":0,"docs":null,"types":[{"type":"function void(Database db, any data, int numQueries, Handle[] results, any[] queryData)","docStart":9217,"docEnd":9652,"docs":{"brief":"Callback for a successful transaction.","tags":[{"tag":"","text":"Callback for a successful transaction."},{"tag":"param:db","text":"Database handle."},{"tag":"param:data","text":"Data value passed to SQL_ExecuteTransaction()."},{"tag":"param:numQueries","text":"Number of queries executed in the transaction."},{"tag":"param:results","text":"An array of Query handle results, one for each of numQueries. They are closed automatically."},{"tag":"param:queryData","text":"An array of each data value passed to SQL_AddQuery()."}]}},{"type":"function void(Database db, any data, int numQueries, DBResultSet[] results, any[] queryData)","docStart":9750,"docEnd":10184,"docs":{"brief":"Callback for a successful transaction.","tags":[{"tag":"","text":"Callback for a successful transaction."},{"tag":"param:db","text":"Database handle."},{"tag":"param:data","text":"Data value passed to SQL_ExecuteTransaction()."},{"tag":"param:numQueries","text":"Number of queries executed in the transaction."},{"tag":"param:results","text":"An array of DBResultSet results, one for each of numQueries. They are closed automatically."},{"tag":"param:queryData","text":"An array of each data value passed to SQL_AddQuery()."}]}}]}],"typedefs":[{"name":"SQLTxnFailure","docStart":10289,"docEnd":10727,"docs":{"brief":"Callback for a failed transaction.","tags":[{"tag":"","text":"Callback for a failed transaction."},{"tag":"param:db","text":"Database handle."},{"tag":"param:data","text":"Data value passed to SQL_ExecuteTransaction()."},{"tag":"param:numQueries","text":"Number of queries executed in the transaction."},{"tag":"param:error","text":"Error message."},{"tag":"param:failIndex","text":"Index of the query that failed, or -1 if something else."},{"tag":"param:queryData","text":"An array of each data value passed to SQL_AddQuery()."}]},"type":"function void(Database db, any data, int numQueries, const char[] error, int failIndex, any[] queryData)"},{"name":"SQLConnectCallback","docStart":12971,"docEnd":13418,"docs":{"brief":"Callback for receiving asynchronous database connections.","tags":[{"tag":"","text":"Callback for receiving asynchronous database connections."},{"tag":"param:db","text":"Handle to the database connection."},{"tag":"param:error","text":"Error string if there was an error.  The error could be\nempty even if an error condition exists, so it is important\nto check the actual Handle value instead."},{"tag":"param:data","text":"Data passed in via the original threaded invocation."}]},"type":"function void(Database db, const char[] error, any data)"},{"name":"SQLQueryCallback","docStart":13511,"docEnd":14028,"docs":{"brief":"Callback for receiving asynchronous database query results.","tags":[{"tag":"","text":"Callback for receiving asynchronous database query results."},{"tag":"param:db","text":"Cloned handle to the database connection."},{"tag":"param:results","text":"Result object, or null on failure."},{"tag":"param:error","text":"Error string if there was an error.  The error could be\nempty even if an error condition exists, so it is important\nto check the actual results value instead."},{"tag":"param:data","text":"Data passed in via the original threaded invocation."}]},"type":"function void(Database db, DBResultSet results, const char[] error, any data)"},{"name":"SQLTCallback","docStart":40309,"docEnd":40843,"docs":{"brief":"General callback for threaded SQL stuff.","tags":[{"tag":"","text":"General callback for threaded SQL stuff."},{"tag":"param:owner","text":"Parent object of the Handle (or INVALID_HANDLE if none)."},{"tag":"param:hndl","text":"Handle to the child object (or INVALID_HANDLE if none)."},{"tag":"param:error","text":"Error string if there was an error.  The error could be\nempty even if an error condition exists, so it is important\nto check the actual Handle value instead."},{"tag":"param:data","text":"Data passed in via the original threaded invocation."}]},"type":"function void(Handle owner, Handle hndl, const char[] error, any data)"}]}