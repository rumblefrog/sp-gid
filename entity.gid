{"functions":[{"name":"GetMaxEntities","docStart":3855,"docEnd":4129,"docs":{"brief":"Returns the maximum number of networked entities.\n\nNote: For legacy reasons, this only returns the maximum\nnetworked entities (maximum edicts), rather than total\nmaximum entities.","tags":[{"tag":"","text":"Returns the maximum number of networked entities.\n\nNote: For legacy reasons, this only returns the maximum\nnetworked entities (maximum edicts), rather than total\nmaximum entities."},{"tag":"return","text":"Maximum number of networked entities."}]},"kind":"native","returnType":"int","arguments":[]},{"name":"GetEntityCount","docStart":4163,"docEnd":4457,"docs":{"brief":"Returns the number of networked entities in the server.\n\nNote: For legacy reasons, this only returns the current count\nof networked entities (current edicts), rather than total\ncount of current entities.","tags":[{"tag":"","text":"Returns the number of networked entities in the server.\n\nNote: For legacy reasons, this only returns the current count\nof networked entities (current edicts), rather than total\ncount of current entities."},{"tag":"return","text":"Number of entities in the server."}]},"kind":"native","returnType":"int","arguments":[]},{"name":"IsValidEntity","docStart":4491,"docEnd":4731,"docs":{"brief":"Returns whether or not an entity is valid.  Returns false\nif there is no matching CBaseEntity for this entity index.","tags":[{"tag":"","text":"Returns whether or not an entity is valid.  Returns false\nif there is no matching CBaseEntity for this entity index."},{"tag":"param:entity","text":"Index of the entity."},{"tag":"return","text":"True if valid, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"entity","decl":"int entity"}]},{"name":"IsValidEdict","docStart":4775,"docEnd":4941,"docs":{"brief":"Returns whether or not an edict index is valid.","tags":[{"tag":"","text":"Returns whether or not an edict index is valid."},{"tag":"param:edict","text":"Index of the edict."},{"tag":"return","text":"True if valid, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"edict","decl":"int edict"}]},{"name":"IsEntNetworkable","docStart":4983,"docEnd":5192,"docs":{"brief":"Returns whether or not an entity has a valid networkable edict.","tags":[{"tag":"","text":"Returns whether or not an entity has a valid networkable edict."},{"tag":"param:entity","text":"Index of the entity."},{"tag":"return","text":"True if networkable, false if invalid or not networkable."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"entity","decl":"int entity"}]},{"name":"CreateEdict","docStart":5239,"docEnd":5370,"docs":{"brief":"Creates a new edict (the basis of a networkable entity)","tags":[{"tag":"","text":"Creates a new edict (the basis of a networkable entity)"},{"tag":"return","text":"Index of the edict, 0 on failure."}]},"kind":"native","returnType":"int","arguments":[]},{"name":"RemoveEdict","docStart":5401,"docEnd":5541,"docs":{"brief":"Removes an edict from the world.","tags":[{"tag":"","text":"Removes an edict from the world."},{"tag":"param:edict","text":"Index of the edict."},{"tag":"error","text":"Invalid edict index."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"edict","decl":"int edict"}]},{"name":"RemoveEntity","docStart":5582,"docEnd":5721,"docs":{"brief":"Marks an entity for deletion.","tags":[{"tag":"","text":"Marks an entity for deletion."},{"tag":"param:entity","text":"Index of the entity."},{"tag":"error","text":"Invalid entity index."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"entity","decl":"int entity"}]},{"name":"GetEdictFlags","docStart":5764,"docEnd":5982,"docs":{"brief":"Returns the flags on an edict.  These are not the same as entity flags.","tags":[{"tag":"","text":"Returns the flags on an edict.  These are not the same as entity flags."},{"tag":"param:edict","text":"Index of the entity."},{"tag":"return","text":"Edict flags."},{"tag":"error","text":"Invalid edict index."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"edict","decl":"int edict"}]},{"name":"SetEdictFlags","docStart":6024,"docEnd":6240,"docs":{"brief":"Sets the flags on an edict.  These are not the same as entity flags.","tags":[{"tag":"","text":"Sets the flags on an edict.  These are not the same as entity flags."},{"tag":"param:edict","text":"Index of the entity."},{"tag":"param:flags","text":"Flags to set."},{"tag":"error","text":"Invalid edict index."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"edict","decl":"int edict"},{"type":"int","name":"flags","decl":"int flags"}]},{"name":"GetEdictClassname","docStart":6294,"docEnd":6575,"docs":{"brief":"Retrieves an edict classname.","tags":[{"tag":"","text":"Retrieves an edict classname."},{"tag":"param:edict","text":"Index of the entity."},{"tag":"param:clsname","text":"Buffer to store the classname."},{"tag":"param:maxlength","text":"Maximum length of the buffer."},{"tag":"return","text":"True on success, false if there is no classname set."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"edict","decl":"int edict"},{"type":"char[]","name":"clsname","decl":"char[] clsname"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"GetEntityNetClass","docStart":6653,"docEnd":7097,"docs":{"brief":"Retrieves an entity's networkable serverclass name.\nThis is not the same as the classname and is used for networkable state changes.","tags":[{"tag":"","text":"Retrieves an entity's networkable serverclass name.\nThis is not the same as the classname and is used for networkable state changes."},{"tag":"param:edict","text":"Index of the entity."},{"tag":"param:clsname","text":"Buffer to store the serverclass name."},{"tag":"param:maxlength","text":"Maximum length of the buffer."},{"tag":"return","text":"True on success, false if the edict is not networkable."},{"tag":"error","text":"Invalid edict index."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"edict","decl":"int edict"},{"type":"char[]","name":"clsname","decl":"char[] clsname"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"ChangeEdictState","docStart":8212,"docEnd":8663,"docs":{"brief":"Marks an entity as state changed.  This can be useful if you set an offset\nand wish for it to be immediately changed over the network.  By default this\nis not done for offset setting functions.","tags":[{"tag":"","text":"Marks an entity as state changed.  This can be useful if you set an offset\nand wish for it to be immediately changed over the network.  By default this\nis not done for offset setting functions."},{"tag":"param:edict","text":"Index to the edict."},{"tag":"param:offset","text":"Offset to mark as changed.  If 0,\nthe entire edict is marked as changed."},{"tag":"error","text":"Invalid entity or offset out of bounds."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"edict","decl":"int edict"},{"type":"int","name":"offset","decl":"int offset"}]},{"name":"GetEntData","docStart":8725,"docEnd":9128,"docs":{"brief":"Peeks into an entity's object data and retrieves the integer value at\nthe given offset.","tags":[{"tag":"","text":"Peeks into an entity's object data and retrieves the integer value at\nthe given offset."},{"tag":"param:entity","text":"Edict index."},{"tag":"param:offset","text":"Offset to use."},{"tag":"param:size","text":"Number of bytes to read (valid values are 1, 2, or 4)."},{"tag":"return","text":"Value at the given memory location."},{"tag":"error","text":"Invalid entity or offset out of reasonable bounds."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"int","name":"offset","decl":"int offset"},{"type":"int","name":"size","decl":"int size"}]},{"name":"SetEntData","docStart":9192,"docEnd":9641,"docs":{"brief":"Peeks into an entity's object data and sets the integer value at\nthe given offset.","tags":[{"tag":"","text":"Peeks into an entity's object data and sets the integer value at\nthe given offset."},{"tag":"param:entity","text":"Edict index."},{"tag":"param:offset","text":"Offset to use."},{"tag":"param:value","text":"Value to set."},{"tag":"param:size","text":"Number of bytes to write (valid values are 1, 2, or 4)."},{"tag":"param:changeState","text":"If true, change will be sent over the network."},{"tag":"error","text":"Invalid entity or offset out of reasonable bounds."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"int","name":"offset","decl":"int offset"},{"type":"any","name":"value","decl":"any value"},{"type":"int","name":"size","decl":"int size"},{"type":"bool","name":"changeState","decl":"bool changeState"}]},{"name":"GetEntDataFloat","docStart":9741,"docEnd":10062,"docs":{"brief":"Peeks into an entity's object data and retrieves the float value at\nthe given offset.","tags":[{"tag":"","text":"Peeks into an entity's object data and retrieves the float value at\nthe given offset."},{"tag":"param:entity","text":"Edict index."},{"tag":"param:offset","text":"Offset to use."},{"tag":"return","text":"Value at the given memory location."},{"tag":"error","text":"Invalid entity or offset out of reasonable bounds."}]},"kind":"native","returnType":"float","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"int","name":"offset","decl":"int offset"}]},{"name":"SetEntDataFloat","docStart":10121,"docEnd":10487,"docs":{"brief":"Peeks into an entity's object data and sets the float value at\nthe given offset.","tags":[{"tag":"","text":"Peeks into an entity's object data and sets the float value at\nthe given offset."},{"tag":"param:entity","text":"Edict index."},{"tag":"param:offset","text":"Offset to use."},{"tag":"param:value","text":"Value to set."},{"tag":"param:changeState","text":"If true, change will be sent over the network."},{"tag":"error","text":"Invalid entity or offset out of reasonable bounds."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"int","name":"offset","decl":"int offset"},{"type":"float","name":"value","decl":"float value"},{"type":"bool","name":"changeState","decl":"bool changeState"}]},{"name":"GetEntDataEnt","docStart":0,"docEnd":0,"docs":null,"kind":"native","returnType":"int","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"int","name":"offset","decl":"int offset"}]},{"name":"SetEntDataEnt","docStart":0,"docEnd":0,"docs":null,"kind":"native","returnType":"void","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"int","name":"offset","decl":"int offset"},{"type":"int","name":"other","decl":"int other"},{"type":"bool","name":"changeState","decl":"bool changeState"}]},{"name":"GetEntDataEnt2","docStart":12143,"docEnd":12777,"docs":{"brief":"Peeks into an entity's object data and retrieves the entity index\nat the given offset.\n\nNote: This will only work on offsets that are stored as \"entity\nhandles\" (which usually looks like m_h* in properties).  These\nare not SourceMod Handles, but internal Source structures.","tags":[{"tag":"","text":"Peeks into an entity's object data and retrieves the entity index\nat the given offset.\n\nNote: This will only work on offsets that are stored as \"entity\nhandles\" (which usually looks like m_h* in properties).  These\nare not SourceMod Handles, but internal Source structures."},{"tag":"param:entity","text":"Edict index."},{"tag":"param:offset","text":"Offset to use."},{"tag":"return","text":"Entity index at the given location.  If there is no entity,\nor the stored entity is invalid, then -1 is returned."},{"tag":"error","text":"Invalid input entity, or offset out of reasonable bounds."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"int","name":"offset","decl":"int offset"}]},{"name":"SetEntDataEnt2","docStart":12833,"docEnd":13432,"docs":{"brief":"Peeks into an entity's object data and sets the entity index at the\ngiven offset.\n\nNote: This will only work on offsets that are stored as \"entity\nhandles\" (which usually looks like m_h* in properties).  These\nare not SourceMod Handles, but internal Source structures.","tags":[{"tag":"","text":"Peeks into an entity's object data and sets the entity index at the\ngiven offset.\n\nNote: This will only work on offsets that are stored as \"entity\nhandles\" (which usually looks like m_h* in properties).  These\nare not SourceMod Handles, but internal Source structures."},{"tag":"param:entity","text":"Edict index."},{"tag":"param:offset","text":"Offset to use."},{"tag":"param:other","text":"Entity index to set, or -1 to clear."},{"tag":"param:changeState","text":"If true, change will be sent over the network."},{"tag":"error","text":"Invalid input entity, or offset out of reasonable bounds."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"int","name":"offset","decl":"int offset"},{"type":"int","name":"other","decl":"int other"},{"type":"bool","name":"changeState","decl":"bool changeState"}]},{"name":"GetEntDataVector","docStart":13524,"docEnd":13964,"docs":{"brief":"Peeks into an entity's object data and retrieves the vector at the\ngiven offset.","tags":[{"tag":"","text":"Peeks into an entity's object data and retrieves the vector at the\ngiven offset."},{"tag":"note","text":"Both a Vector and a QAngle are three floats.  This is a\nconvenience function and will work with both types."},{"tag":"param:entity","text":"Edict index."},{"tag":"param:offset","text":"Offset to use."},{"tag":"param:vec","text":"Vector buffer to store data in."},{"tag":"error","text":"Invalid entity or offset out of reasonable bounds."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"int","name":"offset","decl":"int offset"},{"type":"float[3]","name":"vec","decl":"float vec[3]"}]},{"name":"SetEntDataVector","docStart":14037,"docEnd":14527,"docs":{"brief":"Peeks into an entity's object data and sets the vector at the given\noffset.","tags":[{"tag":"","text":"Peeks into an entity's object data and sets the vector at the given\noffset."},{"tag":"note","text":"Both a Vector and a QAngle are three floats.  This is a\nconvenience function and will work with both types."},{"tag":"param:entity","text":"Edict index."},{"tag":"param:offset","text":"Offset to use."},{"tag":"param:vec","text":"Vector to set."},{"tag":"param:changeState","text":"If true, change will be sent over the network."},{"tag":"error","text":"Invalid entity or offset out of reasonable bounds."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"int","name":"offset","decl":"int offset"},{"type":"const float[3]","name":"vec","decl":"const float vec[3]"},{"type":"bool","name":"changeState","decl":"bool changeState"}]},{"name":"GetEntDataString","docStart":14630,"docEnd":15061,"docs":{"brief":"Peeks into an entity's object data and retrieves the string at\nthe given offset.","tags":[{"tag":"","text":"Peeks into an entity's object data and retrieves the string at\nthe given offset."},{"tag":"param:entity","text":"Edict index."},{"tag":"param:offset","text":"Offset to use."},{"tag":"param:buffer","text":"Destination string buffer."},{"tag":"param:maxlen","text":"Maximum length of output string buffer."},{"tag":"return","text":"Number of non-null bytes written."},{"tag":"error","text":"Invalid entity or offset out of reasonable bounds."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"int","name":"offset","decl":"int offset"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlen","decl":"int maxlen"}]},{"name":"SetEntDataString","docStart":15146,"docEnd":15626,"docs":{"brief":"Peeks into an entity's object data and sets the string at\nthe given offset.","tags":[{"tag":"","text":"Peeks into an entity's object data and sets the string at\nthe given offset."},{"tag":"param:entity","text":"Edict index."},{"tag":"param:offset","text":"Offset to use."},{"tag":"param:buffer","text":"String to set."},{"tag":"param:maxlen","text":"Maximum length of bytes to write."},{"tag":"param:changeState","text":"If true, change will be sent over the network."},{"tag":"return","text":"Number of non-null bytes written."},{"tag":"error","text":"Invalid entity or offset out of reasonable bounds."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"int","name":"offset","decl":"int offset"},{"type":"const char[]","name":"buffer","decl":"const char[] buffer"},{"type":"int","name":"maxlen","decl":"int maxlen"},{"type":"bool","name":"changeState","decl":"bool changeState"}]},{"name":"FindSendPropOffs","docStart":0,"docEnd":0,"docs":null,"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"cls","decl":"const char[] cls"},{"type":"const char[]","name":"prop","decl":"const char[] prop"}]},{"name":"FindSendPropInfo","docStart":16671,"docEnd":17572,"docs":{"brief":"Given a ServerClass name, finds a networkable send property offset.\nThis information is cached for future calls.","tags":[{"tag":"","text":"Given a ServerClass name, finds a networkable send property offset.\nThis information is cached for future calls."},{"tag":"param:cls","text":"Classname."},{"tag":"param:prop","text":"Property name."},{"tag":"param:type","text":"Optional parameter to store the type."},{"tag":"param:num_bits","text":"Optional parameter to store the number of bits the field\nuses, if applicable (otherwise 0 is stored).  The number\nof bits varies for integers and floats, and is always 0\nfor strings."},{"tag":"param:local_offset","text":"Optional parameter to store the local offset, as\nFindSendPropOffs() would return."},{"tag":"return","text":"On success, returns an absolutely computed offset.\nIf no offset is available, 0 is returned.\nIf the property is not found, -1 is returned."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"cls","decl":"const char[] cls"},{"type":"const char[]","name":"prop","decl":"const char[] prop"},{"type":"PropFieldType&","name":"type","decl":"PropFieldType& type"},{"type":"int&","name":"num_bits","decl":"int& num_bits"},{"type":"int&","name":"local_offset","decl":"int& local_offset"}]},{"name":"FindDataMapOffs","docStart":0,"docEnd":0,"docs":null,"kind":"native","returnType":"int","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"const char[]","name":"prop","decl":"const char[] prop"},{"type":"PropFieldType&","name":"type","decl":"PropFieldType& type"},{"type":"int&","name":"num_bits","decl":"int& num_bits"}]},{"name":"FindDataMapInfo","docStart":18663,"docEnd":19340,"docs":{"brief":"Given an entity, finds a nested datamap property offset.\nThis information is cached for future calls.","tags":[{"tag":"","text":"Given an entity, finds a nested datamap property offset.\nThis information is cached for future calls."},{"tag":"param:entity","text":"Entity index."},{"tag":"param:prop","text":"Property name."},{"tag":"param:type","text":"Optional parameter to store the type."},{"tag":"param:num_bits","text":"Optional parameter to store the number of bits the field\nuses.  The bit count will either be 1 (for boolean) or\ndivisible by 8 (including 0 if unknown)."},{"tag":"param:local_offset","text":"Optional parameter to store the local offset, as\nFindDataMapOffs() would return."},{"tag":"return","text":"An offset, or -1 on failure."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"const char[]","name":"prop","decl":"const char[] prop"},{"type":"PropFieldType&","name":"type","decl":"PropFieldType& type"},{"type":"int&","name":"num_bits","decl":"int& num_bits"},{"type":"int&","name":"local_offset","decl":"int& local_offset"}]},{"name":"GetEntSendPropOffs","docStart":19525,"docEnd":19930,"docs":{"brief":"Wrapper function for finding a send property for a particular entity.","tags":[{"tag":"","text":"Wrapper function for finding a send property for a particular entity."},{"tag":"param:ent","text":"Entity index."},{"tag":"param:prop","text":"Property name."},{"tag":"param:actual","text":"Defaults to false for backwards compatibility.\nIf true, the newer FindSendPropInfo() function\nis used instead."},{"tag":"return","text":"An offset, or -1 on failure."}]},"kind":"stock","returnType":"int","arguments":[{"type":"int","name":"ent","decl":"int ent"},{"type":"const char[]","name":"prop","decl":"const char[] prop"},{"type":"bool","name":"actual","decl":"bool actual"}]},{"name":"HasEntProp","docStart":20243,"docEnd":20543,"docs":{"brief":"Checks if an entity property exists on an entity.","tags":[{"tag":"","text":"Checks if an entity property exists on an entity."},{"tag":"param:entity","text":"Entity/edict index."},{"tag":"param:type","text":"Property type."},{"tag":"param:prop","text":"Property name."},{"tag":"return","text":"Whether the property exists on the entity."},{"tag":"error","text":"Invalid entity."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"PropType","name":"type","decl":"PropType type"},{"type":"const char[]","name":"prop","decl":"const char[] prop"}]},{"name":"GetEntProp","docStart":20899,"docEnd":21671,"docs":{"brief":"Retrieves an integer value from an entity's property.\n\nThis function is considered safer and more robust over GetEntData,\nbecause it performs strict offset checking and typing rules.","tags":[{"tag":"","text":"Retrieves an integer value from an entity's property.\n\nThis function is considered safer and more robust over GetEntData,\nbecause it performs strict offset checking and typing rules."},{"tag":"param:entity","text":"Entity/edict index."},{"tag":"param:type","text":"Property type."},{"tag":"param:prop","text":"Property name."},{"tag":"param:size","text":"Number of bytes to write (valid values are 1, 2, or 4).\nThis value is auto-detected, and the size parameter is\nonly used as a fallback in case detection fails."},{"tag":"param:element","text":"Element # (starting from 0) if property is an array."},{"tag":"return","text":"Value at the given property offset."},{"tag":"error","text":"Invalid entity or property not found."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"PropType","name":"type","decl":"PropType type"},{"type":"const char[]","name":"prop","decl":"const char[] prop"},{"type":"int","name":"size","decl":"int size"},{"type":"int","name":"element","decl":"int element"}]},{"name":"SetEntProp","docStart":21772,"docEnd":22528,"docs":{"brief":"Sets an integer value in an entity's property.\n\nThis function is considered safer and more robust over SetEntData,\nbecause it performs strict offset checking and typing rules.","tags":[{"tag":"","text":"Sets an integer value in an entity's property.\n\nThis function is considered safer and more robust over SetEntData,\nbecause it performs strict offset checking and typing rules."},{"tag":"param:entity","text":"Entity/edict index."},{"tag":"param:type","text":"Property type."},{"tag":"param:prop","text":"Property name."},{"tag":"param:value","text":"Value to set."},{"tag":"param:size","text":"Number of bytes to write (valid values are 1, 2, or 4).\nThis value is auto-detected, and the size parameter is\nonly used as a fallback in case detection fails."},{"tag":"param:element","text":"Element # (starting from 0) if property is an array."},{"tag":"error","text":"Invalid entity or offset out of reasonable bounds."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"PropType","name":"type","decl":"PropType type"},{"type":"const char[]","name":"prop","decl":"const char[] prop"},{"type":"any","name":"value","decl":"any value"},{"type":"int","name":"size","decl":"int size"},{"type":"int","name":"element","decl":"int element"}]},{"name":"GetEntPropFloat","docStart":22641,"docEnd":23193,"docs":{"brief":"Retrieves a float value from an entity's property.\n\nThis function is considered safer and more robust over GetEntDataFloat,\nbecause it performs strict offset checking and typing rules.","tags":[{"tag":"","text":"Retrieves a float value from an entity's property.\n\nThis function is considered safer and more robust over GetEntDataFloat,\nbecause it performs strict offset checking and typing rules."},{"tag":"param:entity","text":"Entity/edict index."},{"tag":"param:type","text":"Property type."},{"tag":"param:prop","text":"Property name."},{"tag":"param:element","text":"Element # (starting from 0) if property is an array."},{"tag":"return","text":"Value at the given property offset."},{"tag":"error","text":"Invalid entity or offset out of reasonable bounds."}]},"kind":"native","returnType":"float","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"PropType","name":"type","decl":"PropType type"},{"type":"const char[]","name":"prop","decl":"const char[] prop"},{"type":"int","name":"element","decl":"int element"}]},{"name":"SetEntPropFloat","docStart":23289,"docEnd":23812,"docs":{"brief":"Sets a float value in an entity's property.\n\nThis function is considered safer and more robust over SetEntDataFloat,\nbecause it performs strict offset checking and typing rules.","tags":[{"tag":"","text":"Sets a float value in an entity's property.\n\nThis function is considered safer and more robust over SetEntDataFloat,\nbecause it performs strict offset checking and typing rules."},{"tag":"param:entity","text":"Entity/edict index."},{"tag":"param:type","text":"Property type."},{"tag":"param:prop","text":"Property name."},{"tag":"param:value","text":"Value to set."},{"tag":"param:element","text":"Element # (starting from 0) if property is an array."},{"tag":"error","text":"Invalid entity or offset out of reasonable bounds."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"PropType","name":"type","decl":"PropType type"},{"type":"const char[]","name":"prop","decl":"const char[] prop"},{"type":"float","name":"value","decl":"float value"},{"type":"int","name":"element","decl":"int element"}]},{"name":"GetEntPropEnt","docStart":23920,"docEnd":24595,"docs":{"brief":"Retrieves an entity index from an entity's property.\n\nThis function is considered safer and more robust over GetEntDataEnt*,\nbecause it performs strict offset checking and typing rules.","tags":[{"tag":"","text":"Retrieves an entity index from an entity's property.\n\nThis function is considered safer and more robust over GetEntDataEnt*,\nbecause it performs strict offset checking and typing rules."},{"tag":"param:entity","text":"Entity/edict index."},{"tag":"param:type","text":"Property type."},{"tag":"param:prop","text":"Property name."},{"tag":"param:element","text":"Element # (starting from 0) if property is an array."},{"tag":"return","text":"Entity index at the given property.\nIf there is no entity, or the entity is not valid,\nthen -1 is returned."},{"tag":"error","text":"Invalid entity or offset out of reasonable bounds."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"PropType","name":"type","decl":"PropType type"},{"type":"const char[]","name":"prop","decl":"const char[] prop"},{"type":"int","name":"element","decl":"int element"}]},{"name":"SetEntPropEnt","docStart":24687,"docEnd":25234,"docs":{"brief":"Sets an entity index in an entity's property.\n\nThis function is considered safer and more robust over SetEntDataEnt*,\nbecause it performs strict offset checking and typing rules.","tags":[{"tag":"","text":"Sets an entity index in an entity's property.\n\nThis function is considered safer and more robust over SetEntDataEnt*,\nbecause it performs strict offset checking and typing rules."},{"tag":"param:entity","text":"Entity/edict index."},{"tag":"param:type","text":"Property type."},{"tag":"param:prop","text":"Property name."},{"tag":"param:other","text":"Entity index to set, or -1 to unset."},{"tag":"param:element","text":"Element # (starting from 0) if property is an array."},{"tag":"error","text":"Invalid entity or offset out of reasonable bounds."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"PropType","name":"type","decl":"PropType type"},{"type":"const char[]","name":"prop","decl":"const char[] prop"},{"type":"int","name":"other","decl":"int other"},{"type":"int","name":"element","decl":"int element"}]},{"name":"GetEntPropVector","docStart":25338,"docEnd":25968,"docs":{"brief":"Retrieves a vector of floats from an entity, given a named network property.\n\nThis function is considered safer and more robust over GetEntDataVector,\nbecause it performs strict offset checking and typing rules.","tags":[{"tag":"","text":"Retrieves a vector of floats from an entity, given a named network property.\n\nThis function is considered safer and more robust over GetEntDataVector,\nbecause it performs strict offset checking and typing rules."},{"tag":"param:entity","text":"Entity/edict index."},{"tag":"param:type","text":"Property type."},{"tag":"param:prop","text":"Property name."},{"tag":"param:vec","text":"Vector buffer to store data in."},{"tag":"param:element","text":"Element # (starting from 0) if property is an array."},{"tag":"error","text":"Invalid entity, property not found, or property not\nactually a vector data type."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"PropType","name":"type","decl":"PropType type"},{"type":"const char[]","name":"prop","decl":"const char[] prop"},{"type":"float[3]","name":"vec","decl":"float vec[3]"},{"type":"int","name":"element","decl":"int element"}]},{"name":"SetEntPropVector","docStart":26078,"docEnd":26684,"docs":{"brief":"Sets a vector of floats in an entity, given a named network property.\n\nThis function is considered safer and more robust over SetEntDataVector,\nbecause it performs strict offset checking and typing rules.","tags":[{"tag":"","text":"Sets a vector of floats in an entity, given a named network property.\n\nThis function is considered safer and more robust over SetEntDataVector,\nbecause it performs strict offset checking and typing rules."},{"tag":"param:entity","text":"Entity/edict index."},{"tag":"param:type","text":"Property type."},{"tag":"param:prop","text":"Property name."},{"tag":"param:vec","text":"Vector to set."},{"tag":"param:element","text":"Element # (starting from 0) if property is an array."},{"tag":"error","text":"Invalid entity, property not found, or property not\nactually a vector data type."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"PropType","name":"type","decl":"PropType type"},{"type":"const char[]","name":"prop","decl":"const char[] prop"},{"type":"const float[3]","name":"vec","decl":"const float vec[3]"},{"type":"int","name":"element","decl":"int element"}]},{"name":"GetEntPropString","docStart":26800,"docEnd":27336,"docs":{"brief":"Gets a network property as a string.","tags":[{"tag":"","text":"Gets a network property as a string."},{"tag":"param:entity","text":"Edict index."},{"tag":"param:type","text":"Property type."},{"tag":"param:prop","text":"Property to use."},{"tag":"param:buffer","text":"Destination string buffer."},{"tag":"param:maxlen","text":"Maximum length of output string buffer."},{"tag":"param:element","text":"Element # (starting from 0) if property is an array."},{"tag":"return","text":"Number of non-null bytes written."},{"tag":"error","text":"Invalid entity, offset out of reasonable bounds, or property is not a valid string."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"PropType","name":"type","decl":"PropType type"},{"type":"const char[]","name":"prop","decl":"const char[] prop"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlen","decl":"int maxlen"},{"type":"int","name":"element","decl":"int element"}]},{"name":"SetEntPropString","docStart":27458,"docEnd":27917,"docs":{"brief":"Sets a network property as a string.","tags":[{"tag":"","text":"Sets a network property as a string."},{"tag":"param:entity","text":"Edict index."},{"tag":"param:type","text":"Property type."},{"tag":"param:prop","text":"Property to use."},{"tag":"param:buffer","text":"String to set."},{"tag":"param:element","text":"Element # (starting from 0) if property is an array."},{"tag":"return","text":"Number of non-null bytes written."},{"tag":"error","text":"Invalid entity, offset out of reasonable bounds, or property is not a valid string."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"PropType","name":"type","decl":"PropType type"},{"type":"const char[]","name":"prop","decl":"const char[] prop"},{"type":"const char[]","name":"buffer","decl":"const char[] buffer"},{"type":"int","name":"element","decl":"int element"}]},{"name":"GetEntPropArraySize","docStart":28033,"docEnd":28397,"docs":{"brief":"Retrieves the count of values that an entity property's array can store.","tags":[{"tag":"","text":"Retrieves the count of values that an entity property's array can store."},{"tag":"param:entity","text":"Entity/edict index."},{"tag":"param:type","text":"Property type."},{"tag":"param:prop","text":"Property name."},{"tag":"return","text":"Size of array (in elements) or 1 if property is not an array."},{"tag":"error","text":"Invalid entity or property not found."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"PropType","name":"type","decl":"PropType type"},{"type":"const char[]","name":"prop","decl":"const char[] prop"}]},{"name":"GetEntDataArray","docStart":28480,"docEnd":28873,"docs":{"brief":"Copies an array of cells from an entity at a given offset.","tags":[{"tag":"","text":"Copies an array of cells from an entity at a given offset."},{"tag":"param:entity","text":"Entity index."},{"tag":"param:offset","text":"Offset to use."},{"tag":"param:array","text":"Array to read into."},{"tag":"param:arraySize","text":"Number of values to read."},{"tag":"param:dataSize","text":"Size of each value in bytes (1, 2, or 4)."},{"tag":"error","text":"Invalid entity or offset out of reasonable bounds."}]},"kind":"stock","returnType":"void","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"int","name":"offset","decl":"int offset"},{"type":"int[]","name":"array","decl":"int[] array"},{"type":"int","name":"arraySize","decl":"int arraySize"},{"type":"int","name":"dataSize","decl":"int dataSize"}]},{"name":"SetEntDataArray","docStart":29090,"docEnd":29570,"docs":{"brief":"Copies an array of cells to an entity at a given offset.","tags":[{"tag":"","text":"Copies an array of cells to an entity at a given offset."},{"tag":"param:entity","text":"Entity index."},{"tag":"param:offset","text":"Offset to use."},{"tag":"param:array","text":"Array of values to copy."},{"tag":"param:arraySize","text":"Number of values to copy."},{"tag":"param:dataSize","text":"Size of each value in bytes (1, 2, or 4)."},{"tag":"param:changeState","text":"True to set the network state as changed; false otherwise."},{"tag":"error","text":"Invalid entity or offset out of reasonable bounds."}]},"kind":"stock","returnType":"void","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"int","name":"offset","decl":"int offset"},{"type":"const int[]","name":"array","decl":"const int[] array"},{"type":"int","name":"arraySize","decl":"int arraySize"},{"type":"int","name":"dataSize","decl":"int dataSize"},{"type":"bool","name":"changeState","decl":"bool changeState"}]},{"name":"GetEntityAddress","docStart":29829,"docEnd":30011,"docs":{"brief":"Gets the memory address of an entity.","tags":[{"tag":"","text":"Gets the memory address of an entity."},{"tag":"param:entity","text":"Entity index."},{"tag":"return","text":"Address of the entity."},{"tag":"error","text":"Invalid entity."}]},"kind":"native","returnType":"Address","arguments":[{"type":"int","name":"entity","decl":"int entity"}]},{"name":"GetEntityClassname","docStart":30061,"docEnd":30443,"docs":{"brief":"Retrieves the classname of an entity.\nThis is like GetEdictClassname(), except it works for ALL\nentities, not just edicts.","tags":[{"tag":"","text":"Retrieves the classname of an entity.\nThis is like GetEdictClassname(), except it works for ALL\nentities, not just edicts."},{"tag":"param:entity","text":"Index of the entity."},{"tag":"param:clsname","text":"Buffer to store the classname."},{"tag":"param:maxlength","text":"Maximum length of the buffer."},{"tag":"return","text":"True on success, false if there is no classname set."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"int","name":"entity","decl":"int entity"},{"type":"char[]","name":"clsname","decl":"char[] clsname"},{"type":"int","name":"maxlength","decl":"int maxlength"}]}],"methodmaps":[],"constants":[],"enums":[{"name":"PropType","docStart":1637,"docEnd":1678,"docs":{"brief":"Property types for entities.","tags":[{"tag":"","text":"Property types for entities."}]},"entries":[{"name":"Prop_Send","docStart":1715,"docEnd":1750,"docs":null},{"name":"Prop_Data","docStart":1769,"docEnd":1820,"docs":null}]},{"name":"PropFieldType","docStart":0,"docEnd":0,"docs":null,"entries":[{"name":"PropField_Unsupported","docStart":2874,"docEnd":2906,"docs":null},{"name":"PropField_Integer","docStart":2937,"docEnd":2979,"docs":null},{"name":"PropField_Float","docStart":3010,"docEnd":3052,"docs":null},{"name":"PropField_Entity","docStart":3083,"docEnd":3141,"docs":null},{"name":"PropField_Vector","docStart":3172,"docEnd":3214,"docs":null},{"name":"PropField_String","docStart":3245,"docEnd":3287,"docs":null},{"name":"PropField_String_T","docStart":0,"docEnd":0,"docs":null},{"name":"PropField_Variant","docStart":3318,"docEnd":3623,"docs":null}]}],"typesets":[],"typedefs":[]}