{"functions":[{"name":"SocketIsConnected","docStart":10071,"docEnd":10208,"docs":{"brief":"Returns whether a socket is connected or not.","tags":[{"tag":"","text":"Returns whether a socket is connected or not."},{"tag":"param:socket","text":"Socket handle to check"},{"tag":"return","text":"bool The connection status"}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null}]},{"name":"SocketCreate","docStart":10257,"docEnd":10571,"docs":{"brief":"Creates a new socket.","tags":[{"tag":"","text":"Creates a new socket."},{"tag":"note","text":"this function may be relatively expensive, reuse sockets if possible"},{"tag":"param:SocketType","text":"protocol The protocol to use, SOCKET_TCP is default"},{"tag":"param:SocketErrorCB","text":"efunc  The error callback"},{"tag":"return","text":"Handle     The socket handle. Returns INVALID_HANDLE on failure"}]},"kind":"native","returnType":"Handle","arguments":[{"type":"SocketType","name":"protocol","decl":"SocketType protocol","default":"SOCKET_TCP"},{"type":"SocketErrorCB","name":"efunc","decl":"SocketErrorCB efunc","default":null}]},{"name":"SocketBind","docStart":10654,"docEnd":10926,"docs":{"brief":"Binds the socket to a local address","tags":[{"tag":"","text":"Binds the socket to a local address"},{"tag":"param:Handle","text":"socket  The handle of the socket to be used."},{"tag":"param:String","text":"hostname The hostname (or IP) to bind the socket to."},{"tag":"param:cell_t","text":"port  The port to bind the socket to."},{"tag":"return","text":"bool     true on success"}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null},{"type":"const char[]","name":"hostname","decl":"const char[] hostname","default":null},{"type":"int","name":"port","decl":"int port","default":null}]},{"name":"SocketConnect","docStart":11000,"docEnd":11657,"docs":{"brief":"Connects a socket","tags":[{"tag":"","text":"Connects a socket"},{"tag":"note","text":"this native is threaded, it may be still running after it executed, use the connect callback"},{"tag":"note","text":"invokes the SocketError callback with errorType = CONNECT_ERROR or EMPTY_HOST if it fails"},{"tag":"note","text":"invokes the SocketConnect callback if it succeeds"},{"tag":"param:Handle","text":"socket  The handle of the socket to be used."},{"tag":"param:SocketConnectCB","text":"cfunc  The connect callback"},{"tag":"param:SocketReceiveCB","text":"rfunc  The receive callback"},{"tag":"param:SocketDisconnectCB","text":"dfunc  The disconnect callback"},{"tag":"param:String","text":"hostname The hostname (or IP) to connect to."},{"tag":"param:cell_t","text":"port  The port to connect to."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null},{"type":"SocketConnectCB","name":"cfunc","decl":"SocketConnectCB cfunc","default":null},{"type":"SocketReceiveCB","name":"rfunc","decl":"SocketReceiveCB rfunc","default":null},{"type":"SocketDisconnectCB","name":"dfunc","decl":"SocketDisconnectCB dfunc","default":null},{"type":"const char[]","name":"hostname","decl":"const char[] hostname","default":null},{"type":"int","name":"port","decl":"int port","default":null}]},{"name":"SocketDisconnect","docStart":11806,"docEnd":12024,"docs":{"brief":"Disconnects a socket","tags":[{"tag":"","text":"Disconnects a socket"},{"tag":"note","text":"this will not close the handle, the socket will be reset to a state similar to after SocketCreate()"},{"tag":"note","text":"this won't trigger any disconnect/error callbacks\n"}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null}]},{"name":"SocketListen","docStart":12071,"docEnd":12302,"docs":{"brief":"Makes a socket listen for incoming connections","tags":[{"tag":"","text":"Makes a socket listen for incoming connections"},{"tag":"param:Handle","text":"socket The handle of the socket to be used."},{"tag":"param:SocketIncomingCB","text":"ifunc The callback for incoming connections"},{"tag":"return","text":"bool      true on success"}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null},{"type":"SocketIncomingCB","name":"ifunc","decl":"SocketIncomingCB ifunc","default":null}]},{"name":"SocketSend","docStart":12369,"docEnd":12964,"docs":{"brief":"Sends data through the socket.","tags":[{"tag":"","text":"Sends data through the socket."},{"tag":"note","text":"specify size for binary safe operation"},{"tag":"note","text":"if size is not specified the \\0 terminator will not be included"},{"tag":"note","text":"This native is threaded, it may be still running after it executed (not atomic)."},{"tag":"note","text":"Use the SendqueueEmpty callback to determine when all data has been successfully sent."},{"tag":"note","text":"The socket extension will ensure that the data will be send in the correct order and split\nthe data if required."},{"tag":"param:Handle","text":"socket The handle of the socket to be used."},{"tag":"param:String","text":"data The data to send."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null},{"type":"const char[]","name":"data","decl":"const char[] data","default":null},{"type":"int","name":"size","decl":"int size","default":"-1"}]},{"name":"SocketSendTo","docStart":13037,"docEnd":13765,"docs":{"brief":"Sends UDP data through the socket to a specific destination.","tags":[{"tag":"","text":"Sends UDP data through the socket to a specific destination."},{"tag":"note","text":"specify size for binary safe operation"},{"tag":"note","text":"if size is not specified the \\0 terminator will not be included"},{"tag":"note","text":"This native is threaded, it may be still running after it executed (not atomic)."},{"tag":"note","text":"Use the SendqueueEmpty callback to determine when all data has been successfully sent."},{"tag":"note","text":"The socket extension will ensure that the data will be send in the correct order and split\nthe data if required."},{"tag":"param:Handle","text":"socket The handle of the socket to be used."},{"tag":"param:String","text":"data The data to send."},{"tag":"param:String","text":"hostname The hostname (or IP) to send to."},{"tag":"param:cell_t","text":"port  The port to send to."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null},{"type":"const char[]","name":"data","decl":"const char[] data","default":null},{"type":"int","name":"size","decl":"int size","default":"-1"},{"type":"const char[]","name":"hostname","decl":"const char[] hostname","default":null},{"type":"int","name":"port","decl":"int port","default":null}]},{"name":"SocketSetOption","docStart":13873,"docEnd":14187,"docs":{"brief":"Set a socket option.","tags":[{"tag":"","text":"Set a socket option."},{"tag":"param:Handle","text":"socket The handle of the socket to be used. May be INVALID_HANDLE if not essential."},{"tag":"param:SocketOption","text":"option The option to modify (see enum SocketOption for details)."},{"tag":"param:cellt_","text":"value The value to set the option to."},{"tag":"return","text":"cell_t   1 on success."}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null},{"type":"SocketOption","name":"option","decl":"SocketOption option","default":null},{"type":"int","name":"value","decl":"int value","default":null}]},{"name":"SocketSetReceiveCallback","docStart":14265,"docEnd":14619,"docs":{"brief":"Defines the callback function for when the socket receives data","tags":[{"tag":"","text":"Defines the callback function for when the socket receives data"},{"tag":"note","text":"this is only useful and required for child-sockets spawned by listen-sockets\n(otherwise you already set it in SocketConnect())"},{"tag":"param:Handle","text":"socket The handle of the socket to be used."},{"tag":"param:SocketReceiveCB","text":"rfunc The receive callback"}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null},{"type":"SocketReceiveCB","name":"rfunc","decl":"SocketReceiveCB rfunc","default":null}]},{"name":"SocketSetSendqueueEmptyCallback","docStart":14697,"docEnd":15109,"docs":{"brief":"Defines the callback function for when the socket sent all items in its send queue","tags":[{"tag":"","text":"Defines the callback function for when the socket sent all items in its send queue"},{"tag":"note","text":"this must be called AFTER sending (queueing) the data"},{"tag":"note","text":"if no send-data is queued this will fire the callback itself"},{"tag":"note","text":"the callback is guaranteed to fire"},{"tag":"param:Handle","text":"socket The handle of the socket to be used."},{"tag":"param:SocketDisconnectCB","text":"dfunc The disconnect callback"}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null},{"type":"SocketSendqueueEmptyCB","name":"sfunc","decl":"SocketSendqueueEmptyCB sfunc","default":null}]},{"name":"SocketSetDisconnectCallback","docStart":15201,"docEnd":15593,"docs":{"brief":"Defines the callback function for when the socket was properly disconnected by the remote side","tags":[{"tag":"","text":"Defines the callback function for when the socket was properly disconnected by the remote side"},{"tag":"note","text":"this is only useful and required for child-sockets spawned by listen-sockets\n(otherwise you already set it in SocketConnect())"},{"tag":"param:Handle","text":"socket The handle of the socket to be used."},{"tag":"param:SocketDisconnectCB","text":"dfunc The disconnect callback"}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null},{"type":"SocketDisconnectCB","name":"dfunc","decl":"SocketDisconnectCB dfunc","default":null}]},{"name":"SocketSetErrorCallback","docStart":15677,"docEnd":16030,"docs":{"brief":"Defines the callback function for when the socket triggered an error","tags":[{"tag":"","text":"Defines the callback function for when the socket triggered an error"},{"tag":"note","text":"this is only useful and required for child-sockets spawned by listen-sockets\n(otherwise you already set it in SocketCreate())"},{"tag":"param:Handle","text":"socket The handle of the socket to be used."},{"tag":"param:SocketErrorCB","text":"efunc The error callback"}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null},{"type":"SocketErrorCB","name":"efunc","decl":"SocketErrorCB efunc","default":null}]},{"name":"SocketSetArg","docStart":16105,"docEnd":16276,"docs":{"brief":"Sets the argument being passed to callbacks","tags":[{"tag":"","text":"Sets the argument being passed to callbacks"},{"tag":"param:Handle","text":"socket The handle of the socket to be used."},{"tag":"param:any","text":"arg  The argument to set"}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null},{"type":"any","name":"arg","decl":"any arg","default":null}]},{"name":"SocketGetHostName","docStart":16328,"docEnd":16567,"docs":{"brief":"Retrieve the local system's hostname as the command \"hostname\" does.","tags":[{"tag":"","text":"Retrieve the local system's hostname as the command \"hostname\" does."},{"tag":"param:dest","text":"Destination string buffer to copy to."},{"tag":"param:destLen","text":"Destination buffer length (includes null terminator)."},{"tag":"return","text":"1 on success"}]},"kind":"native","returnType":"int","arguments":[{"type":"char[]","name":"dest","decl":"char[] dest","default":null},{"type":"int","name":"destLen","decl":"int destLen","default":null}]}],"methodmaps":[],"enumstructs":[],"constants":[{"name":"EMPTY_HOST","docStart":0,"docEnd":0,"docs":null},{"name":"NO_HOST","docStart":0,"docEnd":0,"docs":null},{"name":"CONNECT_ERROR","docStart":0,"docEnd":0,"docs":null},{"name":"SEND_ERROR","docStart":0,"docEnd":0,"docs":null},{"name":"BIND_ERROR","docStart":0,"docEnd":0,"docs":null},{"name":"RECV_ERROR","docStart":0,"docEnd":0,"docs":null},{"name":"LISTEN_ERROR","docStart":0,"docEnd":0,"docs":null}],"enums":[{"name":"SocketType","docStart":0,"docEnd":0,"docs":null,"entries":[{"name":"SOCKET_TCP","docStart":0,"docEnd":0,"docs":null,"value":"1"},{"name":"SOCKET_UDP","docStart":0,"docEnd":0,"docs":null,"value":null},{"name":"SOCKET_RAW","docStart":0,"docEnd":0,"docs":null,"value":null}]},{"name":"SocketOption","docStart":596,"docEnd":775,"docs":{"brief":"Options available for SocketSetOption()","tags":[{"tag":"","text":"Options available for SocketSetOption()"},{"tag":"note","text":"modifying these options is not required for normal operation, you can skip the whole\nsection in most cases."}]},"entries":[{"name":"ConcatenateCallbacks","docStart":796,"docEnd":1577,"docs":{"brief":"If this option is set the socket extension will try to concatenate SocketReceive callbacks.\n\nThis will possibly lower the amount of callbacks passed to SourceMod plugins and improve the\nperformance. The socket extension will preserve the packet order.","tags":[{"tag":"","text":"If this option is set the socket extension will try to concatenate SocketReceive callbacks.\n\nThis will possibly lower the amount of callbacks passed to SourceMod plugins and improve the\nperformance. The socket extension will preserve the packet order."},{"tag":"note","text":"this doesn't prevent multiple callbacks, it only reduces them for high load."},{"tag":"note","text":"this will not truncate packets below 4096 bytes, setting it lower will be ignored"},{"tag":"note","text":"set this option if you expect lots of data in a short timeframe"},{"tag":"note","text":"don't forget to set your buffer sizes at least to the value passed to this function, but\nalways at least to 4096"},{"tag":"param:cell_t","text":"0(=default) to disable or max. chunk size including \\0 terminator in bytes"},{"tag":"return","text":"bool true on success"}]},"value":"1"},{"name":"ForceFrameLock","docStart":1605,"docEnd":2236,"docs":{"brief":"If this option is set the socket extension will enforce a mutex lock in the GameFrame() hook.\n\nThis will ensure that callbacks will be processed every gameframe as fast as possible with the\ndrawback of potentially creating lag. It's not recommended to set this option for most cases.\nIf this option is not set the gameframe will be skipped if quietly obtaining a lock fails.","tags":[{"tag":"","text":"If this option is set the socket extension will enforce a mutex lock in the GameFrame() hook.\n\nThis will ensure that callbacks will be processed every gameframe as fast as possible with the\ndrawback of potentially creating lag. It's not recommended to set this option for most cases.\nIf this option is not set the gameframe will be skipped if quietly obtaining a lock fails."},{"tag":"note","text":"combine this with CallbacksPerFrame for best performance"},{"tag":"note","text":"this option will affect all sockets from all plugins, use it with caution!"},{"tag":"param:bool","text":"whether to force locking or not"},{"tag":"return","text":"bool true on success"}]},"value":null},{"name":"CallbacksPerFrame","docStart":2254,"docEnd":2851,"docs":{"brief":"This will specify the maximum amount of callbacks processed in every gameframe.\n\nThe default value for this option is 1, setting it higher will possibly increase networking\nperformance but may cause lag if it's set too high.\nThe amount of callbacks actually being processed is limited by not being able to quietly obtain\na lock (see ForceFrameLock) and the amount of callbacks in the queue.","tags":[{"tag":"","text":"This will specify the maximum amount of callbacks processed in every gameframe.\n\nThe default value for this option is 1, setting it higher will possibly increase networking\nperformance but may cause lag if it's set too high.\nThe amount of callbacks actually being processed is limited by not being able to quietly obtain\na lock (see ForceFrameLock) and the amount of callbacks in the queue."},{"tag":"note","text":"this option will affect all sockets from all plugins, use it with caution!"},{"tag":"param:cell_t","text":"maximum amount of callbacks per gameframe"},{"tag":"return","text":"bool  true on success"}]},"value":null},{"name":"SocketBroadcast","docStart":2872,"docEnd":3126,"docs":{"brief":"If this option is set the socket will be allowed to send broadcast messages in case the protocol\nsupports it. This is a wrapper for setting SO_BROADCAST.","tags":[{"tag":"","text":"If this option is set the socket will be allowed to send broadcast messages in case the protocol\nsupports it. This is a wrapper for setting SO_BROADCAST."},{"tag":"param:bool","text":"whether to allow broadcasting or not"},{"tag":"return","text":"bool true on success"}]},"value":null},{"name":"SocketReuseAddr","docStart":3145,"docEnd":3392,"docs":{"brief":"If this option is set SocketBind() will allow reusing local adresses in case the protocol\nsupports it. This is a wrapper for setting SO_REUSEADDR.","tags":[{"tag":"","text":"If this option is set SocketBind() will allow reusing local adresses in case the protocol\nsupports it. This is a wrapper for setting SO_REUSEADDR."},{"tag":"param:bool","text":"whether to allow broadcasting or not"},{"tag":"return","text":"bool true on success"}]},"value":null},{"name":"SocketKeepAlive","docStart":3411,"docEnd":3688,"docs":{"brief":"If this option is set the socket will try to keep the connection alive by periodically sending\nmessages if the protocol supports it. This is a wrapper for setting SO_KEEPALIVE.","tags":[{"tag":"","text":"If this option is set the socket will try to keep the connection alive by periodically sending\nmessages if the protocol supports it. This is a wrapper for setting SO_KEEPALIVE."},{"tag":"param:bool","text":"whether to allow broadcasting or not"},{"tag":"return","text":"bool true on success"}]},"value":null},{"name":"SocketLinger","docStart":3707,"docEnd":3959,"docs":{"brief":"This option specifies how long a socket will wait if it's being closed and its send buffer is\nstill filled. This is a wrapper for setting SO_LINGER.","tags":[{"tag":"","text":"This option specifies how long a socket will wait if it's being closed and its send buffer is\nstill filled. This is a wrapper for setting SO_LINGER."},{"tag":"param:cell_t","text":"0 (=default) to disable or time in s"},{"tag":"return","text":"bool  true on success"}]},"value":null},{"name":"SocketOOBInline","docStart":3975,"docEnd":4211,"docs":{"brief":"If this option is set out-of-band data will be inlined into the normal receive stream. This is a\nwrapper for setting SO_OOBINLINE.","tags":[{"tag":"","text":"If this option is set out-of-band data will be inlined into the normal receive stream. This is a\nwrapper for setting SO_OOBINLINE."},{"tag":"param:bool","text":"whether to inline out-of-band data or not"},{"tag":"return","text":"bool true on success"}]},"value":null},{"name":"SocketSendBuffer","docStart":4230,"docEnd":4408,"docs":{"brief":"This option specifies how large the send buffer will be. This is a wrapper for setting\nSO_SNDBUF.","tags":[{"tag":"","text":"This option specifies how large the send buffer will be. This is a wrapper for setting\nSO_SNDBUF."},{"tag":"param:cell_t","text":"size in bytes"},{"tag":"return","text":"bool  true on success"}]},"value":null},{"name":"SocketReceiveBuffer","docStart":4428,"docEnd":4609,"docs":{"brief":"This option specifies how large the receive buffer will be. This is a wrapper for setting\nSO_RCVBUF.","tags":[{"tag":"","text":"This option specifies how large the receive buffer will be. This is a wrapper for setting\nSO_RCVBUF."},{"tag":"param:cell_t","text":"size in bytes"},{"tag":"return","text":"bool  true on success"}]},"value":null},{"name":"SocketDontRoute","docStart":4632,"docEnd":4968,"docs":{"brief":"If this option is set outgoing messages will ignore the default routing facilities if the\nprotocol implementation supports it. The remote site should be directly connected to the sender.\nThis is a wrapper for setting SO_DONTROUTE.","tags":[{"tag":"","text":"If this option is set outgoing messages will ignore the default routing facilities if the\nprotocol implementation supports it. The remote site should be directly connected to the sender.\nThis is a wrapper for setting SO_DONTROUTE."},{"tag":"param:bool","text":"whether to skip default routing or not"},{"tag":"return","text":"bool true on success"}]},"value":null},{"name":"SocketReceiveLowWatermark","docStart":4987,"docEnd":5264,"docs":{"brief":"This option specifies the minimum amount of data to receive before processing it. This is a\nwrapper for setting SO_RCVLOWAT.","tags":[{"tag":"","text":"This option specifies the minimum amount of data to receive before processing it. This is a\nwrapper for setting SO_RCVLOWAT."},{"tag":"note","text":"this can probably block the extension, use it with caution!"},{"tag":"param:cell_t","text":"size in bytes"},{"tag":"return","text":"bool  true on success"}]},"value":null},{"name":"SocketReceiveTimeout","docStart":5293,"docEnd":5549,"docs":{"brief":"This option specifies how long a socket will try to receive data before it times out and\nprocesses the data. This is a wrapper for setting SO_RCVTIMEO.","tags":[{"tag":"","text":"This option specifies how long a socket will try to receive data before it times out and\nprocesses the data. This is a wrapper for setting SO_RCVTIMEO."},{"tag":"param:cell_t","text":"0 (=default) to disable or time in ms"},{"tag":"return","text":"bool  true on success"}]},"value":null},{"name":"SocketSendLowWatermark","docStart":5573,"docEnd":5873,"docs":{"brief":"This option specifies the minimum amount of data required in the send buffer before starting to\nsend it. This is a wrapper for setting SO_SNDLOWAT.","tags":[{"tag":"","text":"This option specifies the minimum amount of data required in the send buffer before starting to\nsend it. This is a wrapper for setting SO_SNDLOWAT."},{"tag":"note","text":"this can probably block the extension, use it with caution!"},{"tag":"param:cell_t","text":"size in bytes"},{"tag":"return","text":"bool  true on success"}]},"value":null},{"name":"SocketSendTimeout","docStart":5899,"docEnd":6150,"docs":{"brief":"This option specifies how long a socket will try to send data before it times out and\nretries it later. This is a wrapper for setting SO_SNDTIMEO.","tags":[{"tag":"","text":"This option specifies how long a socket will try to send data before it times out and\nretries it later. This is a wrapper for setting SO_SNDTIMEO."},{"tag":"param:cell_t","text":"0 (=default) to disable or time in ms"},{"tag":"return","text":"bool  true on success"}]},"value":null},{"name":"DebugMode","docStart":6171,"docEnd":6369,"docs":{"brief":"If this option is set the socket extension will display debugging messages in the server console/logs.","tags":[{"tag":"","text":"If this option is set the socket extension will display debugging messages in the server console/logs."},{"tag":"param:bool","text":"whether to enable debugging or not"},{"tag":"return","text":"bool true on success"}]},"value":null}]}],"typesets":[],"typedefs":[{"name":"SocketConnectCB","docStart":6688,"docEnd":6904,"docs":{"brief":"triggered if a normal sockets finished connecting and is ready to be used","tags":[{"tag":"","text":"triggered if a normal sockets finished connecting and is ready to be used"},{"tag":"param:socket","text":"The socket handle pointing to the calling socket"},{"tag":"param:arg","text":"The argument set by SocketSetArg()"}]},"type":"function void(Handle socket, any arg)","parsedSignature":{"returnType":"void","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null},{"type":"any","name":"arg","decl":"any arg","default":null}]}},{"name":"SocketIncomingCB","docStart":6972,"docEnd":7467,"docs":{"brief":"triggered if a listening socket received an incoming connection and is ready to be used","tags":[{"tag":"","text":"triggered if a listening socket received an incoming connection and is ready to be used"},{"tag":"note","text":"The child-socket won't work until receive-, disconnect-, and errorcallback for it are set."},{"tag":"param:Handle","text":"socket  The socket handle pointing to the calling listen-socket"},{"tag":"param:Handle","text":"newSocket The socket handle to the newly spawned child socket"},{"tag":"param:String","text":"remoteIP The remote IP"},{"tag":"param:any","text":"arg   The argument set by SocketSetArg() for the listen-socket"}]},"type":"function void(Handle socket, Handle newSocket, const char[] remoteIP, int remotePort, any arg)","parsedSignature":{"returnType":"void","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null},{"type":"Handle","name":"newSocket","decl":"Handle newSocket","default":null},{"type":"const char[]","name":"remoteIP","decl":"const char[] remoteIP","default":null},{"type":"int","name":"remotePort","decl":"int remotePort","default":null},{"type":"any","name":"arg","decl":"any arg","default":null}]}},{"name":"SocketReceiveCB","docStart":7593,"docEnd":8331,"docs":{"brief":"triggered if a socket receives data","tags":[{"tag":"","text":"triggered if a socket receives data"},{"tag":"note","text":"This is binary safe if you always use dataSize for operations on receiveData[]"},{"tag":"note","text":"packets may be split up into multiple chunks -> multiple calls to the receive callback"},{"tag":"note","text":"if not set otherwise by SocketSetOption(..., ConcatenateCallbacks, ...) receiveData will\nnever be longer than 4096 characters including \\0 terminator"},{"tag":"param:Handle","text":"socket  The socket handle pointing to the calling socket"},{"tag":"param:String","text":"receiveData The data which arrived, 0-terminated at receiveData[dataSize]"},{"tag":"param:cell_t","text":"dataSize The length of the arrived data excluding the 0-termination"},{"tag":"param:any","text":"arg   The argument set by SocketSetArg() for the socket"}]},"type":"function void(Handle socket, const char[] receiveData, const int dataSize, any arg)","parsedSignature":{"returnType":"void","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null},{"type":"const char[]","name":"receiveData","decl":"const char[] receiveData","default":null},{"type":"const int","name":"dataSize","decl":"const int dataSize","default":null},{"type":"any","name":"arg","decl":"any arg","default":null}]}},{"name":"SocketSendqueueEmptyCB","docStart":8445,"docEnd":8684,"docs":{"brief":"called after a socket sent all items in its send queue successfully","tags":[{"tag":"","text":"called after a socket sent all items in its send queue successfully"},{"tag":"param:Handle","text":"socket  The socket handle pointing to the calling socket"},{"tag":"param:any","text":"arg   The argument set by SocketSetArg() for the socket"}]},"type":"function void(Handle socket, any arg)","parsedSignature":{"returnType":"void","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null},{"type":"any","name":"arg","decl":"any arg","default":null}]}},{"name":"SocketDisconnectCB","docStart":8759,"docEnd":9093,"docs":{"brief":"called if a socket has been properly disconnected by the remote side","tags":[{"tag":"","text":"called if a socket has been properly disconnected by the remote side"},{"tag":"note","text":"You should call CloseHandle(socket) or reuse the socket before this function ends"},{"tag":"param:Handle","text":"socket  The socket handle pointing to the calling socket"},{"tag":"param:any","text":"arg   The argument set by SocketSetArg() for the socket"}]},"type":"function void(Handle socket, any arg)","parsedSignature":{"returnType":"void","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null},{"type":"any","name":"arg","decl":"any arg","default":null}]}},{"name":"SocketErrorCB","docStart":9164,"docEnd":9662,"docs":{"brief":"called if an unrecoverable error occured, close the socket without an additional call to a disconnect callback","tags":[{"tag":"","text":"called if an unrecoverable error occured, close the socket without an additional call to a disconnect callback"},{"tag":"note","text":"You should call CloseHandle(socket) or reuse the socket before this function ends"},{"tag":"param:Handle","text":"socket  The socket handle pointing to the calling socket"},{"tag":"param:cell_t","text":"errorType The error type, see defines above"},{"tag":"param:cell_t","text":"errorNum The errno, see errno.h for details"},{"tag":"param:any","text":"arg   The argument set by SocketSetArg() for the socket"}]},"type":"function void(Handle socket, const int errorType, const int errorNum, any arg)","parsedSignature":{"returnType":"void","arguments":[{"type":"Handle","name":"socket","decl":"Handle socket","default":null},{"type":"const int","name":"errorType","decl":"const int errorType","default":null},{"type":"const int","name":"errorNum","decl":"const int errorNum","default":null},{"type":"any","name":"arg","decl":"any arg","default":null}]}}]}