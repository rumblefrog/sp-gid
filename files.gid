{"functions":[{"name":"BuildPath","docStart":9994,"docEnd":10528,"docs":{"brief":"Builds a path relative to the SourceMod folder.  This should be used instead of\ndirectly referencing addons/sourcemod, in case users change the name of their\nfolder layout.","tags":[{"tag":"","text":"Builds a path relative to the SourceMod folder.  This should be used instead of\ndirectly referencing addons/sourcemod, in case users change the name of their\nfolder layout."},{"tag":"param:type","text":"Type of path to build as the base."},{"tag":"param:buffer","text":"Buffer to store the path."},{"tag":"param:maxlength","text":"Maximum length of buffer."},{"tag":"param:fmt","text":"Format string."},{"tag":"param:...","text":"Format arguments."},{"tag":"return","text":"Number of bytes written to buffer (not including null terminator)."}]},"kind":"native","returnType":"int","arguments":[{"type":"PathType","name":"type","decl":"PathType type"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"const char[]","name":"fmt","decl":"const char[] fmt"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"OpenDirectory","docStart":10627,"docEnd":11364,"docs":{"brief":"Opens a directory/folder for contents enumeration.","tags":[{"tag":"","text":"Opens a directory/folder for contents enumeration."},{"tag":"note","text":"Directories are closed with CloseHandle() or delete."},{"tag":"note","text":"Directories Handles can be cloned."},{"tag":"note","text":"OpenDirectory() supports the \"file://\" notation."},{"tag":"param:path","text":"Path to open."},{"tag":"param:use_valve_fs","text":"If true, the Valve file system will be used instead.\nThis can be used to find files existing in any of\nthe Valve search paths, rather than solely files\nexisting directly in the gamedir."},{"tag":"param:valve_path_id","text":"If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."},{"tag":"return","text":"A Handle to the directory, null on error."}]},"kind":"native","returnType":"DirectoryListing","arguments":[{"type":"const char[]","name":"path","decl":"const char[] path"},{"type":"bool","name":"use_valve_fs","decl":"bool use_valve_fs"},{"type":"const char[]","name":"valve_path_id","decl":"const char[] valve_path_id"}]},{"name":"ReadDirEntry","docStart":11487,"docEnd":12128,"docs":{"brief":"Reads the current directory entry as a local filename, then moves to the next file.","tags":[{"tag":"","text":"Reads the current directory entry as a local filename, then moves to the next file."},{"tag":"note","text":"Contents of buffers are undefined when returning false."},{"tag":"note","text":"Both the '.' and '..' automatic directory entries will be retrieved for Windows and Linux."},{"tag":"param:dir","text":"Handle to a directory."},{"tag":"param:buffer","text":"String buffer to hold directory name."},{"tag":"param:maxlength","text":"Maximum size of string buffer."},{"tag":"param:type","text":"Optional variable to store the file type."},{"tag":"return","text":"True on success, false if there are no more files to read."},{"tag":"error","text":"Invalid or corrupt Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"dir","decl":"Handle dir"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"FileType&","name":"type","decl":"FileType& type"}]},{"name":"OpenFile","docStart":12234,"docEnd":14094,"docs":{"brief":"Opens or creates a file, returning a File handle on success. File handles\nshould be closed with delete or CloseHandle().\n\nThe open mode may be one of the following strings:\n\"r\": Open an existing file for reading.\n\"w\": Create a file for writing, or truncate (delete the contents of) an\nexisting file and then open it for writing.\n\"a\": Create a file for writing, or open an existing file such that writes\nwill be appended to the end.\n\"r+\": Open an existing file for both reading and writing.\n\"w+\": Create a file for reading and writing, or truncate an existing file\nand then open it for reading and writing.\n\"a+\": Create a file for both reading and writing, or open an existing file\nsuch that writes will be appended to the end.\n\nThe open mode may also contain an additional character after \"r\", \"w\", or \"a\",\nbut before any \"+\" sign. This character may be \"b\" (indicating binary mode) or\n\"t\" (indicating text mode). By default, \"text\" mode is implied. On Linux and\nMac, this has no distinction from binary mode. On Windows, it causes the '\\n'\ncharacter (0xA) to be written as \"\\r\\n\" (0xD, 0xA).\n\nExample: \"rb\" opens a binary file for reading; \"at\" opens a text file for\nappending.","tags":[{"tag":"","text":"Opens or creates a file, returning a File handle on success. File handles\nshould be closed with delete or CloseHandle().\n\nThe open mode may be one of the following strings:\n\"r\": Open an existing file for reading.\n\"w\": Create a file for writing, or truncate (delete the contents of) an\nexisting file and then open it for writing.\n\"a\": Create a file for writing, or open an existing file such that writes\nwill be appended to the end.\n\"r+\": Open an existing file for both reading and writing.\n\"w+\": Create a file for reading and writing, or truncate an existing file\nand then open it for reading and writing.\n\"a+\": Create a file for both reading and writing, or open an existing file\nsuch that writes will be appended to the end.\n\nThe open mode may also contain an additional character after \"r\", \"w\", or \"a\",\nbut before any \"+\" sign. This character may be \"b\" (indicating binary mode) or\n\"t\" (indicating text mode). By default, \"text\" mode is implied. On Linux and\nMac, this has no distinction from binary mode. On Windows, it causes the '\\n'\ncharacter (0xA) to be written as \"\\r\\n\" (0xD, 0xA).\n\nExample: \"rb\" opens a binary file for reading; \"at\" opens a text file for\nappending."},{"tag":"param:file","text":"File to open."},{"tag":"param:mode","text":"Open mode."},{"tag":"param:use_valve_fs","text":"If true, the Valve file system will be used instead.\nThis can be used to find files existing in valve\nsearch paths, rather than solely files existing directly\nin the gamedir."},{"tag":"param:valve_path_id","text":"If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."},{"tag":"return","text":"A File handle, or null if the file could not be opened."}]},"kind":"native","returnType":"File","arguments":[{"type":"const char[]","name":"file","decl":"const char[] file"},{"type":"const char[]","name":"mode","decl":"const char[] mode"},{"type":"bool","name":"use_valve_fs","decl":"bool use_valve_fs"},{"type":"const char[]","name":"valve_path_id","decl":"const char[] valve_path_id"}]},{"name":"DeleteFile","docStart":14219,"docEnd":14786,"docs":{"brief":"Deletes a file.","tags":[{"tag":"","text":"Deletes a file."},{"tag":"param:path","text":"Path of the file to delete."},{"tag":"param:use_valve_fs","text":"If true, the Valve file system will be used instead.\nThis can be used to delete files existing in the Valve\nsearch path, rather than solely files existing directly\nin the gamedir."},{"tag":"param:valve_path_id","text":"If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."},{"tag":"return","text":"True on success, false on failure or if file not immediately removed."}]},"kind":"native","returnType":"bool","arguments":[{"type":"const char[]","name":"path","decl":"const char[] path"},{"type":"bool","name":"use_valve_fs","decl":"bool use_valve_fs"},{"type":"const char[]","name":"valve_path_id","decl":"const char[] valve_path_id"}]},{"name":"ReadFileLine","docStart":14908,"docEnd":15172,"docs":{"brief":"Reads a line from a text file.","tags":[{"tag":"","text":"Reads a line from a text file."},{"tag":"param:hndl","text":"Handle to the file."},{"tag":"param:buffer","text":"String buffer to hold the line."},{"tag":"param:maxlength","text":"Maximum size of string buffer."},{"tag":"return","text":"True on success, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"hndl","decl":"Handle hndl"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"ReadFile","docStart":15246,"docEnd":15647,"docs":{"brief":"Reads binary data from a file.","tags":[{"tag":"","text":"Reads binary data from a file."},{"tag":"param:hndl","text":"Handle to the file."},{"tag":"param:items","text":"Array to store each item read."},{"tag":"param:num_items","text":"Number of items to read into the array."},{"tag":"param:size","text":"Size of each element, in bytes, to be read.\nValid sizes are 1, 2, or 4."},{"tag":"return","text":"Number of elements read, or -1 on error."}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"hndl","decl":"Handle hndl"},{"type":"int[]","name":"items","decl":"int[] items"},{"type":"int","name":"num_items","decl":"int num_items"},{"type":"int","name":"size","decl":"int size"}]},{"name":"ReadFileString","docStart":15724,"docEnd":16518,"docs":{"brief":"Reads a UTF8 or ANSI string from a file.","tags":[{"tag":"","text":"Reads a UTF8 or ANSI string from a file."},{"tag":"param:hndl","text":"Handle to the file."},{"tag":"param:buffer","text":"Buffer to store the string."},{"tag":"param:max_size","text":"Maximum size of the string buffer."},{"tag":"param:read_count","text":"If -1, reads until a null terminator is encountered in\nthe file.  Otherwise, read_count bytes are read\ninto the buffer provided.  In this case the buffer\nis not explicitly null terminated, and the buffer\nwill contain any null terminators read from the file."},{"tag":"return","text":"Number of characters written to the buffer, or -1\nif an error was encountered."},{"tag":"error","text":"Invalid Handle, or read_count > max_size."}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"hndl","decl":"Handle hndl"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"max_size","decl":"int max_size"},{"type":"int","name":"read_count","decl":"int read_count"}]},{"name":"WriteFile","docStart":16611,"docEnd":17283,"docs":{"brief":"Writes binary data to a file.","tags":[{"tag":"","text":"Writes binary data to a file."},{"tag":"param:hndl","text":"Handle to the file."},{"tag":"param:items","text":"Array of items to write.  The data is read directly.\nThat is, in 1 or 2-byte mode, the lower byte(s) in\neach cell are used directly, rather than performing\nany casts from a 4-byte number to a smaller number."},{"tag":"param:num_items","text":"Number of items in the array."},{"tag":"param:size","text":"Size of each item in the array in bytes.\nValid sizes are 1, 2, or 4."},{"tag":"return","text":"True on success, false on error."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"hndl","decl":"Handle hndl"},{"type":"const int[]","name":"items","decl":"const int[] items"},{"type":"int","name":"num_items","decl":"int num_items"},{"type":"int","name":"size","decl":"int size"}]},{"name":"WriteFileString","docStart":17368,"docEnd":17677,"docs":{"brief":"Writes a binary string to a file.","tags":[{"tag":"","text":"Writes a binary string to a file."},{"tag":"param:hndl","text":"Handle to the file."},{"tag":"param:buffer","text":"String to write."},{"tag":"param:term","text":"True to append NUL terminator, false otherwise."},{"tag":"return","text":"True on success, false on error."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"hndl","decl":"Handle hndl"},{"type":"const char[]","name":"buffer","decl":"const char[] buffer"},{"type":"bool","name":"term","decl":"bool term"}]},{"name":"WriteFileLine","docStart":17756,"docEnd":18099,"docs":{"brief":"Writes a line of text to a text file.  A newline is automatically appended.","tags":[{"tag":"","text":"Writes a line of text to a text file.  A newline is automatically appended."},{"tag":"param:hndl","text":"Handle to the file."},{"tag":"param:format","text":"Formatting rules."},{"tag":"param:...","text":"Variable number of format parameters."},{"tag":"return","text":"True on success, false otherwise."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"hndl","decl":"Handle hndl"},{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"ReadFileCell","docStart":18174,"docEnd":18568,"docs":{"brief":"Reads a single binary cell from a file.","tags":[{"tag":"","text":"Reads a single binary cell from a file."},{"tag":"param:hndl","text":"Handle to the file."},{"tag":"param:data","text":"Variable to store the data read."},{"tag":"param:size","text":"Size of the data to read in bytes.  Valid\nsizes are 1, 2, or 4 bytes."},{"tag":"return","text":"Number of elements read (max 1), or -1 on error."},{"tag":"error","text":"Invalid Handle."}]},"kind":"stock","returnType":"int","arguments":[{"type":"Handle","name":"hndl","decl":"Handle hndl"},{"type":"int&","name":"data","decl":"int& data"},{"type":"int","name":"size","decl":"int size"}]},{"name":"WriteFileCell","docStart":18760,"docEnd":19327,"docs":{"brief":"Writes a single binary cell to a file.","tags":[{"tag":"","text":"Writes a single binary cell to a file."},{"tag":"param:hndl","text":"Handle to the file."},{"tag":"param:data","text":"Cell to write to the file."},{"tag":"param:size","text":"Size of the data to read in bytes.  Valid\nsizes are 1, 2, or 4 bytes.  If the size\nis less than 4 bytes, the data is truncated\nrather than casted.  That is, only the lower\nbits will be read."},{"tag":"return","text":"True on success, false on error."},{"tag":"error","text":"Invalid Handle."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"Handle","name":"hndl","decl":"Handle hndl"},{"type":"int","name":"data","decl":"int data"},{"type":"int","name":"size","decl":"int size"}]},{"name":"IsEndOfFile","docStart":19475,"docEnd":19700,"docs":{"brief":"Tests if the end of file has been reached.","tags":[{"tag":"","text":"Tests if the end of file has been reached."},{"tag":"param:file","text":"Handle to the file."},{"tag":"return","text":"True if end of file has been reached, false otherwise."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"file","decl":"Handle file"}]},{"name":"FileSeek","docStart":19743,"docEnd":20081,"docs":{"brief":"Sets the file position indicator.","tags":[{"tag":"","text":"Sets the file position indicator."},{"tag":"param:file","text":"Handle to the file."},{"tag":"param:position","text":"Position relative to what is specified in whence."},{"tag":"param:where","text":"SEEK_ constant value of where to see from."},{"tag":"return","text":"True on success, false otherwise."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"file","decl":"Handle file"},{"type":"int","name":"position","decl":"int position"},{"type":"int","name":"where","decl":"int where"}]},{"name":"FilePosition","docStart":20146,"docEnd":20346,"docs":{"brief":"Get current position in the file.","tags":[{"tag":"","text":"Get current position in the file."},{"tag":"param:file","text":"Handle to the file."},{"tag":"return","text":"Value for the file position indicator."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"file","decl":"Handle file"}]},{"name":"FileExists","docStart":20389,"docEnd":20933,"docs":{"brief":"Checks if a file exists.","tags":[{"tag":"","text":"Checks if a file exists."},{"tag":"param:path","text":"Path to the file."},{"tag":"param:use_valve_fs","text":"If true, the Valve file system will be used instead.\nThis can be used to find files existing in any of\nthe Valve search paths, rather than solely files\nexisting directly in the gamedir."},{"tag":"param:valve_path_id","text":"If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."},{"tag":"return","text":"True if the file exists, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"const char[]","name":"path","decl":"const char[] path"},{"type":"bool","name":"use_valve_fs","decl":"bool use_valve_fs"},{"type":"const char[]","name":"valve_path_id","decl":"const char[] valve_path_id"}]},{"name":"RenameFile","docStart":21041,"docEnd":21596,"docs":{"brief":"Renames a file.","tags":[{"tag":"","text":"Renames a file."},{"tag":"param:newpath","text":"New path to the file."},{"tag":"param:oldpath","text":"Path to the existing file."},{"tag":"param:use_valve_fs","text":"If true, the Valve file system will be used instead.\nThis can be used to rename files in the game's\nValve search paths, rather than directly in the gamedir."},{"tag":"param:valve_path_id","text":"If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."},{"tag":"return","text":"True on success or use_valve_fs specified, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"const char[]","name":"newpath","decl":"const char[] newpath"},{"type":"const char[]","name":"oldpath","decl":"const char[] oldpath"},{"type":"bool","name":"use_valve_fs","decl":"bool use_valve_fs"},{"type":"const char[]","name":"valve_path_id","decl":"const char[] valve_path_id"}]},{"name":"DirExists","docStart":21743,"docEnd":22302,"docs":{"brief":"Checks if a directory exists.","tags":[{"tag":"","text":"Checks if a directory exists."},{"tag":"param:path","text":"Path to the directory."},{"tag":"param:use_valve_fs","text":"If true, the Valve file system will be used instead.\nThis can be used to find files existing in any of\nthe Valve search paths, rather than solely files\nexisting directly in the gamedir."},{"tag":"param:valve_path_id","text":"If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."},{"tag":"return","text":"True if the directory exists, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"const char[]","name":"path","decl":"const char[] path"},{"type":"bool","name":"use_valve_fs","decl":"bool use_valve_fs"},{"type":"const char[]","name":"valve_path_id","decl":"const char[] valve_path_id"}]},{"name":"FileSize","docStart":22409,"docEnd":22956,"docs":{"brief":"Get the file size in bytes.","tags":[{"tag":"","text":"Get the file size in bytes."},{"tag":"param:path","text":"Path to the file."},{"tag":"param:use_valve_fs","text":"If true, the Valve file system will be used instead.\nThis can be used to find files existing in any of\nthe Valve search paths, rather than solely files\nexisting directly in the gamedir."},{"tag":"param:valve_path_id","text":"If use_valve_fs, a search path from gameinfo or NULL_STRING for all search paths."},{"tag":"return","text":"File size in bytes, -1 if file not found."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"path","decl":"const char[] path"},{"type":"bool","name":"use_valve_fs","decl":"bool use_valve_fs"},{"type":"const char[]","name":"valve_path_id","decl":"const char[] valve_path_id"}]},{"name":"FlushFile","docStart":23061,"docEnd":23351,"docs":{"brief":"Flushes a file's buffered output; any buffered output\nis immediately written to the file.","tags":[{"tag":"","text":"Flushes a file's buffered output; any buffered output\nis immediately written to the file."},{"tag":"param:file","text":"Handle to the file."},{"tag":"return","text":"True on success or use_valve_fs specified with OpenFile,\notherwise false on failure."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"file","decl":"Handle file"}]},{"name":"RemoveDir","docStart":23392,"docEnd":23629,"docs":{"brief":"Removes a directory.","tags":[{"tag":"","text":"Removes a directory."},{"tag":"note","text":"On most Operating Systems you cannot remove a directory which has files inside it."},{"tag":"param:path","text":"Path to the directory."},{"tag":"return","text":"True on success, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"const char[]","name":"path","decl":"const char[] path"}]},{"name":"CreateDirectory","docStart":24212,"docEnd":24922,"docs":{"brief":"Creates a directory.","tags":[{"tag":"","text":"Creates a directory."},{"tag":"param:path","text":"Path to create."},{"tag":"param:mode","text":"Permissions (default is o=rx,g=rx,u=rwx).  Note that folders must have\nthe execute bit set on Linux.  On Windows, the mode is ignored."},{"tag":"param:use_valve_fs","text":"If true, the Valve file system will be used instead.\nThis can be used to create folders in the game's\nValve search paths, rather than directly in the gamedir."},{"tag":"param:valve_path_id","text":"If use_valve_fs, a search path from gameinfo or NULL_STRING for default.\nIn this case, mode is ignored."},{"tag":"return","text":"True on success, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"const char[]","name":"path","decl":"const char[] path"},{"type":"int","name":"mode","decl":"int mode"},{"type":"bool","name":"use_valve_fs","decl":"bool use_valve_fs"},{"type":"const char[]","name":"valve_path_id","decl":"const char[] valve_path_id"}]},{"name":"SetFilePermissions","docStart":25059,"docEnd":25265,"docs":{"brief":"Changes a file or directories permissions.","tags":[{"tag":"","text":"Changes a file or directories permissions."},{"tag":"param:path","text":"Path to the file."},{"tag":"param:mode","text":"Permissions to set."},{"tag":"return","text":"True on success, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"const char[]","name":"path","decl":"const char[] path"},{"type":"int","name":"mode","decl":"int mode"}]},{"name":"GetFileTime","docStart":25331,"docEnd":25520,"docs":{"brief":"Returns a file timestamp as a unix timestamp.","tags":[{"tag":"","text":"Returns a file timestamp as a unix timestamp."},{"tag":"param:file","text":"File name."},{"tag":"param:tmode","text":"Time mode."},{"tag":"return","text":"Time value, or -1 on failure."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"file","decl":"const char[] file"},{"type":"FileTimeMode","name":"tmode","decl":"FileTimeMode tmode"}]},{"name":"LogToOpenFile","docStart":25588,"docEnd":25890,"docs":{"brief":"Same as LogToFile(), except uses an open file Handle.  The file must\nbe opened in text appending mode.","tags":[{"tag":"","text":"Same as LogToFile(), except uses an open file Handle.  The file must\nbe opened in text appending mode."},{"tag":"param:hndl","text":"Handle to the file."},{"tag":"param:message","text":"Message format."},{"tag":"param:...","text":"Message format parameters."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"hndl","decl":"Handle hndl"},{"type":"const char[]","name":"message","decl":"const char[] message"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"LogToOpenFileEx","docStart":25966,"docEnd":26270,"docs":{"brief":"Same as LogToFileEx(), except uses an open file Handle.  The file must\nbe opened in text appending mode.","tags":[{"tag":"","text":"Same as LogToFileEx(), except uses an open file Handle.  The file must\nbe opened in text appending mode."},{"tag":"param:hndl","text":"Handle to the file."},{"tag":"param:message","text":"Message format."},{"tag":"param:...","text":"Message format parameters."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"hndl","decl":"Handle hndl"},{"type":"const char[]","name":"message","decl":"const char[] message"},{"type":"any...","name":"...","decl":"any... ..."}]}],"methodmaps":[{"name":"DirectoryListing","docStart":3138,"docEnd":3265,"docs":{"brief":"A DirectoryListing iterates over the contents of a directory. To obtain a\nDirectoryListing handle, call OpenDirectory().","tags":[{"tag":"","text":"A DirectoryListing iterates over the contents of a directory. To obtain a\nDirectoryListing handle, call OpenDirectory()."}]},"methods":[{"name":"GetNext","docStart":3308,"docEnd":3771,"docs":{"brief":"Reads the current directory entry as a local filename, then moves to the\nnext file.\n\nNote: Both the '.' and '..' automatic directory entries will be retrieved.","tags":[{"tag":"","text":"Reads the current directory entry as a local filename, then moves to the\nnext file.\n\nNote: Both the '.' and '..' automatic directory entries will be retrieved."},{"tag":"param:buffer","text":"String buffer to hold directory name."},{"tag":"param:maxlength","text":"Maximum size of string buffer."},{"tag":"param:type","text":"Optional variable to store the file type."},{"tag":"return","text":"True on success, false if there are no more files to read."}]},"kind":"native","returnType":"bool","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"},{"type":"FileType&","name":"type","decl":"FileType& type"}]}],"properties":[]},{"name":"File","docStart":3872,"docEnd":4076,"docs":{"brief":"A File object can be obtained by calling OpenFile(). File objects should be\nclosed with delete or Close(). Note that, \"delete file\" does not\nactually delete the file, it just closes the handle.","tags":[{"tag":"","text":"A File object can be obtained by calling OpenFile(). File objects should be\nclosed with delete or Close(). Note that, \"delete file\" does not\nactually delete the file, it just closes the handle."}]},"methods":[{"name":"Close","docStart":4107,"docEnd":4183,"docs":{"brief":"Close the file handle. This is the same as using CloseHandle() or delete.","tags":[{"tag":"","text":"Close the file handle. This is the same as using CloseHandle() or delete."}]},"kind":"stock","returnType":"void","arguments":[]},{"name":"ReadLine","docStart":4238,"docEnd":4460,"docs":{"brief":"Reads a line of text from a file.","tags":[{"tag":"","text":"Reads a line of text from a file."},{"tag":"param:buffer","text":"String buffer to hold the line."},{"tag":"param:maxlength","text":"Maximum size of string buffer."},{"tag":"return","text":"True on success, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"Read","docStart":4526,"docEnd":4888,"docs":{"brief":"Reads binary data from a file.","tags":[{"tag":"","text":"Reads binary data from a file."},{"tag":"param:items","text":"Array to store each item read."},{"tag":"param:num_items","text":"Number of items to read into the array."},{"tag":"param:size","text":"Size of each element, in bytes, to be read.\nValid sizes are 1, 2, or 4."},{"tag":"return","text":"Number of elements read, or -1 on error."}]},"kind":"native","returnType":"int","arguments":[{"type":"int[]","name":"items","decl":"int[] items"},{"type":"int","name":"num_items","decl":"int num_items"},{"type":"int","name":"size","decl":"int size"}]},{"name":"ReadString","docStart":4957,"docEnd":5708,"docs":{"brief":"Reads a UTF8 or ANSI string from a file.","tags":[{"tag":"","text":"Reads a UTF8 or ANSI string from a file."},{"tag":"param:buffer","text":"Buffer to store the string."},{"tag":"param:max_size","text":"Maximum size of the string buffer."},{"tag":"param:read_count","text":"If -1, reads until a null terminator is encountered in\nthe file.  Otherwise, read_count bytes are read\ninto the buffer provided.  In this case the buffer\nis not explicitly null terminated, and the buffer\nwill contain any null terminators read from the file."},{"tag":"return","text":"Number of characters written to the buffer, or -1\nif an error was encountered."},{"tag":"error","text":"read_count > max_size."}]},"kind":"native","returnType":"int","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"max_size","decl":"int max_size"},{"type":"int","name":"read_count","decl":"int read_count"}]},{"name":"Write","docStart":5793,"docEnd":6394,"docs":{"brief":"Writes binary data to a file.","tags":[{"tag":"","text":"Writes binary data to a file."},{"tag":"param:items","text":"Array of items to write.  The data is read directly.\nThat is, in 1 or 2-byte mode, the lower byte(s) in\neach cell are used directly, rather than performing\nany casts from a 4-byte number to a smaller number."},{"tag":"param:num_items","text":"Number of items in the array."},{"tag":"param:size","text":"Size of each item in the array in bytes.\nValid sizes are 1, 2, or 4."},{"tag":"return","text":"True on success, false on error."}]},"kind":"native","returnType":"bool","arguments":[{"type":"const int[]","name":"items","decl":"const int[] items"},{"type":"int","name":"num_items","decl":"int num_items"},{"type":"int","name":"size","decl":"int size"}]},{"name":"WriteString","docStart":6471,"docEnd":6694,"docs":{"brief":"Writes a binary string to a file.","tags":[{"tag":"","text":"Writes a binary string to a file."},{"tag":"param:buffer","text":"String to write."},{"tag":"param:term","text":"True to append NUL terminator, false otherwise."},{"tag":"return","text":"True on success, false on error."}]},"kind":"native","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer"},{"type":"bool","name":"term","decl":"bool term"}]},{"name":"WriteLine","docStart":6765,"docEnd":7070,"docs":{"brief":"Writes a line of text to a text file.  A newline is automatically appended.","tags":[{"tag":"","text":"Writes a line of text to a text file.  A newline is automatically appended."},{"tag":"param:hndl","text":"Handle to the file."},{"tag":"param:format","text":"Formatting rules."},{"tag":"param:...","text":"Variable number of format parameters."},{"tag":"return","text":"True on success, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"ReadInt8","docStart":7137,"docEnd":7363,"docs":{"brief":"Reads a single int8 (byte) from a file. The returned value is sign-\nextended to an int32.","tags":[{"tag":"","text":"Reads a single int8 (byte) from a file. The returned value is sign-\nextended to an int32."},{"tag":"param:data","text":"Variable to store the data read."},{"tag":"return","text":"True on success, false on failure."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int&","name":"data","decl":"int& data"}]},{"name":"ReadUint8","docStart":7410,"docEnd":7645,"docs":{"brief":"Reads a single uint8 (unsigned byte) from a file. The returned value is\nzero-extended to an int32.","tags":[{"tag":"","text":"Reads a single uint8 (unsigned byte) from a file. The returned value is\nzero-extended to an int32."},{"tag":"param:data","text":"Variable to store the data read."},{"tag":"return","text":"True on success, false on failure."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int&","name":"data","decl":"int& data"}]},{"name":"ReadInt16","docStart":7693,"docEnd":7911,"docs":{"brief":"Reads a single int16 (short) from a file. The value is sign-extended to\nan int32.","tags":[{"tag":"","text":"Reads a single int16 (short) from a file. The value is sign-extended to\nan int32."},{"tag":"param:data","text":"Variable to store the data read."},{"tag":"return","text":"True on success, false on failure."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int&","name":"data","decl":"int& data"}]},{"name":"ReadUint16","docStart":7959,"docEnd":8187,"docs":{"brief":"Reads a single unt16 (unsigned short) from a file. The value is zero-\nextended to an int32.","tags":[{"tag":"","text":"Reads a single unt16 (unsigned short) from a file. The value is zero-\nextended to an int32."},{"tag":"param:data","text":"Variable to store the data read."},{"tag":"return","text":"True on success, false on failure."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int&","name":"data","decl":"int& data"}]},{"name":"ReadInt32","docStart":8236,"docEnd":8412,"docs":{"brief":"Reads a single int32 (int/cell) from a file.","tags":[{"tag":"","text":"Reads a single int32 (int/cell) from a file."},{"tag":"param:data","text":"Variable to store the data read."},{"tag":"return","text":"True on success, false on failure."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int&","name":"data","decl":"int& data"}]},{"name":"WriteInt8","docStart":8460,"docEnd":8635,"docs":{"brief":"Writes a single int8 (byte) to a file.","tags":[{"tag":"","text":"Writes a single int8 (byte) to a file."},{"tag":"param:data","text":"Data to write (truncated to an int8)."},{"tag":"return","text":"True on success, false on failure."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"data","decl":"int data"}]},{"name":"WriteInt16","docStart":8682,"docEnd":8860,"docs":{"brief":"Writes a single int16 (short) to a file.","tags":[{"tag":"","text":"Writes a single int16 (short) to a file."},{"tag":"param:data","text":"Data to write (truncated to an int16)."},{"tag":"return","text":"True on success, false on failure."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"data","decl":"int data"}]},{"name":"WriteInt32","docStart":8908,"docEnd":9065,"docs":{"brief":"Writes a single int32 (int/cell) to a file.","tags":[{"tag":"","text":"Writes a single int32 (int/cell) to a file."},{"tag":"param:data","text":"Data to write."},{"tag":"return","text":"True on success, false on failure."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"data","decl":"int data"}]},{"name":"EndOfFile","docStart":9113,"docEnd":9246,"docs":{"brief":"Tests if the end of file has been reached.","tags":[{"tag":"","text":"Tests if the end of file has been reached."},{"tag":"return","text":"True if end of file has been reached, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[]},{"name":"Seek","docStart":9285,"docEnd":9537,"docs":{"brief":"Sets the file position indicator.","tags":[{"tag":"","text":"Sets the file position indicator."},{"tag":"param:position","text":"Position relative to what is specified in whence."},{"tag":"param:where","text":"SEEK_ constant value of where to see from."},{"tag":"return","text":"True on success, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"position","decl":"int position"},{"type":"int","name":"where","decl":"int where"}]},{"name":"Flush","docStart":9594,"docEnd":9834,"docs":{"brief":"Flushes a file's buffered output; any buffered output\nis immediately written to the file.","tags":[{"tag":"","text":"Flushes a file's buffered output; any buffered output\nis immediately written to the file."},{"tag":"return","text":"True on success or use_valve_fs specified with OpenFile,\notherwise false on failure."}]},"kind":"native","returnType":"bool","arguments":[]}],"properties":[{"name":"Position","docStart":9870,"docEnd":9933,"docs":{"brief":"Get the current position in the file; returns -1 on failure.","tags":[{"tag":"","text":"Get the current position in the file; returns -1 on failure."}]},"type":"int","getter":true,"setter":false}]}],"constants":[],"enums":[{"name":"FileType","docStart":2297,"docEnd":2327,"docs":{"brief":"File inode types.","tags":[{"tag":"","text":"File inode types."}]},"entries":[{"name":"FileType_Unknown","docStart":2372,"docEnd":2411,"docs":{"brief":"Unknown file type (device/socket)","tags":[{"tag":"","text":"Unknown file type (device/socket)"}]}},{"name":"FileType_Directory","docStart":2438,"docEnd":2463,"docs":{"brief":"File is a directory","tags":[{"tag":"","text":"File is a directory"}]}},{"name":"FileType_File","docStart":2490,"docEnd":2510,"docs":{"brief":"File is a file","tags":[{"tag":"","text":"File is a file"}]}}]},{"name":"FileTimeMode","docStart":2518,"docEnd":2547,"docs":{"brief":"File time modes.","tags":[{"tag":"","text":"File time modes."}]},"entries":[{"name":"FileTime_LastAccess","docStart":2600,"docEnd":2640,"docs":{"brief":"Last access (does not work on FAT)","tags":[{"tag":"","text":"Last access (does not work on FAT)"}]}},{"name":"FileTime_Created","docStart":2671,"docEnd":2708,"docs":{"brief":"Creation (does not work on FAT)","tags":[{"tag":"","text":"Creation (does not work on FAT)"}]}},{"name":"FileTime_LastChange","docStart":2739,"docEnd":2762,"docs":{"brief":"Last modification","tags":[{"tag":"","text":"Last modification"}]}}]},{"name":"PathType","docStart":3028,"docEnd":3052,"docs":{"brief":"Path types.","tags":[{"tag":"","text":"Path types."}]},"entries":[{"name":"Path_SM","docStart":3101,"docEnd":3130,"docs":{"brief":"SourceMod root folder","tags":[{"tag":"","text":"SourceMod root folder"}]}}]}],"typesets":[],"typedefs":[]}