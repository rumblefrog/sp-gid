{"functions":[{"name":"CreateTimer","docStart":3200,"docEnd":3828,"docs":{"brief":"Creates a basic timer.  Calling CloseHandle() on a timer will end the timer.","tags":[{"tag":"","text":"Creates a basic timer.  Calling CloseHandle() on a timer will end the timer."},{"tag":"param:interval","text":"Interval from the current game time to execute the given function."},{"tag":"param:func","text":"Function to execute once the given interval has elapsed."},{"tag":"param:data","text":"Handle or value to pass through to the timer callback function."},{"tag":"param:flags","text":"Flags to set (such as repeatability or auto-Handle closing)."},{"tag":"return","text":"Handle to the timer object.  You do not need to call CloseHandle().\nIf the timer could not be created, INVALID_HANDLE will be returned."}]},"kind":"native","returnType":"Handle","arguments":[{"type":"float","name":"interval","decl":"float interval","default":null},{"type":"Timer","name":"func","decl":"Timer func","default":null},{"type":"any","name":"data","decl":"any data","default":"INVALID_HANDLE"},{"type":"int","name":"flags","decl":"int flags","default":"0"}]},{"name":"KillTimer","docStart":3926,"docEnd":4320,"docs":{"brief":"Kills a timer.  Use this instead of CloseHandle() if you need more options.","tags":[{"tag":"","text":"Kills a timer.  Use this instead of CloseHandle() if you need more options."},{"tag":"param:timer","text":"Timer Handle to kill."},{"tag":"param:autoClose","text":"If autoClose is true, the data that was passed to CreateTimer() will\nbe closed as a handle if TIMER_DATA_HNDL_CLOSE was not specified."},{"tag":"error","text":"Invalid handles will cause a run time error."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"timer","decl":"Handle timer","default":null},{"type":"bool","name":"autoClose","decl":"bool autoClose","default":"false"}]},{"name":"TriggerTimer","docStart":4384,"docEnd":4648,"docs":{"brief":"Manually triggers a timer so its function will be called.","tags":[{"tag":"","text":"Manually triggers a timer so its function will be called."},{"tag":"param:timer","text":"Timer Handle to trigger."},{"tag":"param:reset","text":"If reset is true, the elapsed time counter is reset\nso the full interval must pass again."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"timer","decl":"Handle timer","default":null},{"type":"bool","name":"reset","decl":"bool reset","default":"false"}]},{"name":"GetTickedTime","docStart":4711,"docEnd":5159,"docs":{"brief":"Returns the simulated game time.\n\nThis time is internally maintained by SourceMod and is based on the game\ntick count and tick rate.  Unlike GetGameTime(), it will increment past\nmap changes and while no players are connected.  Unlike GetEngineTime(),\nit will not increment based on the system clock (i.e. it is still bound\nto the ticking process).","tags":[{"tag":"","text":"Returns the simulated game time.\n\nThis time is internally maintained by SourceMod and is based on the game\ntick count and tick rate.  Unlike GetGameTime(), it will increment past\nmap changes and while no players are connected.  Unlike GetEngineTime(),\nit will not increment based on the system clock (i.e. it is still bound\nto the ticking process)."},{"tag":"return","text":"Time based on the game tick count."}]},"kind":"native","returnType":"float","arguments":[]},{"name":"GetMapTimeLeft","docStart":5194,"docEnd":5646,"docs":{"brief":"Returns an estimate of the time left before the map ends.  If the server\nhas not processed any frames yet (i.e. no players have joined the map yet),\nthen the time left returned will always be infinite.","tags":[{"tag":"","text":"Returns an estimate of the time left before the map ends.  If the server\nhas not processed any frames yet (i.e. no players have joined the map yet),\nthen the time left returned will always be infinite."},{"tag":"param:timeleft","text":"Variable to store the time, in seconds.  If the\nvalue is less than 0, the time limit is infinite."},{"tag":"return","text":"True if the operation is supported, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int&","name":"timeleft","decl":"int& timeleft","default":null}]},{"name":"GetMapTimeLimit","docStart":5694,"docEnd":6117,"docs":{"brief":"Retrieves the current map time limit.  If the server has not processed any\nframes yet (i.e. no players have joined the map yet), then the time limit\nreturned will always be 0.","tags":[{"tag":"","text":"Retrieves the current map time limit.  If the server has not processed any\nframes yet (i.e. no players have joined the map yet), then the time limit\nreturned will always be 0."},{"tag":"param:time","text":"Set to the number of total seconds in the map time\nlimit, or 0 if there is no time limit set."},{"tag":"return","text":"True on success, false if operation is not supported."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int&","name":"time","decl":"int& time","default":null}]},{"name":"ExtendMapTimeLimit","docStart":6162,"docEnd":6549,"docs":{"brief":"Extends the map time limit in a way that will notify all plugins.","tags":[{"tag":"","text":"Extends the map time limit in a way that will notify all plugins."},{"tag":"param:time","text":"Number of seconds to extend map time limit by.\nThe number can be negative to decrease the time limit.\nIf 0, the map will be set to have no time limit."},{"tag":"return","text":"True on success, false if operation is not supported."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"time","decl":"int time","default":null}]},{"name":"GetTickInterval","docStart":6596,"docEnd":6784,"docs":{"brief":"Returns the number of seconds in between game server ticks.\n\nNote: A tick, in this context, is a frame.","tags":[{"tag":"","text":"Returns the number of seconds in between game server ticks.\n\nNote: A tick, in this context, is a frame."},{"tag":"return","text":"Number of seconds in between ticks."}]},"kind":"native","returnType":"float","arguments":[]},{"name":"OnMapTimeLeftChanged","docStart":6821,"docEnd":7442,"docs":{"brief":"Notification that the map's time left has changed via a change in the time\nlimit or a change in the game rules (such as mp_restartgame).  This is useful\nfor plugins trying to create timers based on the time left in the map.\n\nCalling ExtendMapTimeLimit() from here, without proper precaution, will\ncause infinite recursion.\n\nIf the operation is not supported, this will never be called.\n\nIf the server has not yet processed any frames (i.e. no players have joined\nthe map yet), then this will be called once the server begins ticking, even\nif there is no time limit set.","tags":[{"tag":"","text":"Notification that the map's time left has changed via a change in the time\nlimit or a change in the game rules (such as mp_restartgame).  This is useful\nfor plugins trying to create timers based on the time left in the map.\n\nCalling ExtendMapTimeLimit() from here, without proper precaution, will\ncause infinite recursion.\n\nIf the operation is not supported, this will never be called.\n\nIf the server has not yet processed any frames (i.e. no players have joined\nthe map yet), then this will be called once the server begins ticking, even\nif there is no time limit set."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"IsServerProcessing","docStart":7484,"docEnd":7832,"docs":{"brief":"Returns whether or not the server is processing frames or not.\n\nThe server does not process frames until at least one client joins the game.\nOnce the first player has in, even if that player, leaves, the server's\ntimers and entities will work.","tags":[{"tag":"","text":"Returns whether or not the server is processing frames or not.\n\nThe server does not process frames until at least one client joins the game.\nOnce the first player has in, even if that player, leaves, the server's\ntimers and entities will work."},{"tag":"return","text":"True if the server is ticking, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[]},{"name":"CreateDataTimer","docStart":7871,"docEnd":8574,"docs":{"brief":"Creates a timer associated with a new datapack, and returns the datapack.","tags":[{"tag":"","text":"Creates a timer associated with a new datapack, and returns the datapack."},{"tag":"note","text":"The datapack is automatically freed when the timer ends."},{"tag":"note","text":"The position of the datapack is not reset or changed for the timer function."},{"tag":"param:interval","text":"Interval from the current game time to execute the given function."},{"tag":"param:func","text":"Function to execute once the given interval has elapsed."},{"tag":"param:datapack","text":"The newly created datapack is passed though this by-reference\nparameter to the timer callback function."},{"tag":"param:flags","text":"Timer flags."},{"tag":"return","text":"Handle to the timer object.  You do not need to call CloseHandle()."}]},"kind":"stock","returnType":"Handle","arguments":[{"type":"float","name":"interval","decl":"float interval","default":null},{"type":"Timer","name":"func","decl":"Timer func","default":null},{"type":"Handle&","name":"datapack","decl":"Handle &datapack","default":null},{"type":"int","name":"flags","decl":"int flags","default":"0"}]}],"methodmaps":[],"enumstructs":[],"constants":[],"enums":[],"typesets":[{"name":"Timer","docStart":2065,"docEnd":2141,"docs":{"brief":"Any of the following prototypes will work for a timed function.","tags":[{"tag":"","text":"Any of the following prototypes will work for a timed function."}]},"types":[{"docStart":2162,"docEnd":2489,"docs":{"brief":"Called when the timer interval has elapsed.","tags":[{"tag":"","text":"Called when the timer interval has elapsed."},{"tag":"param:timer","text":"Handle to the timer object."},{"tag":"param:hndl","text":"Handle passed to CreateTimer() when timer was created."},{"tag":"return","text":"Plugin_Stop to stop a repeating timer, any other value for\ndefault behavior."}]},"type":"function Action(Handle timer, Handle hndl)","parsedSignature":{"returnType":"Action","arguments":[{"type":"Handle","name":"timer","decl":"Handle timer","default":null},{"type":"Handle","name":"hndl","decl":"Handle hndl","default":null}]}},{"docStart":2540,"docEnd":2865,"docs":{"brief":"Called when the timer interval has elapsed.","tags":[{"tag":"","text":"Called when the timer interval has elapsed."},{"tag":"param:timer","text":"Handle to the timer object."},{"tag":"param:data","text":"Data passed to CreateTimer() when timer was created."},{"tag":"return","text":"Plugin_Stop to stop a repeating timer, any other value for\ndefault behavior."}]},"type":"function Action(Handle timer, any data)","parsedSignature":{"returnType":"Action","arguments":[{"type":"Handle","name":"timer","decl":"Handle timer","default":null},{"type":"any","name":"data","decl":"any data","default":null}]}},{"docStart":2913,"docEnd":3159,"docs":{"brief":"Called when the timer interval has elapsed.","tags":[{"tag":"","text":"Called when the timer interval has elapsed."},{"tag":"param:timer","text":"Handle to the timer object."},{"tag":"return","text":"Plugin_Stop to stop a repeating timer, any other value for\ndefault behavior."}]},"type":"function Action(Handle timer)","parsedSignature":{"returnType":"Action","arguments":[]}}]}],"typedefs":[]}