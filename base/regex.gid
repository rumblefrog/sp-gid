{"functions":[{"name":"CompileRegex","docStart":8460,"docEnd":9076,"docs":{"brief":"Precompile a regular expression.  Use this if you intend on using the\nsame expression multiple times.  Pass the regex handle returned here to\nMatchRegex to check for matches.","tags":[{"tag":"","text":"Precompile a regular expression.  Use this if you intend on using the\nsame expression multiple times.  Pass the regex handle returned here to\nMatchRegex to check for matches."},{"tag":"param:pattern","text":"The regular expression pattern."},{"tag":"param:flags","text":"General flags for the regular expression."},{"tag":"param:error","text":"Error message encountered, if applicable."},{"tag":"param:maxLen","text":"Maximum string length of the error buffer."},{"tag":"param:errcode","text":"Regex type error code encountered, if applicable."},{"tag":"return","text":"Valid regex handle on success, INVALID_HANDLE on failure."}]},"kind":"native","returnType":"Regex","arguments":[{"type":"const char[]","name":"pattern","decl":"const char[] pattern","default":null},{"type":"int","name":"flags","decl":"int flags","default":"0"},{"type":"char[]","name":"error","decl":"char[] error","default":"\"\""},{"type":"int","name":"maxLen","decl":"int maxLen","default":"0"},{"type":"RegexError&","name":"errcode","decl":"RegexError& errcode","default":"REGEX_ERROR_NONE"}]},{"name":"MatchRegex","docStart":9218,"docEnd":9640,"docs":{"brief":"Matches a string against a pre-compiled regular expression pattern.","tags":[{"tag":"","text":"Matches a string against a pre-compiled regular expression pattern."},{"tag":"param:regex","text":"Regex Handle from CompileRegex()"},{"tag":"param:str","text":"The string to check."},{"tag":"param:ret","text":"Error code, if applicable."},{"tag":"return","text":"Number of captures found or -1 on failure."},{"tag":"note","text":"Use the regex handle passed to this function to extract\nmatches with GetRegexSubString()."}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"regex","decl":"Handle regex","default":null},{"type":"const char[]","name":"str","decl":"const char[] str","default":null},{"type":"RegexError&","name":"ret","decl":"RegexError& ret","default":"REGEX_ERROR_NONE"}]},{"name":"GetRegexSubString","docStart":9736,"docEnd":10387,"docs":{"brief":"Returns a matched substring from a regex handle.\nSubstring ids start at 0 and end at captures-1, where captures is the number returned\nby MatchRegex.","tags":[{"tag":"","text":"Returns a matched substring from a regex handle.\nSubstring ids start at 0 and end at captures-1, where captures is the number returned\nby MatchRegex."},{"tag":"param:regex","text":"The regex handle to extract data from."},{"tag":"param:str_id","text":"The index of the expression to get - starts at 0, and ends at captures - 1."},{"tag":"param:buffer","text":"The buffer to set to the matching substring."},{"tag":"param:maxlen","text":"The maximum string length of the buffer."},{"tag":"return","text":"True if a substring was found, False on fail/error"},{"tag":"note","text":"str_id = 0 is the full captured string, anything else is the capture group index.\n"}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"regex","decl":"Handle regex","default":null},{"type":"int","name":"str_id","decl":"int str_id","default":null},{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"maxlen","decl":"int maxlen","default":null}]},{"name":"SimpleRegexMatch","docStart":10476,"docEnd":11121,"docs":{"brief":"Matches a string against a regular expression pattern.","tags":[{"tag":"","text":"Matches a string against a regular expression pattern."},{"tag":"note","text":"If you intend on using the same regular expression pattern\nmultiple times, consider using CompileRegex and MatchRegex\ninstead of making this function reparse the expression each time."},{"tag":"param:str","text":"The string to check."},{"tag":"param:pattern","text":"The regular expression pattern."},{"tag":"param:flags","text":"General flags for the regular expression."},{"tag":"param:error","text":"Error message, if applicable."},{"tag":"param:maxLen","text":"Maximum length of the error buffer."},{"tag":"return","text":"Number of substrings found or -1 on failure."}]},"kind":"stock","returnType":"int","arguments":[{"type":"const char[]","name":"str","decl":"const char[] str","default":null},{"type":"const char[]","name":"pattern","decl":"const char[] pattern","default":null},{"type":"int","name":"flags","decl":"int flags","default":"0"},{"type":"char[]","name":"error","decl":"char[] error","default":"\"\""},{"type":"int","name":"maxLen","decl":"int maxLen","default":"0"}]},{"name":"__ext_regex_SetNTVOptional","docStart":0,"docEnd":0,"docs":null,"kind":"public","returnType":"void","arguments":[]}],"methodmaps":[{"name":"Regex","docStart":5141,"docEnd":5232,"docs":{"brief":"Regular expression objects are used to match or decompose strings based on\npatterns.","tags":[{"tag":"","text":"Regular expression objects are used to match or decompose strings based on\npatterns."}]},"parent":"Handle","methods":[{"name":"Regex","docStart":5264,"docEnd":5640,"docs":{"brief":"Compile a regular expression.","tags":[{"tag":"","text":"Compile a regular expression."},{"tag":"param:pattern","text":"The regular expression pattern."},{"tag":"param:flags","text":"General flags for the regular expression."},{"tag":"param:error","text":"Error message encountered, if applicable."},{"tag":"param:maxLen","text":"Maximum string length of the error buffer."},{"tag":"param:errcode","text":"Regex type error code encountered, if applicable."}]},"kind":"native","returnType":"Regex","arguments":[{"type":"const char[]","name":"pattern","decl":"const char[] pattern","default":null},{"type":"int","name":"flags","decl":"int flags","default":"0"},{"type":"char[]","name":"error","decl":"char[] error","default":"\"\""},{"type":"int","name":"maxLen","decl":"int maxLen","default":"0"},{"type":"RegexError&","name":"errcode","decl":"RegexError& errcode","default":"REGEX_ERROR_NONE"}]},{"name":"Match","docStart":5778,"docEnd":6251,"docs":{"brief":"Matches a string against a pre-compiled regular expression pattern.","tags":[{"tag":"","text":"Matches a string against a pre-compiled regular expression pattern."},{"tag":"param:str","text":"The string to check."},{"tag":"param:ret","text":"Error code, if applicable."},{"tag":"param:offset","text":"Offset in the string to start searching from. MatchOffset returns the offset of the match."},{"tag":"return","text":"Number of captures found or -1 on failure."},{"tag":"note","text":"Use the regex handle passed to this function to extract\nmatches with GetSubString()."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"str","decl":"const char[] str","default":null},{"type":"RegexError&","name":"ret","decl":"RegexError& ret","default":"REGEX_ERROR_NONE"},{"type":"int","name":"offset","decl":"int offset","default":"0"}]},{"name":"MatchAll","docStart":6353,"docEnd":6682,"docs":{"brief":"Gets all matches from a string against a pre-compiled regular expression pattern.","tags":[{"tag":"","text":"Gets all matches from a string against a pre-compiled regular expression pattern."},{"tag":"param:str","text":"The string to check."},{"tag":"param:ret","text":"Error code, if applicable."},{"tag":"return","text":"Number of matches found or -1 on failure."},{"tag":"note","text":"Use GetSubString() and loop from 0 -> totalmatches - 1."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"str","decl":"const char[] str","default":null},{"type":"RegexError&","name":"ret","decl":"RegexError& ret","default":"REGEX_ERROR_NONE"}]},{"name":"GetSubString","docStart":6771,"docEnd":7534,"docs":{"brief":"Returns a matched substring from a regex handle.\n\nSubstring ids start at 0 and end at captures-1, where captures is the\nnumber returned by Regex.Match or Regex.CaptureCount.","tags":[{"tag":"","text":"Returns a matched substring from a regex handle.\n\nSubstring ids start at 0 and end at captures-1, where captures is the\nnumber returned by Regex.Match or Regex.CaptureCount."},{"tag":"param:str_id","text":"The index of the expression to get - starts at 0, and ends at captures - 1."},{"tag":"param:buffer","text":"The buffer to set to the matching substring."},{"tag":"param:maxlen","text":"The maximum string length of the buffer."},{"tag":"param:match","text":"Match to get the captures for - starts at 0, and ends at MatchCount() -1"},{"tag":"return","text":"True if a substring was found, False on fail/error"},{"tag":"note","text":"str_id = 0 is the full captured string, anything else is the capture group index.\nif Regex.Match is used match can only be 0"}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"str_id","decl":"int str_id","default":null},{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"maxlen","decl":"int maxlen","default":null},{"type":"int","name":"match","decl":"int match","default":"0"}]},{"name":"MatchCount","docStart":7628,"docEnd":7788,"docs":{"brief":"Returns number of matches\n\nWhen using Match this is always 1 or 0 (unless an error occured)","tags":[{"tag":"","text":"Returns number of matches\n\nWhen using Match this is always 1 or 0 (unless an error occured)"},{"tag":"return","text":"Total number of matches found."}]},"kind":"native","returnType":"int","arguments":[]},{"name":"CaptureCount","docStart":7827,"docEnd":8143,"docs":{"brief":"Returns number of captures for a match","tags":[{"tag":"","text":"Returns number of captures for a match"},{"tag":"param:match","text":"Match to get the number of captures for. Match starts at 0, and ends at MatchCount() -1"},{"tag":"return","text":"Number of captures in the match."},{"tag":"note","text":"Use GetSubString() and loop from 1 -> captures -1 for str_id to get all captures"}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"match","decl":"int match","default":"0"}]},{"name":"MatchOffset","docStart":8197,"docEnd":8404,"docs":{"brief":"Returns the string offset of a match.","tags":[{"tag":"","text":"Returns the string offset of a match."},{"tag":"param:match","text":"Match to get the offset of. Match starts at 0, and ends at MatchCount() -1"},{"tag":"return","text":"Offset of the match in the string."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"match","decl":"int match","default":"0"}]}],"properties":[]}],"enumstructs":[],"constants":[],"enums":[{"name":"RegexError","docStart":2903,"docEnd":2945,"docs":{"brief":"Regex expression error codes.","tags":[{"tag":"","text":"Regex expression error codes."}]},"entries":[{"name":"REGEX_ERROR_NONE","docStart":3004,"docEnd":3018,"docs":{"brief":"No error","tags":[{"tag":"","text":"No error"}]},"value":"0"},{"name":"REGEX_ERROR_ASSERT","docStart":3059,"docEnd":3081,"docs":{"brief":"internal error ?","tags":[{"tag":"","text":"internal error ?"}]},"value":"1"},{"name":"REGEX_ERROR_BADBR","docStart":3120,"docEnd":3153,"docs":{"brief":"invalid repeat counts in {}","tags":[{"tag":"","text":"invalid repeat counts in {}"}]},"value":null},{"name":"REGEX_ERROR_BADPAT","docStart":3192,"docEnd":3211,"docs":{"brief":"pattern error","tags":[{"tag":"","text":"pattern error"}]},"value":null},{"name":"REGEX_ERROR_BADRPT","docStart":3250,"docEnd":3269,"docs":{"brief":"? * + invalid","tags":[{"tag":"","text":"? * + invalid"}]},"value":null},{"name":"REGEX_ERROR_EBRACE","docStart":3308,"docEnd":3327,"docs":{"brief":"unbalanced {}","tags":[{"tag":"","text":"unbalanced {}"}]},"value":null},{"name":"REGEX_ERROR_EBRACK","docStart":3366,"docEnd":3385,"docs":{"brief":"unbalanced []","tags":[{"tag":"","text":"unbalanced []"}]},"value":null},{"name":"REGEX_ERROR_ECOLLATE","docStart":3424,"docEnd":3460,"docs":{"brief":"collation error - not relevant","tags":[{"tag":"","text":"collation error - not relevant"}]},"value":null},{"name":"REGEX_ERROR_ECTYPE","docStart":3499,"docEnd":3514,"docs":{"brief":"bad class","tags":[{"tag":"","text":"bad class"}]},"value":null},{"name":"REGEX_ERROR_EESCAPE","docStart":3553,"docEnd":3578,"docs":{"brief":"bad escape sequence","tags":[{"tag":"","text":"bad escape sequence"}]},"value":null},{"name":"REGEX_ERROR_EMPTY","docStart":3617,"docEnd":3639,"docs":{"brief":"empty expression","tags":[{"tag":"","text":"empty expression"}]},"value":null},{"name":"REGEX_ERROR_EPAREN","docStart":3678,"docEnd":3697,"docs":{"brief":"unbalanced ()","tags":[{"tag":"","text":"unbalanced ()"}]},"value":null},{"name":"REGEX_ERROR_ERANGE","docStart":3736,"docEnd":3761,"docs":{"brief":"bad range inside []","tags":[{"tag":"","text":"bad range inside []"}]},"value":null},{"name":"REGEX_ERROR_ESIZE","docStart":3800,"docEnd":3824,"docs":{"brief":"expression too big","tags":[{"tag":"","text":"expression too big"}]},"value":null},{"name":"REGEX_ERROR_ESPACE","docStart":3863,"docEnd":3889,"docs":{"brief":"failed to get memory","tags":[{"tag":"","text":"failed to get memory"}]},"value":null},{"name":"REGEX_ERROR_ESUBREG","docStart":3928,"docEnd":3952,"docs":{"brief":"bad back reference","tags":[{"tag":"","text":"bad back reference"}]},"value":null},{"name":"REGEX_ERROR_INVARG","docStart":3991,"docEnd":4009,"docs":{"brief":"bad argument","tags":[{"tag":"","text":"bad argument"}]},"value":null},{"name":"REGEX_ERROR_NOMATCH","docStart":4050,"docEnd":4074,"docs":{"brief":"No match was found","tags":[{"tag":"","text":"No match was found"}]},"value":"-1"},{"name":"REGEX_ERROR_NULL","docStart":0,"docEnd":0,"docs":null,"value":"-2"},{"name":"REGEX_ERROR_BADOPTION","docStart":0,"docEnd":0,"docs":null,"value":"-3"},{"name":"REGEX_ERROR_BADMAGIC","docStart":0,"docEnd":0,"docs":null,"value":"-4"},{"name":"REGEX_ERROR_UNKNOWN_OPCODE","docStart":0,"docEnd":0,"docs":null,"value":"-5"},{"name":"REGEX_ERROR_NOMEMORY","docStart":0,"docEnd":0,"docs":null,"value":"-6"},{"name":"REGEX_ERROR_NOSUBSTRING","docStart":0,"docEnd":0,"docs":null,"value":"-7"},{"name":"REGEX_ERROR_MATCHLIMIT","docStart":0,"docEnd":0,"docs":null,"value":"-8"},{"name":"REGEX_ERROR_CALLOUT","docStart":4324,"docEnd":4355,"docs":{"brief":"Never used by PCRE itself","tags":[{"tag":"","text":"Never used by PCRE itself"}]},"value":"-9"},{"name":"REGEX_ERROR_BADUTF8","docStart":0,"docEnd":0,"docs":null,"value":"-10"},{"name":"REGEX_ERROR_BADUTF8_OFFSET","docStart":0,"docEnd":0,"docs":null,"value":"-11"},{"name":"REGEX_ERROR_PARTIAL","docStart":0,"docEnd":0,"docs":null,"value":"-12"},{"name":"REGEX_ERROR_BADPARTIAL","docStart":0,"docEnd":0,"docs":null,"value":"-13"},{"name":"REGEX_ERROR_INTERNAL","docStart":0,"docEnd":0,"docs":null,"value":"-14"},{"name":"REGEX_ERROR_BADCOUNT","docStart":0,"docEnd":0,"docs":null,"value":"-15"},{"name":"REGEX_ERROR_DFA_UITEM","docStart":0,"docEnd":0,"docs":null,"value":"-16"},{"name":"REGEX_ERROR_DFA_UCOND","docStart":0,"docEnd":0,"docs":null,"value":"-17"},{"name":"REGEX_ERROR_DFA_UMLIMIT","docStart":0,"docEnd":0,"docs":null,"value":"-18"},{"name":"REGEX_ERROR_DFA_WSSIZE","docStart":0,"docEnd":0,"docs":null,"value":"-19"},{"name":"REGEX_ERROR_DFA_RECURSE","docStart":0,"docEnd":0,"docs":null,"value":"-20"},{"name":"REGEX_ERROR_RECURSIONLIMIT","docStart":0,"docEnd":0,"docs":null,"value":"-21"},{"name":"REGEX_ERROR_NULLWSLIMIT","docStart":4776,"docEnd":4805,"docs":{"brief":"No longer actually used","tags":[{"tag":"","text":"No longer actually used"}]},"value":"-22"},{"name":"REGEX_ERROR_BADNEWLINE","docStart":0,"docEnd":0,"docs":null,"value":"-23"},{"name":"REGEX_ERROR_BADOFFSET","docStart":0,"docEnd":0,"docs":null,"value":"-24"},{"name":"REGEX_ERROR_SHORTUTF8","docStart":0,"docEnd":0,"docs":null,"value":"-25"},{"name":"REGEX_ERROR_RECURSELOOP","docStart":0,"docEnd":0,"docs":null,"value":"-26"},{"name":"REGEX_ERROR_JIT_STACKLIMIT","docStart":0,"docEnd":0,"docs":null,"value":"-27"},{"name":"REGEX_ERROR_BADMODE","docStart":0,"docEnd":0,"docs":null,"value":"-28"},{"name":"REGEX_ERROR_BADENDIANNESS","docStart":0,"docEnd":0,"docs":null,"value":"-29"},{"name":"REGEX_ERROR_DFA_BADRESTART","docStart":0,"docEnd":0,"docs":null,"value":"-30"},{"name":"REGEX_ERROR_JIT_BADOPTION","docStart":0,"docEnd":0,"docs":null,"value":"-31"},{"name":"REGEX_ERROR_BADLENGTH","docStart":0,"docEnd":0,"docs":null,"value":"-32"}]}],"typesets":[],"typedefs":[]}