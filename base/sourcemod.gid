{"functions":[{"name":"OnPluginStart","docStart":4128,"docEnd":4433,"docs":{"brief":"Called when the plugin is fully initialized and all known external references\nare resolved. This is only called once in the lifetime of the plugin, and is\npaired with OnPluginEnd().\n\nIf any run-time error is thrown during this callback, the plugin will be marked\nas failed.","tags":[{"tag":"","text":"Called when the plugin is fully initialized and all known external references\nare resolved. This is only called once in the lifetime of the plugin, and is\npaired with OnPluginEnd().\n\nIf any run-time error is thrown during this callback, the plugin will be marked\nas failed."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"AskPluginLoad","docStart":0,"docEnd":0,"docs":null,"kind":"forward","returnType":"bool","arguments":[{"type":"Handle","name":"myself","decl":"Handle myself","default":null},{"type":"bool","name":"late","decl":"bool late","default":null},{"type":"char[]","name":"error","decl":"char[] error","default":null},{"type":"int","name":"err_max","decl":"int err_max","default":null}]},{"name":"AskPluginLoad2","docStart":4813,"docEnd":5953,"docs":{"brief":"Called before OnPluginStart, in case the plugin wants to check for load failure.\nThis is called even if the plugin type is \"private.\"  Any natives from modules are\nnot available at this point.  Thus, this forward should only be used for explicit\npre-emptive things, such as adding dynamic natives, setting certain types of load\nfilters (such as not loading the plugin for certain games).","tags":[{"tag":"","text":"Called before OnPluginStart, in case the plugin wants to check for load failure.\nThis is called even if the plugin type is \"private.\"  Any natives from modules are\nnot available at this point.  Thus, this forward should only be used for explicit\npre-emptive things, such as adding dynamic natives, setting certain types of load\nfilters (such as not loading the plugin for certain games)."},{"tag":"note","text":"It is not safe to call externally resolved natives until OnPluginStart()."},{"tag":"note","text":"Any sort of RTE in this function will cause the plugin to fail loading."},{"tag":"note","text":"If you do not return anything, it is treated like returning success."},{"tag":"note","text":"If a plugin has an AskPluginLoad2(), AskPluginLoad() will not be called."},{"tag":"param:myself","text":"Handle to the plugin."},{"tag":"param:late","text":"Whether or not the plugin was loaded \"late\" (after map load)."},{"tag":"param:error","text":"Error message buffer in case load failed."},{"tag":"param:err_max","text":"Maximum number of characters for error message buffer."},{"tag":"return","text":"APLRes_Success for load success, APLRes_Failure or APLRes_SilentFailure otherwise"}]},"kind":"forward","returnType":"APLRes","arguments":[{"type":"Handle","name":"myself","decl":"Handle myself","default":null},{"type":"bool","name":"late","decl":"bool late","default":null},{"type":"char[]","name":"error","decl":"char[] error","default":null},{"type":"int","name":"err_max","decl":"int err_max","default":null}]},{"name":"OnPluginEnd","docStart":6042,"docEnd":6287,"docs":{"brief":"Called when the plugin is about to be unloaded.\n\nIt is not necessary to close any handles or remove hooks in this function.\nSourceMod guarantees that plugin shutdown automatically and correctly releases\nall resources.","tags":[{"tag":"","text":"Called when the plugin is about to be unloaded.\n\nIt is not necessary to close any handles or remove hooks in this function.\nSourceMod guarantees that plugin shutdown automatically and correctly releases\nall resources."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnPluginPauseChange","docStart":6320,"docEnd":6465,"docs":{"brief":"Called when the plugin's pause status is changing.","tags":[{"tag":"","text":"Called when the plugin's pause status is changing."},{"tag":"param:pause","text":"True if the plugin is being paused, false otherwise."}]},"kind":"forward","returnType":"void","arguments":[{"type":"bool","name":"pause","decl":"bool pause","default":null}]},{"name":"OnGameFrame","docStart":6516,"docEnd":6656,"docs":{"brief":"Called before every server frame.  Note that you should avoid\ndoing expensive computations or declaring large local arrays.","tags":[{"tag":"","text":"Called before every server frame.  Note that you should avoid\ndoing expensive computations or declaring large local arrays."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnMapStart","docStart":6689,"docEnd":6860,"docs":{"brief":"Called when the map is loaded.","tags":[{"tag":"","text":"Called when the map is loaded."},{"tag":"note","text":"This used to be OnServerLoad(), which is now deprecated.\nPlugins still using the old forward will work."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnMapEnd","docStart":6892,"docEnd":6936,"docs":{"brief":"Called right before a map ends.","tags":[{"tag":"","text":"Called right before a map ends."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnConfigsExecuted","docStart":6966,"docEnd":7310,"docs":{"brief":"Called when the map has loaded, servercfgfile (server.cfg) has been\nexecuted, and all plugin configs are done executing.  This is the best\nplace to initialize plugin functions which are based on cvar data.","tags":[{"tag":"","text":"Called when the map has loaded, servercfgfile (server.cfg) has been\nexecuted, and all plugin configs are done executing.  This is the best\nplace to initialize plugin functions which are based on cvar data."},{"tag":"note","text":"This will always be called once and only once per map.  It will be\ncalled after OnMapStart()."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnAutoConfigsBuffered","docStart":7349,"docEnd":7914,"docs":{"brief":"This is called once, right after OnMapStart() but any time before\nOnConfigsExecuted().  It is called after the \"exec sourcemod.cfg\"\ncommand and all AutoExecConfig() exec commands have been added to\nthe ServerCommand() buffer.\n\nIf you need to load per-map settings that override default values,\nadding commands to the ServerCommand() buffer here will guarantee\nthat they're set before OnConfigsExecuted().\n\nUnlike OnMapStart() and OnConfigsExecuted(), this is not called on\nlate loads that occur after OnMapStart().","tags":[{"tag":"","text":"This is called once, right after OnMapStart() but any time before\nOnConfigsExecuted().  It is called after the \"exec sourcemod.cfg\"\ncommand and all AutoExecConfig() exec commands have been added to\nthe ServerCommand() buffer.\n\nIf you need to load per-map settings that override default values,\nadding commands to the ServerCommand() buffer here will guarantee\nthat they're set before OnConfigsExecuted().\n\nUnlike OnMapStart() and OnConfigsExecuted(), this is not called on\nlate loads that occur after OnMapStart()."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"OnServerCfg","docStart":0,"docEnd":0,"docs":null,"kind":"forward","returnType":"void","arguments":[]},{"name":"OnAllPluginsLoaded","docStart":8108,"docEnd":8288,"docs":{"brief":"Called after all plugins have been loaded.  This is called once for\nevery plugin.  If a plugin late loads, it will be called immediately\nafter OnPluginStart().","tags":[{"tag":"","text":"Called after all plugins have been loaded.  This is called once for\nevery plugin.  If a plugin late loads, it will be called immediately\nafter OnPluginStart()."}]},"kind":"forward","returnType":"void","arguments":[]},{"name":"GetMyHandle","docStart":8328,"docEnd":8436,"docs":{"brief":"Returns the calling plugin's Handle.","tags":[{"tag":"","text":"Returns the calling plugin's Handle."},{"tag":"return","text":"Handle of the calling plugin."}]},"kind":"native","returnType":"Handle","arguments":[]},{"name":"GetPluginIterator","docStart":8470,"docEnd":8700,"docs":{"brief":"Returns an iterator that can be used to search through plugins.","tags":[{"tag":"","text":"Returns an iterator that can be used to search through plugins."},{"tag":"return","text":"Handle to iterate with.  Must be closed via\nCloseHandle()."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"Handle","arguments":[]},{"name":"MorePlugins","docStart":8740,"docEnd":8983,"docs":{"brief":"Returns whether there are more plugins available in the iterator.","tags":[{"tag":"","text":"Returns whether there are more plugins available in the iterator."},{"tag":"param:iter","text":"Handle to the plugin iterator."},{"tag":"return","text":"True on more plugins, false otherwise."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"iter","decl":"Handle iter","default":null}]},{"name":"ReadPlugin","docStart":9026,"docEnd":9327,"docs":{"brief":"Returns the current plugin in the iterator and advances the iterator.","tags":[{"tag":"","text":"Returns the current plugin in the iterator and advances the iterator."},{"tag":"param:iter","text":"Handle to the plugin iterator."},{"tag":"return","text":"Current plugin the iterator is at, before\nthe iterator is advanced."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"Handle","arguments":[{"type":"Handle","name":"iter","decl":"Handle iter","default":null}]},{"name":"GetPluginStatus","docStart":9371,"docEnd":9589,"docs":{"brief":"Returns a plugin's status.","tags":[{"tag":"","text":"Returns a plugin's status."},{"tag":"param:plugin","text":"Plugin Handle (INVALID_HANDLE uses the calling plugin)."},{"tag":"return","text":"Status code for the plugin."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"PluginStatus","arguments":[{"type":"Handle","name":"plugin","decl":"Handle plugin","default":null}]},{"name":"GetPluginFilename","docStart":9646,"docEnd":9967,"docs":{"brief":"Retrieves a plugin's file name relative to the plugins folder.","tags":[{"tag":"","text":"Retrieves a plugin's file name relative to the plugins folder."},{"tag":"param:plugin","text":"Plugin Handle (INVALID_HANDLE uses the calling plugin)."},{"tag":"param:buffer","text":"Buffer to the store the file name."},{"tag":"param:maxlength","text":"Maximum length of the name buffer."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"plugin","decl":"Handle plugin","default":null},{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"maxlength","decl":"int maxlength","default":null}]},{"name":"IsPluginDebugging","docStart":10048,"docEnd":10305,"docs":{"brief":"Retrieves whether or not a plugin is being debugged.","tags":[{"tag":"","text":"Retrieves whether or not a plugin is being debugged."},{"tag":"param:plugin","text":"Plugin Handle (INVALID_HANDLE uses the calling plugin)."},{"tag":"return","text":"True if being debugged, false otherwise."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"plugin","decl":"Handle plugin","default":null}]},{"name":"GetPluginInfo","docStart":10356,"docEnd":10766,"docs":{"brief":"Retrieves a plugin's public info.","tags":[{"tag":"","text":"Retrieves a plugin's public info."},{"tag":"param:plugin","text":"Plugin Handle (INVALID_HANDLE uses the calling plugin)."},{"tag":"param:info","text":"Plugin info property to retrieve."},{"tag":"param:buffer","text":"Buffer to store info in."},{"tag":"param:maxlength","text":"Maximum length of buffer."},{"tag":"return","text":"True on success, false if property is not available."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"plugin","decl":"Handle plugin","default":null},{"type":"PluginInfo","name":"info","decl":"PluginInfo info","default":null},{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"maxlength","decl":"int maxlength","default":null}]},{"name":"FindPluginByNumber","docStart":10860,"docEnd":11368,"docs":{"brief":"Finds a plugin by its order in the list from the \"plugins list\" server\n\"sm\" command.  You should not use this function to loop through all plugins,\nuse the iterator instead.  Looping through all plugins using this native\nis O(n^2), whereas using the iterator is O(n).","tags":[{"tag":"","text":"Finds a plugin by its order in the list from the \"plugins list\" server\n\"sm\" command.  You should not use this function to loop through all plugins,\nuse the iterator instead.  Looping through all plugins using this native\nis O(n^2), whereas using the iterator is O(n)."},{"tag":"param:order_num","text":"Number of the plugin as it appears in \"sm plugins list\"."},{"tag":"return","text":"Plugin Handle on success, INVALID_HANDLE if no plugin\nmatches the given number."}]},"kind":"native","returnType":"Handle","arguments":[{"type":"int","name":"order_num","decl":"int order_num","default":null}]},{"name":"SetFailState","docStart":11422,"docEnd":12145,"docs":{"brief":"Causes the plugin to enter a failed state.  An error will be thrown and\nthe plugin will be paused until it is unloaded or reloaded.\n\nFor backwards compatibility, if no extra arguments are passed, no\nformatting is applied.  If one or more additional arguments is passed,\nthe string is formatted using Format().  If any errors are encountered\nduring formatting, both the format specifier string and an additional\nerror message are written.\n\nThis function does not return, and no further code in the plugin is\nexecuted.","tags":[{"tag":"","text":"Causes the plugin to enter a failed state.  An error will be thrown and\nthe plugin will be paused until it is unloaded or reloaded.\n\nFor backwards compatibility, if no extra arguments are passed, no\nformatting is applied.  If one or more additional arguments is passed,\nthe string is formatted using Format().  If any errors are encountered\nduring formatting, both the format specifier string and an additional\nerror message are written.\n\nThis function does not return, and no further code in the plugin is\nexecuted."},{"tag":"param:string","text":"Format specifier string."},{"tag":"param:...","text":"Formatting arguments."},{"tag":"error","text":"Always throws SP_ERROR_ABORT."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"string","decl":"const char[] string","default":null},{"type":"any...","name":"","decl":"any... ","default":null}]},{"name":"ThrowError","docStart":12206,"docEnd":12464,"docs":{"brief":"Aborts the current callback and throws an error.  This function\ndoes not return in that no code is executed following it.","tags":[{"tag":"","text":"Aborts the current callback and throws an error.  This function\ndoes not return in that no code is executed following it."},{"tag":"param:fmt","text":"String format."},{"tag":"param:...","text":"Format arguments."},{"tag":"error","text":"Always!"}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"fmt","decl":"const char[] fmt","default":null},{"type":"any...","name":"","decl":"any... ","default":null}]},{"name":"LogStackTrace","docStart":12520,"docEnd":12795,"docs":{"brief":"Logs a stack trace from the current function call. Code\nexecution continues after the call","tags":[{"tag":"","text":"Logs a stack trace from the current function call. Code\nexecution continues after the call"},{"tag":"param:fmt","text":"Format string to send with the stack trace."},{"tag":"param:...","text":"Format arguments."},{"tag":"error","text":"Always logs a stack trace."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"fmt","decl":"const char[] fmt","default":null},{"type":"any...","name":"","decl":"any... ","default":null}]},{"name":"GetTime","docStart":12854,"docEnd":13064,"docs":{"brief":"Gets the system time as a unix timestamp.","tags":[{"tag":"","text":"Gets the system time as a unix timestamp."},{"tag":"param:bigStamp","text":"Optional array to store the 64bit timestamp in."},{"tag":"return","text":"32bit timestamp (number of seconds since unix epoch)."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"bigStamp[2]","decl":"int bigStamp[2]","default":"{ 00,  }"}]},{"name":"FormatTime","docStart":13112,"docEnd":13868,"docs":{"brief":"Produces a date and/or time string value for a timestamp.\n\nSee this URL for valid parameters:\nhttp://cplusplus.com/reference/clibrary/ctime/strftime.html\n\nNote that available parameters depends on support from your operating system.\nIn particular, ones highlighted in yellow on that page are not currently\navailable on Windows and should be avoided for portable plugins.","tags":[{"tag":"","text":"Produces a date and/or time string value for a timestamp.\n\nSee this URL for valid parameters:\nhttp://cplusplus.com/reference/clibrary/ctime/strftime.html\n\nNote that available parameters depends on support from your operating system.\nIn particular, ones highlighted in yellow on that page are not currently\navailable on Windows and should be avoided for portable plugins."},{"tag":"param:buffer","text":"Destination string buffer."},{"tag":"param:maxlength","text":"Maximum length of output string buffer."},{"tag":"param:format","text":"Formatting rules (passing NULL_STRING will use the rules defined in sm_datetime_format)."},{"tag":"param:stamp","text":"Optional time stamp."},{"tag":"error","text":"Buffer too small or invalid time format."}]},"kind":"native","returnType":"void","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"maxlength","decl":"int maxlength","default":null},{"type":"const char[]","name":"format","decl":"const char[] format","default":null},{"type":"int","name":"stamp","decl":"int stamp","default":"-1"}]},{"name":"LoadGameConfigFile","docStart":13962,"docEnd":14269,"docs":{"brief":"Loads a game config file.","tags":[{"tag":"","text":"Loads a game config file."},{"tag":"param:file","text":"File to load.  The path must be relative to the 'gamedata' folder under the config folder\nand the extension should be omitted."},{"tag":"return","text":"A handle to the game config file or INVALID_HANDLE on failure."}]},"kind":"native","returnType":"GameData","arguments":[{"type":"const char[]","name":"file","decl":"const char[] file","default":null}]},{"name":"GameConfGetOffset","docStart":14329,"docEnd":14535,"docs":{"brief":"Returns an offset value.","tags":[{"tag":"","text":"Returns an offset value."},{"tag":"param:gc","text":"Game config handle."},{"tag":"param:key","text":"Key to retrieve from the offset section."},{"tag":"return","text":"An offset, or -1 on failure."}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"gc","decl":"Handle gc","default":null},{"type":"const char[]","name":"key","decl":"const char[] key","default":null}]},{"name":"GameConfGetKeyValue","docStart":14599,"docEnd":14953,"docs":{"brief":"Gets the value of a key from the \"Keys\" section.","tags":[{"tag":"","text":"Gets the value of a key from the \"Keys\" section."},{"tag":"param:gc","text":"Game config handle."},{"tag":"param:key","text":"Key to retrieve from the Keys section."},{"tag":"param:buffer","text":"Destination string buffer."},{"tag":"param:maxlen","text":"Maximum length of output string buffer."},{"tag":"return","text":"True if key existed, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"gc","decl":"Handle gc","default":null},{"type":"const char[]","name":"key","decl":"const char[] key","default":null},{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"maxlen","decl":"int maxlen","default":null}]},{"name":"GameConfGetAddress","docStart":15047,"docEnd":15373,"docs":{"brief":"Finds an address calculation in a GameConfig file,\nperforms LoadFromAddress on it as appropriate, then returns the final address.","tags":[{"tag":"","text":"Finds an address calculation in a GameConfig file,\nperforms LoadFromAddress on it as appropriate, then returns the final address."},{"tag":"param:gameconf","text":"Game config handle."},{"tag":"param:name","text":"Name of the property to find."},{"tag":"return","text":"An address calculated on success, or 0 on failure."}]},"kind":"native","returnType":"Address","arguments":[{"type":"Handle","name":"gameconf","decl":"Handle gameconf","default":null},{"type":"const char[]","name":"name","decl":"const char[] name","default":null}]},{"name":"GetSysTickCount","docStart":15449,"docEnd":15680,"docs":{"brief":"Returns the operating system's \"tick count,\" which is a number of\nmilliseconds since the operating system loaded.  This can be used\nfor basic benchmarks.","tags":[{"tag":"","text":"Returns the operating system's \"tick count,\" which is a number of\nmilliseconds since the operating system loaded.  This can be used\nfor basic benchmarks."},{"tag":"return","text":"Tick count in milliseconds."}]},"kind":"native","returnType":"int","arguments":[]},{"name":"AutoExecConfig","docStart":15715,"docEnd":16404,"docs":{"brief":"Specifies that the given config file should be executed after plugin load.\nOnConfigsExecuted() will not be called until the config file has executed,\nbut it will be called if the execution fails.","tags":[{"tag":"","text":"Specifies that the given config file should be executed after plugin load.\nOnConfigsExecuted() will not be called until the config file has executed,\nbut it will be called if the execution fails."},{"tag":"param:autoCreate","text":"If true, and the config file does not exist, such a config\nfile will be automatically created and populated with\ninformation from the plugin's registered cvars."},{"tag":"param:name","text":"Name of the config file, excluding the .cfg extension.\nIf empty, <plugin.filename.cfg> is assumed."},{"tag":"param:folder","text":"Folder under cfg/ to use.  By default this is \"sourcemod.\""}]},"kind":"native","returnType":"void","arguments":[{"type":"bool","name":"autoCreate","decl":"bool autoCreate","default":"true"},{"type":"const char[]","name":"name","decl":"const char[] name","default":"\"\""},{"type":"const char[]","name":"folder","decl":"const char[] folder","default":"\"sourcemod\""}]},{"name":"RegPluginLibrary","docStart":16514,"docEnd":16648,"docs":{"brief":"Registers a library name for identifying as a dependency to\nother plugins.","tags":[{"tag":"","text":"Registers a library name for identifying as a dependency to\nother plugins."},{"tag":"param:name","text":"Library name."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name","default":null}]},{"name":"LibraryExists","docStart":16702,"docEnd":17090,"docs":{"brief":"Returns whether a library exists.  This function should be considered\nexpensive; it should only be called on plugin to determine availability\nof resources.  Use OnLibraryAdded()/OnLibraryRemoved() to detect changes\nin optional resources.","tags":[{"tag":"","text":"Returns whether a library exists.  This function should be considered\nexpensive; it should only be called on plugin to determine availability\nof resources.  Use OnLibraryAdded()/OnLibraryRemoved() to detect changes\nin optional resources."},{"tag":"param:name","text":"Library name of a plugin or extension."},{"tag":"return","text":"True if exists, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name","default":null}]},{"name":"GetExtensionFileStatus","docStart":17141,"docEnd":17670,"docs":{"brief":"Returns the status of an extension, by filename.","tags":[{"tag":"","text":"Returns the status of an extension, by filename."},{"tag":"param:name","text":"Extension name (like \"sdktools.ext\")."},{"tag":"param:error","text":"Optional error message buffer."},{"tag":"param:maxlength","text":"Length of optional error message buffer."},{"tag":"return","text":"-2 if the extension was not found.\n-1 if the extension was found but failed to load.\n0 if the extension loaded but reported an error.\n1 if the extension is running without error."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name","default":null},{"type":"char[]","name":"error","decl":"char[] error","default":"\"\""},{"type":"int","name":"maxlength","decl":"int maxlength","default":"0"}]},{"name":"OnLibraryAdded","docStart":17763,"docEnd":17991,"docs":{"brief":"Called after a library is added that the current plugin references\noptionally. A library is either a plugin name or extension name, as\nexposed via its include file.","tags":[{"tag":"","text":"Called after a library is added that the current plugin references\noptionally. A library is either a plugin name or extension name, as\nexposed via its include file."},{"tag":"param:name","text":"Library name."}]},"kind":"forward","returnType":"void","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name","default":null}]},{"name":"OnLibraryRemoved","docStart":18044,"docEnd":18282,"docs":{"brief":"Called right before a library is removed that the current plugin references\noptionally.  A library is either a plugin name or extension name, as\nexposed via its include file.","tags":[{"tag":"","text":"Called right before a library is removed that the current plugin references\noptionally.  A library is either a plugin name or extension name, as\nexposed via its include file."},{"tag":"param:name","text":"Library name."}]},"kind":"forward","returnType":"void","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name","default":null}]},{"name":"ReadMapList","docStart":18654,"docEnd":21817,"docs":{"brief":"Loads a map list to an ADT Array.\n\nA map list is a list of maps from a file.  SourceMod allows easy configuration of\nmaplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given a\nname and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection\n(for example, \"rtv\" => \"default\").  This native will read a map list entry,\ncache the file, and return the list of maps it holds.\n\nSerial change numbers are used to identify if a map list has changed.  Thus, if\nyou pass a serial change number and it's equal to what SourceMod currently knows\nabout the map list, then SourceMod won't re-parse the file.\n\nIf the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), they\nare automatically sorted in alphabetical, ascending order.\n\nArrays created by this function are temporary and must be freed via CloseHandle().\nModifying arrays created by this function will not affect future return values or\nor the contents of arrays returned to other plugins.","tags":[{"tag":"","text":"Loads a map list to an ADT Array.\n\nA map list is a list of maps from a file.  SourceMod allows easy configuration of\nmaplists through addons/sourcemod/configs/maplists.cfg.  Each entry is given a\nname and a file (for example, \"rtv\" => \"rtv.cfg\"), or a name and a redirection\n(for example, \"rtv\" => \"default\").  This native will read a map list entry,\ncache the file, and return the list of maps it holds.\n\nSerial change numbers are used to identify if a map list has changed.  Thus, if\nyou pass a serial change number and it's equal to what SourceMod currently knows\nabout the map list, then SourceMod won't re-parse the file.\n\nIf the maps end up being read from the maps folder (MAPLIST_FLAG_MAPSFOLDER), they\nare automatically sorted in alphabetical, ascending order.\n\nArrays created by this function are temporary and must be freed via CloseHandle().\nModifying arrays created by this function will not affect future return values or\nor the contents of arrays returned to other plugins."},{"tag":"param:array","text":"Array to store the map list.  If INVALID_HANDLE, a new blank\narray will be created.  The blocksize should be at least 16;\notherwise results may be truncated.  Items are added to the array\nas strings.  The array is never checked for duplicates, and it is\nnot read beforehand.  Only the serial number is used to detect\nchanges."},{"tag":"param:serial","text":"Serial number to identify last known map list change.  If -1, the\nthe value will not be checked.  If the map list has since changed,\nthe serial is updated (even if -1 was passed).  If there is an error\nfinding a valid maplist, then the serial is set to -1."},{"tag":"param:str","text":"Config name, or \"default\" for the default map list.  Config names\nshould be somewhat descriptive.  For example, the admin menu uses\na config name of \"admin menu\".  The list names can be configured\nby users in addons/sourcemod/configs/maplists.cfg."},{"tag":"param:flags","text":"MAPLIST_FLAG flags."},{"tag":"return","text":"On failure:\nINVALID_HANDLE is returned, the serial is set to -1, and the input\narray (if any) is left unchanged.\nOn no change:\nINVALID_HANDLE is returned, the serial is unchanged, and the input\narray (if any) is left unchanged.\nOn success:\nA valid array Handle is returned, containing at least one map string.\nIf an array was passed, the return value is equal to the passed Array\nHandle.  If the passed array was not cleared, it will have grown by at\nleast one item.  The serial number is updated to a positive number."},{"tag":"error","text":"Invalid array Handle that is not INVALID_HANDLE."}]},"kind":"native","returnType":"Handle","arguments":[{"type":"Handle","name":"array","decl":"Handle array","default":"INVALID_HANDLE"},{"type":"int&","name":"serial","decl":"int& serial","default":"-1"},{"type":"const char[]","name":"str","decl":"const char[] str","default":"\"default\""},{"type":"int","name":"flags","decl":"int flags","default":"1 << 1"}]},{"name":"SetMapListCompatBind","docStart":22038,"docEnd":22421,"docs":{"brief":"Makes a compatibility binding for map lists.  For example, if a function previously used\n\"clam.cfg\" for map lists, this function will insert a \"fake\" binding to \"clam.cfg\" that\nwill be overridden if it's in the maplists.cfg file.","tags":[{"tag":"","text":"Makes a compatibility binding for map lists.  For example, if a function previously used\n\"clam.cfg\" for map lists, this function will insert a \"fake\" binding to \"clam.cfg\" that\nwill be overridden if it's in the maplists.cfg file."},{"tag":"param:name","text":"Configuration name that would be used with ReadMapList()."},{"tag":"param:file","text":"Default file to use."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name","default":null},{"type":"const char[]","name":"file","decl":"const char[] file","default":null}]},{"name":"OnClientFloodCheck","docStart":22498,"docEnd":22907,"docs":{"brief":"Called when a client has sent chat text.  This must return either true or\nfalse to indicate that a client is or is not spamming the server.\n\nThe return value is a hint only.  Core or another plugin may decide\notherwise.","tags":[{"tag":"","text":"Called when a client has sent chat text.  This must return either true or\nfalse to indicate that a client is or is not spamming the server.\n\nThe return value is a hint only.  Core or another plugin may decide\notherwise."},{"tag":"param:client","text":"Client index.  The server (0) will never be passed."},{"tag":"return","text":"True if client is spamming the server, false otherwise."}]},"kind":"forward","returnType":"bool","arguments":[{"type":"int","name":"client","decl":"int client","default":null}]},{"name":"OnClientFloodResult","docStart":22957,"docEnd":23442,"docs":{"brief":"Called after a client's flood check has been computed.  This can be used\nby antiflood algorithms to decay/increase flooding weights.\n\nSince the result from \"OnClientFloodCheck\" isn't guaranteed to be the\nfinal result, it is generally a good idea to use this to play with other\nalgorithms nicely.","tags":[{"tag":"","text":"Called after a client's flood check has been computed.  This can be used\nby antiflood algorithms to decay/increase flooding weights.\n\nSince the result from \"OnClientFloodCheck\" isn't guaranteed to be the\nfinal result, it is generally a good idea to use this to play with other\nalgorithms nicely."},{"tag":"param:client","text":"Client index.  The server (0) will never be passed."},{"tag":"param:blocked","text":"True if client flooded last \"say\", false otherwise."}]},"kind":"forward","returnType":"void","arguments":[{"type":"int","name":"client","decl":"int client","default":null},{"type":"bool","name":"blocked","decl":"bool blocked","default":null}]},{"name":"CanTestFeatures","docStart":24285,"docEnd":24600,"docs":{"brief":"Returns whether \"GetFeatureStatus\" will work. Using this native\nor this function will not cause SourceMod to fail loading on older versions,\nhowever, GetFeatureStatus will only work if this function returns true.","tags":[{"tag":"","text":"Returns whether \"GetFeatureStatus\" will work. Using this native\nor this function will not cause SourceMod to fail loading on older versions,\nhowever, GetFeatureStatus will only work if this function returns true."},{"tag":"return","text":"True if GetFeatureStatus will work, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[]},{"name":"GetFeatureStatus","docStart":24687,"docEnd":24889,"docs":{"brief":"Returns whether a feature exists, and if so, whether it is usable.","tags":[{"tag":"","text":"Returns whether a feature exists, and if so, whether it is usable."},{"tag":"param:type","text":"Feature type."},{"tag":"param:name","text":"Feature name."},{"tag":"return","text":"Feature status."}]},"kind":"native","returnType":"FeatureStatus","arguments":[{"type":"FeatureType","name":"type","decl":"FeatureType type","default":null},{"type":"const char[]","name":"name","decl":"const char[] name","default":null}]},{"name":"RequireFeature","docStart":24970,"docEnd":25308,"docs":{"brief":"Requires that a given feature is available. If it is not, SetFailState()\nis called with the given message.","tags":[{"tag":"","text":"Requires that a given feature is available. If it is not, SetFailState()\nis called with the given message."},{"tag":"param:type","text":"Feature type."},{"tag":"param:name","text":"Feature name."},{"tag":"param:fmt","text":"Message format string, or empty to use default."},{"tag":"param:...","text":"Message format parameters, if any."}]},"kind":"native","returnType":"void","arguments":[{"type":"FeatureType","name":"type","decl":"FeatureType type","default":null},{"type":"const char[]","name":"name","decl":"const char[] name","default":null},{"type":"const char[]","name":"fmt","decl":"const char[] fmt","default":"\"\""},{"type":"any...","name":"","decl":"any... ","default":null}]},{"name":"LoadFromAddress","docStart":25727,"docEnd":25963,"docs":{"brief":"Load up to 4 bytes from a memory address.","tags":[{"tag":"","text":"Load up to 4 bytes from a memory address."},{"tag":"param:addr","text":"Address to a memory location."},{"tag":"param:size","text":"How many bytes should be read."},{"tag":"return","text":"The value that is stored at that address."}]},"kind":"native","returnType":"int","arguments":[{"type":"Address","name":"addr","decl":"Address addr","default":null},{"type":"NumberType","name":"size","decl":"NumberType size","default":null}]},{"name":"StoreToAddress","docStart":26027,"docEnd":26254,"docs":{"brief":"Store up to 4 bytes to a memory address.","tags":[{"tag":"","text":"Store up to 4 bytes to a memory address."},{"tag":"param:addr","text":"Address to a memory location."},{"tag":"param:data","text":"Value to store at the address."},{"tag":"param:size","text":"How many bytes should be written."}]},"kind":"native","returnType":"void","arguments":[{"type":"Address","name":"addr","decl":"Address addr","default":null},{"type":"int","name":"data","decl":"int data","default":null},{"type":"NumberType","name":"size","decl":"NumberType size","default":null}]}],"methodmaps":[{"name":"GameData","docStart":0,"docEnd":0,"docs":null,"parent":"Handle","methods":[{"name":"GameData","docStart":2853,"docEnd":3144,"docs":{"brief":"Loads a game config file.","tags":[{"tag":"","text":"Loads a game config file."},{"tag":"param:file","text":"File to load.  The path must be relative to the 'gamedata' folder under the config folder\nand the extension should be omitted."},{"tag":"return","text":"A handle to the game config file or null on failure."}]},"kind":"native","returnType":"GameData","arguments":[{"type":"const char[]","name":"file","decl":"const char[] file","default":null}]},{"name":"GetOffset","docStart":3194,"docEnd":3348,"docs":{"brief":"Returns an offset value.","tags":[{"tag":"","text":"Returns an offset value."},{"tag":"param:key","text":"Key to retrieve from the offset section."},{"tag":"return","text":"An offset, or -1 on failure."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"key","decl":"const char[] key","default":null}]},{"name":"GetKeyValue","docStart":3402,"docEnd":3706,"docs":{"brief":"Gets the value of a key from the \"Keys\" section.","tags":[{"tag":"","text":"Gets the value of a key from the \"Keys\" section."},{"tag":"param:key","text":"Key to retrieve from the Keys section."},{"tag":"param:buffer","text":"Destination string buffer."},{"tag":"param:maxlen","text":"Maximum length of output string buffer."},{"tag":"return","text":"True if key existed, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"const char[]","name":"key","decl":"const char[] key","default":null},{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"maxlen","decl":"int maxlen","default":null}]},{"name":"GetAddress","docStart":3790,"docEnd":4065,"docs":{"brief":"Finds an address calculation in a GameConfig file,\nperforms LoadFromAddress on it as appropriate, then returns the final address.","tags":[{"tag":"","text":"Finds an address calculation in a GameConfig file,\nperforms LoadFromAddress on it as appropriate, then returns the final address."},{"tag":"param:name","text":"Name of the property to find."},{"tag":"return","text":"An address calculated on success, or 0 on failure."}]},"kind":"native","returnType":"Address","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name","default":null}]}],"properties":[]},{"name":"FrameIterator","docStart":0,"docEnd":0,"docs":null,"parent":"Handle","methods":[{"name":"FrameIterator","docStart":26365,"docEnd":26487,"docs":{"brief":"Creates a stack frame iterator to build your own stack traces.","tags":[{"tag":"","text":"Creates a stack frame iterator to build your own stack traces."},{"tag":"return","text":"New handle to a FrameIterator."}]},"kind":"native","returnType":"FrameIterator","arguments":[]},{"name":"Next","docStart":26525,"docEnd":26722,"docs":{"brief":"Advances the iterator to the next stack frame.","tags":[{"tag":"","text":"Advances the iterator to the next stack frame."},{"tag":"return","text":"True if another frame was fetched and data can be successfully read."},{"tag":"error","text":"No next element exception."}]},"kind":"native","returnType":"bool","arguments":[]},{"name":"Reset","docStart":26756,"docEnd":26810,"docs":{"brief":"Resets the iterator back to it's starting position.","tags":[{"tag":"","text":"Resets the iterator back to it's starting position."}]},"kind":"native","returnType":"void","arguments":[]},{"name":"GetFunctionName","docStart":26962,"docEnd":27107,"docs":{"brief":"Gets the name of the current function in the call stack.","tags":[{"tag":"","text":"Gets the name of the current function in the call stack."},{"tag":"param:buffer","text":"Buffer to copy to."},{"tag":"param:maxlen","text":"Max size of the buffer."}]},"kind":"native","returnType":"void","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"maxlen","decl":"int maxlen","default":null}]},{"name":"GetFilePath","docStart":27177,"docEnd":27323,"docs":{"brief":"Gets the file path to the current call in the call stack.","tags":[{"tag":"","text":"Gets the file path to the current call in the call stack."},{"tag":"param:buffer","text":"Buffer to copy to."},{"tag":"param:maxlen","text":"Max size of the buffer."}]},"kind":"native","returnType":"void","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"maxlen","decl":"int maxlen","default":null}]}],"properties":[{"name":"LineNumber","docStart":26845,"docEnd":26901,"docs":{"brief":"Returns the line number of the current function call.","tags":[{"tag":"","text":"Returns the line number of the current function call."}]},"type":"int","getter":true,"setter":false}]}],"enumstructs":[{"name":"Plugin","docStart":1643,"docEnd":1682,"docs":{"brief":"Plugin public information.","tags":[{"tag":"","text":"Plugin public information."}]},"methods":[],"fields":[{"name":"name","docStart":1738,"docEnd":1757,"docs":{"brief":"Plugin Name","tags":[{"tag":"","text":"Plugin Name"}]},"type":"const char[]"},{"name":"description","docStart":1795,"docEnd":1821,"docs":{"brief":"Plugin Description","tags":[{"tag":"","text":"Plugin Description"}]},"type":"const char[]"},{"name":"author","docStart":1859,"docEnd":1880,"docs":{"brief":"Plugin Author","tags":[{"tag":"","text":"Plugin Author"}]},"type":"const char[]"},{"name":"version","docStart":1918,"docEnd":1940,"docs":{"brief":"Plugin Version","tags":[{"tag":"","text":"Plugin Version"}]},"type":"const char[]"},{"name":"url","docStart":1978,"docEnd":1996,"docs":{"brief":"Plugin URL","tags":[{"tag":"","text":"Plugin URL"}]},"type":"const char[]"}]}],"constants":[],"enums":[{"name":"APLRes","docStart":0,"docEnd":0,"docs":null,"entries":[{"name":"APLRes_Success","docStart":2627,"docEnd":2653,"docs":{"brief":"Plugin should load","tags":[{"tag":"","text":"Plugin should load"}]},"value":"0"},{"name":"APLRes_Failure","docStart":2680,"docEnd":2737,"docs":{"brief":"Plugin shouldn't load and should display an error","tags":[{"tag":"","text":"Plugin shouldn't load and should display an error"}]},"value":null},{"name":"APLRes_SilentFailure","docStart":2764,"docEnd":2812,"docs":{"brief":"Plugin shouldn't load but do so silently","tags":[{"tag":"","text":"Plugin shouldn't load but do so silently"}]},"value":null}]},{"name":"FeatureType","docStart":23507,"docEnd":23534,"docs":{"brief":"Feature types.","tags":[{"tag":"","text":"Feature types."}]},"entries":[{"name":"FeatureType_Native","docStart":23558,"docEnd":23596,"docs":{"brief":"A native function call.","tags":[{"tag":"","text":"A native function call."}]},"value":null},{"name":"FeatureType_Capability","docStart":23623,"docEnd":23971,"docs":{"brief":"A named capability. This is distinctly different from checking for a\nnative, because the underlying functionality could be enabled on-demand\nto improve loading time. Thus a native may appear to exist, but it might\nbe part of a set of features that are not compatible with the current game\nor version of SourceMod.","tags":[{"tag":"","text":"A named capability. This is distinctly different from checking for a\nnative, because the underlying functionality could be enabled on-demand\nto improve loading time. Thus a native may appear to exist, but it might\nbe part of a set of features that are not compatible with the current game\nor version of SourceMod."}]},"value":null}]},{"name":"FeatureStatus","docStart":24004,"docEnd":24034,"docs":{"brief":"Feature statuses.","tags":[{"tag":"","text":"Feature statuses."}]},"entries":[{"name":"FeatureStatus_Available","docStart":24060,"docEnd":24104,"docs":{"brief":"Feature is available for use.","tags":[{"tag":"","text":"Feature is available for use."}]},"value":null},{"name":"FeatureStatus_Unavailable","docStart":24136,"docEnd":24176,"docs":{"brief":"Feature is not available.","tags":[{"tag":"","text":"Feature is not available."}]},"value":null},{"name":"FeatureStatus_Unknown","docStart":24210,"docEnd":24253,"docs":{"brief":"Feature is not known at all.","tags":[{"tag":"","text":"Feature is not known at all."}]},"value":null}]},{"name":"NumberType","docStart":25436,"docEnd":25516,"docs":{"brief":"Represents how many bytes we can read from an address with one load","tags":[{"tag":"","text":"Represents how many bytes we can read from an address with one load"}]},"entries":[{"name":"NumberType_Int8","docStart":0,"docEnd":0,"docs":null,"value":null},{"name":"NumberType_Int16","docStart":0,"docEnd":0,"docs":null,"value":null},{"name":"NumberType_Int32","docStart":0,"docEnd":0,"docs":null,"value":null}]},{"name":"Address","docStart":0,"docEnd":0,"docs":null,"entries":[{"name":"Address_Null","docStart":25663,"docEnd":25719,"docs":{"brief":"a typical invalid result when an address lookup fails","tags":[{"tag":"","text":"a typical invalid result when an address lookup fails"}]},"value":"0"}]}],"typesets":[],"typedefs":[]}