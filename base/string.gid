{"functions":[{"name":"strlen","docStart":1899,"docEnd":2064,"docs":{"brief":"Calculates the length of a string.","tags":[{"tag":"","text":"Calculates the length of a string."},{"tag":"param:str","text":"String to check."},{"tag":"return","text":"Number of valid character bytes in the string."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"str","decl":"const char[] str","default":null}]},{"name":"StrContains","docStart":2106,"docEnd":2584,"docs":{"brief":"Tests whether a string is found inside another string.","tags":[{"tag":"","text":"Tests whether a string is found inside another string."},{"tag":"param:str","text":"String to search in."},{"tag":"param:substr","text":"Substring to find inside the original string."},{"tag":"param:caseSensitive","text":"If true (default), search is case sensitive.\nIf false, search is case insensitive."},{"tag":"return","text":"-1 on failure (no match found). Any other value\nindicates a position in the string where the match starts."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"str","decl":"const char[] str","default":null},{"type":"const char[]","name":"substr","decl":"const char[] substr","default":null},{"type":"bool","name":"caseSensitive","decl":"bool caseSensitive","default":"true"}]},{"name":"strcmp","docStart":2677,"docEnd":3094,"docs":{"brief":"Compares two strings lexographically.","tags":[{"tag":"","text":"Compares two strings lexographically."},{"tag":"param:str1","text":"First string (left)."},{"tag":"param:str2","text":"Second string (right)."},{"tag":"param:caseSensitive","text":"If true (default), comparison is case sensitive.\nIf false, comparison is case insensitive."},{"tag":"return","text":"-1 if str1 < str2\n0 if str1 == str2\n1 if str1 > str2"}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"str1","decl":"const char[] str1","default":null},{"type":"const char[]","name":"str2","decl":"const char[] str2","default":null},{"type":"bool","name":"caseSensitive","decl":"bool caseSensitive","default":"true"}]},{"name":"strncmp","docStart":3181,"docEnd":3662,"docs":{"brief":"Compares two strings parts lexographically.","tags":[{"tag":"","text":"Compares two strings parts lexographically."},{"tag":"param:str1","text":"First string (left)."},{"tag":"param:str2","text":"Second string (right)."},{"tag":"param:num","text":"Number of characters to compare."},{"tag":"param:caseSensitive","text":"If true (default), comparison is case sensitive.\nIf false, comparison is case insensitive."},{"tag":"return","text":"-1 if str1 < str2\n0 if str1 == str2\n1 if str1 > str2"}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"str1","decl":"const char[] str1","default":null},{"type":"const char[]","name":"str2","decl":"const char[] str2","default":null},{"type":"int","name":"num","decl":"int num","default":null},{"type":"bool","name":"caseSensitive","decl":"bool caseSensitive","default":"true"}]},{"name":"StrCompare","docStart":0,"docEnd":0,"docs":null,"kind":"stock","returnType":"int","arguments":[{"type":"const char[]","name":"str1","decl":"const char[] str1","default":null},{"type":"const char[]","name":"str2","decl":"const char[] str2","default":null},{"type":"bool","name":"caseSensitive","decl":"bool caseSensitive","default":"true"}]},{"name":"StrEqual","docStart":4048,"docEnd":4395,"docs":{"brief":"Returns whether two strings are equal.","tags":[{"tag":"","text":"Returns whether two strings are equal."},{"tag":"param:str1","text":"First string (left)."},{"tag":"param:str2","text":"Second string (right)."},{"tag":"param:caseSensitive","text":"If true (default), comparison is case sensitive.\nIf false, comparison is case insensitive."},{"tag":"return","text":"True if equal, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"str1","decl":"const char[] str1","default":null},{"type":"const char[]","name":"str2","decl":"const char[] str2","default":null},{"type":"bool","name":"caseSensitive","decl":"bool caseSensitive","default":"true"}]},{"name":"strcopy","docStart":4540,"docEnd":4967,"docs":{"brief":"Copies one string to another string.","tags":[{"tag":"","text":"Copies one string to another string."},{"tag":"note","text":"If the destination buffer is too small to hold the source string, the\ndestination will be truncated."},{"tag":"param:dest","text":"Destination string buffer to copy to."},{"tag":"param:destLen","text":"Destination buffer length (includes null terminator)."},{"tag":"param:source","text":"Source string buffer to copy from."},{"tag":"return","text":"Number of cells written."}]},"kind":"native","returnType":"int","arguments":[{"type":"char[]","name":"dest","decl":"char[] dest","default":null},{"type":"int","name":"destLen","decl":"int destLen","default":null},{"type":"const char[]","name":"source","decl":"const char[] source","default":null}]},{"name":"StrCopy","docStart":0,"docEnd":0,"docs":null,"kind":"stock","returnType":"int","arguments":[{"type":"char[]","name":"dest","decl":"char[] dest","default":null},{"type":"int","name":"destLen","decl":"int destLen","default":null},{"type":"const char[]","name":"source","decl":"const char[] source","default":null}]},{"name":"Format","docStart":5298,"docEnd":5665,"docs":{"brief":"Formats a string according to the SourceMod format rules (see documentation).","tags":[{"tag":"","text":"Formats a string according to the SourceMod format rules (see documentation)."},{"tag":"param:buffer","text":"Destination string buffer."},{"tag":"param:maxlength","text":"Maximum length of output string buffer."},{"tag":"param:format","text":"Formatting rules."},{"tag":"param:...","text":"Variable number of format parameters."},{"tag":"return","text":"Number of cells written."}]},"kind":"native","returnType":"int","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"maxlength","decl":"int maxlength","default":null},{"type":"const char[]","name":"format","decl":"const char[] format","default":null},{"type":"any...","name":"...","decl":"any... ...","default":null}]},{"name":"FormatEx","docStart":5749,"docEnd":6323,"docs":{"brief":"Formats a string according to the SourceMod format rules (see documentation).","tags":[{"tag":"","text":"Formats a string according to the SourceMod format rules (see documentation)."},{"tag":"note","text":"This is the same as Format(), except none of the input buffers can\noverlap the same memory as the output buffer.  Since this security\ncheck is removed, it is slightly faster."},{"tag":"param:buffer","text":"Destination string buffer."},{"tag":"param:maxlength","text":"Maximum length of output string buffer."},{"tag":"param:format","text":"Formatting rules."},{"tag":"param:...","text":"Variable number of format parameters."},{"tag":"return","text":"Number of cells written."}]},"kind":"native","returnType":"int","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"maxlength","decl":"int maxlength","default":null},{"type":"const char[]","name":"format","decl":"const char[] format","default":null},{"type":"any...","name":"...","decl":"any... ...","default":null}]},{"name":"VFormat","docStart":6409,"docEnd":7052,"docs":{"brief":"Formats a string according to the SourceMod format rules (see documentation).","tags":[{"tag":"","text":"Formats a string according to the SourceMod format rules (see documentation)."},{"tag":"note","text":"This is the same as Format(), except it grabs parameters from a\nparent parameter stack, rather than a local.  This is useful for\nimplementing your own variable argument functions."},{"tag":"param:buffer","text":"Destination string buffer."},{"tag":"param:maxlength","text":"Maximum length of output string buffer."},{"tag":"param:format","text":"Formatting rules."},{"tag":"param:varpos","text":"Argument number which contains the '...' symbol.\nNote: Arguments start at 1."},{"tag":"return","text":"Number of bytes written."}]},"kind":"native","returnType":"int","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"maxlength","decl":"int maxlength","default":null},{"type":"const char[]","name":"format","decl":"const char[] format","default":null},{"type":"int","name":"varpos","decl":"int varpos","default":null}]},{"name":"StringToInt","docStart":7140,"docEnd":7369,"docs":{"brief":"Converts a string to an integer.","tags":[{"tag":"","text":"Converts a string to an integer."},{"tag":"param:str","text":"String to convert."},{"tag":"param:nBase","text":"Numerical base to use.  10 is default."},{"tag":"return","text":"Integer conversion of string, or 0 on failure."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"str","decl":"const char[] str","default":null},{"type":"int","name":"nBase","decl":"int nBase","default":"10"}]},{"name":"StringToIntEx","docStart":7430,"docEnd":7724,"docs":{"brief":"Converts a string to an integer with some more options.","tags":[{"tag":"","text":"Converts a string to an integer with some more options."},{"tag":"param:str","text":"String to convert."},{"tag":"param:result","text":"Variable to store the result in."},{"tag":"param:nBase","text":"Numerical base to use.  10 is default."},{"tag":"return","text":"Number of characters consumed."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"str","decl":"const char[] str","default":null},{"type":"int&","name":"result","decl":"int& result","default":null},{"type":"int","name":"nBase","decl":"int nBase","default":"10"}]},{"name":"IntToString","docStart":7800,"docEnd":8064,"docs":{"brief":"Converts an integer to a string.","tags":[{"tag":"","text":"Converts an integer to a string."},{"tag":"param:num","text":"Integer to convert."},{"tag":"param:str","text":"Buffer to store string in."},{"tag":"param:maxlength","text":"Maximum length of string buffer."},{"tag":"return","text":"Number of cells written to buffer."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"num","decl":"int num","default":null},{"type":"char[]","name":"str","decl":"char[] str","default":null},{"type":"int","name":"maxlength","decl":"int maxlength","default":null}]},{"name":"StringToFloat","docStart":8129,"docEnd":8312,"docs":{"brief":"Converts a string to a floating point number.","tags":[{"tag":"","text":"Converts a string to a floating point number."},{"tag":"param:str","text":"String to convert to a float."},{"tag":"return","text":"Floating point result, or 0.0 on error."}]},"kind":"native","returnType":"float","arguments":[{"type":"const char[]","name":"str","decl":"const char[] str","default":null}]},{"name":"StringToFloatEx","docStart":8363,"docEnd":8614,"docs":{"brief":"Converts a string to a floating point number with some more options.","tags":[{"tag":"","text":"Converts a string to a floating point number with some more options."},{"tag":"param:str","text":"String to convert to a float."},{"tag":"param:result","text":"Variable to store result in."},{"tag":"return","text":"Number of characters consumed."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"str","decl":"const char[] str","default":null},{"type":"float&","name":"result","decl":"float& result","default":null}]},{"name":"FloatToString","docStart":8680,"docEnd":8971,"docs":{"brief":"Converts a floating point number to a string.","tags":[{"tag":"","text":"Converts a floating point number to a string."},{"tag":"param:num","text":"Floating point number to convert."},{"tag":"param:str","text":"Buffer to store string in."},{"tag":"param:maxlength","text":"Maximum length of string buffer."},{"tag":"return","text":"Number of cells written to buffer."}]},"kind":"native","returnType":"int","arguments":[{"type":"float","name":"num","decl":"float num","default":null},{"type":"char[]","name":"str","decl":"char[] str","default":null},{"type":"int","name":"maxlength","decl":"int maxlength","default":null}]},{"name":"BreakString","docStart":9040,"docEnd":9612,"docs":{"brief":"Finds the first \"argument\" in a string; either a set of space\nterminated characters, or a fully quoted string.  After the\nargument is found, whitespace is read until the next portion\nof the string is reached.  If nothing remains, -1 is returned.\nOtherwise, the index to the first character is returned.","tags":[{"tag":"","text":"Finds the first \"argument\" in a string; either a set of space\nterminated characters, or a fully quoted string.  After the\nargument is found, whitespace is read until the next portion\nof the string is reached.  If nothing remains, -1 is returned.\nOtherwise, the index to the first character is returned."},{"tag":"param:source","text":"Source input string."},{"tag":"param:arg","text":"Stores argument read from string."},{"tag":"param:argLen","text":"Maximum length of argument buffer."},{"tag":"return","text":"Index to next piece of string, or -1 if none."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"source","decl":"const char[] source","default":null},{"type":"char[]","name":"arg","decl":"char[] arg","default":null},{"type":"int","name":"argLen","decl":"int argLen","default":null}]},{"name":"StrBreak","docStart":0,"docEnd":0,"docs":null,"kind":"stock","returnType":"int","arguments":[{"type":"const char[]","name":"source","decl":"const char[] source","default":null},{"type":"char[]","name":"arg","decl":"char[] arg","default":null},{"type":"int","name":"argLen","decl":"int argLen","default":null}]},{"name":"TrimString","docStart":9959,"docEnd":10153,"docs":{"brief":"Removes whitespace characters from the beginning and end of a string.","tags":[{"tag":"","text":"Removes whitespace characters from the beginning and end of a string."},{"tag":"param:str","text":"The string to trim."},{"tag":"return","text":"Number of bytes written (UTF-8 safe)."}]},"kind":"native","returnType":"int","arguments":[{"type":"char[]","name":"str","decl":"char[] str","default":null}]},{"name":"SplitString","docStart":10193,"docEnd":10775,"docs":{"brief":"Returns text in a string up until a certain character sequence is reached.","tags":[{"tag":"","text":"Returns text in a string up until a certain character sequence is reached."},{"tag":"param:source","text":"Source input string."},{"tag":"param:split","text":"A string which specifies a search point to break at."},{"tag":"param:part","text":"Buffer to store string part."},{"tag":"param:partLen","text":"Maximum length of the string part buffer."},{"tag":"return","text":"-1 if no match was found; otherwise, an index into source\nmarking the first index after the searched text.  The\nindex is always relative to the start of the input string."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"source","decl":"const char[] source","default":null},{"type":"const char[]","name":"split","decl":"const char[] split","default":null},{"type":"char[]","name":"part","decl":"char[] part","default":null},{"type":"int","name":"partLen","decl":"int partLen","default":null}]},{"name":"ReplaceString","docStart":10871,"docEnd":11365,"docs":{"brief":"Given a string, replaces all occurrences of a search string with a\nreplacement string.","tags":[{"tag":"","text":"Given a string, replaces all occurrences of a search string with a\nreplacement string."},{"tag":"param:text","text":"String to perform search and replacements on."},{"tag":"param:maxlength","text":"Maximum length of the string buffer."},{"tag":"param:search","text":"String to search for."},{"tag":"param:replace","text":"String to replace the search string with."},{"tag":"param:caseSensitive","text":"If true (default), search is case sensitive."},{"tag":"return","text":"Number of replacements that were performed."}]},"kind":"native","returnType":"int","arguments":[{"type":"char[]","name":"text","decl":"char[] text","default":null},{"type":"int","name":"maxlength","decl":"int maxlength","default":null},{"type":"const char[]","name":"search","decl":"const char[] search","default":null},{"type":"const char[]","name":"replace","decl":"const char[] replace","default":null},{"type":"bool","name":"caseSensitive","decl":"bool caseSensitive","default":"true"}]},{"name":"ReplaceStringEx","docStart":11492,"docEnd":12407,"docs":{"brief":"Given a string, replaces the first occurrence of a search string with a\nreplacement string.","tags":[{"tag":"","text":"Given a string, replaces the first occurrence of a search string with a\nreplacement string."},{"tag":"param:text","text":"String to perform search and replacements on."},{"tag":"param:maxlength","text":"Maximum length of the string buffer."},{"tag":"param:search","text":"String to search for."},{"tag":"param:replace","text":"String to replace the search string with."},{"tag":"param:searchLen","text":"If higher than -1, its value will be used instead of\na strlen() call on the search parameter."},{"tag":"param:replaceLen","text":"If higher than -1, its value will be used instead of\na strlen() call on the replace parameter."},{"tag":"param:caseSensitive","text":"If true (default), search is case sensitive."},{"tag":"return","text":"Index into the buffer (relative to the start) from where\nthe last replacement ended, or -1 if no replacements were\nmade."}]},"kind":"native","returnType":"int","arguments":[{"type":"char[]","name":"text","decl":"char[] text","default":null},{"type":"int","name":"maxlength","decl":"int maxlength","default":null},{"type":"const char[]","name":"search","decl":"const char[] search","default":null},{"type":"const char[]","name":"replace","decl":"const char[] replace","default":null},{"type":"int","name":"searchLen","decl":"int searchLen","default":"-1"},{"type":"int","name":"replaceLen","decl":"int replaceLen","default":"-1"},{"type":"bool","name":"caseSensitive","decl":"bool caseSensitive","default":"true"}]},{"name":"GetCharBytes","docStart":12573,"docEnd":12857,"docs":{"brief":"Returns the number of bytes a character is using.  This is\nfor multi-byte characters (UTF-8).  For normal ASCII characters,\nthis will return 1.","tags":[{"tag":"","text":"Returns the number of bytes a character is using.  This is\nfor multi-byte characters (UTF-8).  For normal ASCII characters,\nthis will return 1."},{"tag":"param:source","text":"Source input string."},{"tag":"return","text":"Number of bytes the current character uses."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"source","decl":"const char[] source","default":null}]},{"name":"IsCharAlpha","docStart":12908,"docEnd":13167,"docs":{"brief":"Returns whether a character is an ASCII alphabet character.","tags":[{"tag":"","text":"Returns whether a character is an ASCII alphabet character."},{"tag":"note","text":"Multi-byte characters will always return false."},{"tag":"param:chr","text":"Character to test."},{"tag":"return","text":"True if character is alphabetical, otherwise false."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"chr","decl":"int chr","default":null}]},{"name":"IsCharNumeric","docStart":13206,"docEnd":13440,"docs":{"brief":"Returns whether a character is numeric.","tags":[{"tag":"","text":"Returns whether a character is numeric."},{"tag":"note","text":"Multi-byte characters will always return false."},{"tag":"param:chr","text":"Character to test."},{"tag":"return","text":"True if character is numeric, otherwise false."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"chr","decl":"int chr","default":null}]},{"name":"IsCharSpace","docStart":13481,"docEnd":13721,"docs":{"brief":"Returns whether a character is whitespace.","tags":[{"tag":"","text":"Returns whether a character is whitespace."},{"tag":"note","text":"Multi-byte characters will always return false."},{"tag":"param:chr","text":"Character to test."},{"tag":"return","text":"True if character is whitespace, otherwise false."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"chr","decl":"int chr","default":null}]},{"name":"IsCharMB","docStart":13760,"docEnd":14004,"docs":{"brief":"Returns if a character is multi-byte or not.","tags":[{"tag":"","text":"Returns if a character is multi-byte or not."},{"tag":"param:chr","text":"Character to test."},{"tag":"return","text":"0 for a normal 7-bit ASCII character,\notherwise number of bytes in multi-byte character."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"chr","decl":"int chr","default":null}]},{"name":"IsCharUpper","docStart":14039,"docEnd":14289,"docs":{"brief":"Returns whether an alphabetic character is uppercase.","tags":[{"tag":"","text":"Returns whether an alphabetic character is uppercase."},{"tag":"note","text":"Multi-byte characters will always return false."},{"tag":"param:chr","text":"Character to test."},{"tag":"return","text":"True if character is uppercase, otherwise false."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"chr","decl":"int chr","default":null}]},{"name":"IsCharLower","docStart":14328,"docEnd":14578,"docs":{"brief":"Returns whether an alphabetic character is lowercase.","tags":[{"tag":"","text":"Returns whether an alphabetic character is lowercase."},{"tag":"note","text":"Multi-byte characters will always return false."},{"tag":"param:chr","text":"Character to test."},{"tag":"return","text":"True if character is lowercase, otherwise false."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"chr","decl":"int chr","default":null}]},{"name":"StripQuotes","docStart":14617,"docEnd":15143,"docs":{"brief":"Strips a quote pair off a string if it exists.  That is, the following\nreplace rule is applied once:  ^\"(.*)\"$ -> ^\\1$\n\nNote that the leading and trailing quotes will only be removed if both\nexist.  Otherwise, the string is left unmodified.  This function should\nbe considered O(k) (all characters get shifted down).","tags":[{"tag":"","text":"Strips a quote pair off a string if it exists.  That is, the following\nreplace rule is applied once:  ^\"(.*)\"$ -> ^\\1$\n\nNote that the leading and trailing quotes will only be removed if both\nexist.  Otherwise, the string is left unmodified.  This function should\nbe considered O(k) (all characters get shifted down)."},{"tag":"param:text","text":"String to modify (in place)."},{"tag":"return","text":"True if string was modified, false if there was no\nset of quotes."}]},"kind":"native","returnType":"bool","arguments":[{"type":"char[]","name":"text","decl":"char[] text","default":null}]},{"name":"CharToUpper","docStart":15186,"docEnd":15415,"docs":{"brief":"Converts a lowercase character to its uppercase counterpart.","tags":[{"tag":"","text":"Converts a lowercase character to its uppercase counterpart."},{"tag":"param:chr","text":"Character to convert."},{"tag":"return","text":"Uppercase character on success,\nno change on failure."}]},"kind":"stock","returnType":"int","arguments":[{"type":"int","name":"chr","decl":"int chr","default":null}]},{"name":"CharToLower","docStart":15532,"docEnd":15762,"docs":{"brief":"Converts an uppercase character to its lowercase counterpart.","tags":[{"tag":"","text":"Converts an uppercase character to its lowercase counterpart."},{"tag":"param:chr","text":"Character to convert."},{"tag":"return","text":"Lowercase character on success,\nno change on failure."}]},"kind":"stock","returnType":"int","arguments":[{"type":"int","name":"chr","decl":"int chr","default":null}]},{"name":"FindCharInString","docStart":15879,"docEnd":16299,"docs":{"brief":"Finds the first occurrence of a character in a string.","tags":[{"tag":"","text":"Finds the first occurrence of a character in a string."},{"tag":"param:str","text":"String."},{"tag":"param:c","text":"Character to search for."},{"tag":"param:reverse","text":"False (default) to search forward, true to search\nbackward."},{"tag":"return","text":"The index of the first occurrence of the character\nin the string, or -1 if the character was not found."}]},"kind":"stock","returnType":"int","arguments":[{"type":"const char[]","name":"str","decl":"const char[] str","default":null},{"type":"char","name":"c","decl":"char c","default":null},{"type":"bool","name":"reverse","decl":"bool reverse","default":"false"}]},{"name":"StrCat","docStart":16654,"docEnd":16917,"docs":{"brief":"Concatenates one string onto another.","tags":[{"tag":"","text":"Concatenates one string onto another."},{"tag":"param:buffer","text":"String to append to."},{"tag":"param:maxlength","text":"Maximum length of entire buffer."},{"tag":"param:source","text":"Source string to concatenate."},{"tag":"return","text":"Number of bytes written."}]},"kind":"stock","returnType":"int","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"maxlength","decl":"int maxlength","default":null},{"type":"const char[]","name":"source","decl":"const char[] source","default":null}]},{"name":"ExplodeString","docStart":17131,"docEnd":17754,"docs":{"brief":"Breaks a string into pieces and stores each piece into an array of buffers.","tags":[{"tag":"","text":"Breaks a string into pieces and stores each piece into an array of buffers."},{"tag":"param:text","text":"The string to split."},{"tag":"param:split","text":"The string to use as a split delimiter."},{"tag":"param:buffers","text":"An array of string buffers (2D array)."},{"tag":"param:maxStrings","text":"Number of string buffers (first dimension size)."},{"tag":"param:maxStringLength","text":"Maximum length of each string buffer."},{"tag":"param:copyRemainder","text":"False (default) discard excess pieces, true to ignore\ndelimiters after last piece."},{"tag":"return","text":"Number of strings retrieved."}]},"kind":"stock","returnType":"int","arguments":[{"type":"const char[]","name":"text","decl":"const char[] text","default":null},{"type":"const char[]","name":"split","decl":"const char[] split","default":null},{"type":"char[][]","name":"buffers","decl":"char[][] buffers","default":null},{"type":"int","name":"maxStrings","decl":"int maxStrings","default":null},{"type":"int","name":"maxStringLength","decl":"int maxStringLength","default":null},{"type":"bool","name":"copyRemainder","decl":"bool copyRemainder","default":"false"}]},{"name":"ImplodeStrings","docStart":18389,"docEnd":18932,"docs":{"brief":"Joins an array of strings into one string, with a \"join\" string inserted in\nbetween each given string.  This function complements ExplodeString.","tags":[{"tag":"","text":"Joins an array of strings into one string, with a \"join\" string inserted in\nbetween each given string.  This function complements ExplodeString."},{"tag":"param:strings","text":"An array of strings."},{"tag":"param:numStrings","text":"Number of strings in the array."},{"tag":"param:join","text":"The join string to insert between each string."},{"tag":"param:buffer","text":"Output buffer to write the joined string to."},{"tag":"param:maxLength","text":"Maximum length of the output buffer."},{"tag":"return","text":"Number of bytes written to the output buffer."}]},"kind":"stock","returnType":"int","arguments":[{"type":"const char[][]","name":"strings","decl":"const char[][] strings","default":null},{"type":"int","name":"numStrings","decl":"int numStrings","default":null},{"type":"const char[]","name":"join","decl":"const char[] join","default":null},{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"maxLength","decl":"int maxLength","default":null}]}],"methodmaps":[],"enumstructs":[],"constants":[],"enums":[],"typesets":[],"typedefs":[]}