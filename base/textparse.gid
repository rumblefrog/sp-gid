{"functions":[{"name":"SMC_CreateParser","docStart":7458,"docEnd":7611,"docs":{"brief":"Creates a new SMC file format parser.  This is used to set parse hooks.","tags":[{"tag":"","text":"Creates a new SMC file format parser.  This is used to set parse hooks."},{"tag":"return","text":"A new Handle to an SMC Parse structure."}]},"kind":"native","returnType":"SMCParser","arguments":[]},{"name":"SMC_ParseFile","docStart":7653,"docEnd":8096,"docs":{"brief":"Parses an SMC file.","tags":[{"tag":"","text":"Parses an SMC file."},{"tag":"param:smc","text":"A Handle to an SMC Parse structure."},{"tag":"param:file","text":"A string containing the file path."},{"tag":"param:line","text":"An optional by reference cell to store the last line number read."},{"tag":"param:col","text":"An optional by reference cell to store the last column number read."},{"tag":"return","text":"An SMCParseError result."},{"tag":"error","text":"Invalid or corrupt Handle."}]},"kind":"native","returnType":"SMCError","arguments":[{"type":"Handle","name":"smc","decl":"Handle smc","default":null},{"type":"const char[]","name":"file","decl":"const char[] file","default":null},{"type":"int&","name":"line","decl":"int& line","default":"0"},{"type":"int&","name":"col","decl":"int& col","default":"0"}]},{"name":"SMC_GetErrorString","docStart":8188,"docEnd":8623,"docs":{"brief":"Gets an error string for an SMCError code.","tags":[{"tag":"","text":"Gets an error string for an SMCError code."},{"tag":"note","text":"SMCError_Okay returns false."},{"tag":"note","text":"SMCError_Custom (which is thrown on SMCParse_HaltFail) returns false."},{"tag":"param:error","text":"The SMCParseError code."},{"tag":"param:buffer","text":"A string buffer for the error (contents undefined on failure)."},{"tag":"param:buf_max","text":"The maximum size of the buffer."},{"tag":"return","text":"True on success, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"SMCError","name":"error","decl":"SMCError error","default":null},{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"buf_max","decl":"int buf_max","default":null}]},{"name":"SMC_SetParseStart","docStart":8704,"docEnd":8923,"docs":{"brief":"Sets the SMC_ParseStart function of a parse Handle.","tags":[{"tag":"","text":"Sets the SMC_ParseStart function of a parse Handle."},{"tag":"param:smc","text":"Handle to an SMC Parse."},{"tag":"param:func","text":"SMC_ParseStart function."},{"tag":"error","text":"Invalid or corrupt Handle."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"smc","decl":"Handle smc","default":null},{"type":"SMC_ParseStart","name":"func","decl":"SMC_ParseStart func","default":null}]},{"name":"SMC_SetParseEnd","docStart":8992,"docEnd":9198,"docs":{"brief":"Sets the SMC_ParseEnd of a parse handle.","tags":[{"tag":"","text":"Sets the SMC_ParseEnd of a parse handle."},{"tag":"param:smc","text":"Handle to an SMC Parse."},{"tag":"param:func","text":"SMC_ParseEnd function."},{"tag":"error","text":"Invalid or corrupt Handle."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"smc","decl":"Handle smc","default":null},{"type":"SMC_ParseEnd","name":"func","decl":"SMC_ParseEnd func","default":null}]},{"name":"SMC_SetReaders","docStart":9263,"docEnd":9544,"docs":{"brief":"Sets the three main reader functions.","tags":[{"tag":"","text":"Sets the three main reader functions."},{"tag":"param:smc","text":"An SMC parse Handle."},{"tag":"param:ns","text":"An SMC_NewSection function pointer."},{"tag":"param:kv","text":"An SMC_KeyValue function pointer."},{"tag":"param:es","text":"An SMC_EndSection function pointer."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"smc","decl":"Handle smc","default":null},{"type":"SMC_NewSection","name":"ns","decl":"SMC_NewSection ns","default":null},{"type":"SMC_KeyValue","name":"kv","decl":"SMC_KeyValue kv","default":null},{"type":"SMC_EndSection","name":"es","decl":"SMC_EndSection es","default":null}]},{"name":"SMC_SetRawLine","docStart":9644,"docEnd":9804,"docs":{"brief":"Sets a raw line reader on an SMC parser Handle.","tags":[{"tag":"","text":"Sets a raw line reader on an SMC parser Handle."},{"tag":"param:smc","text":"Handle to an SMC Parse."},{"tag":"param:func","text":"SMC_RawLine function."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"smc","decl":"Handle smc","default":null},{"type":"SMC_RawLine","name":"func","decl":"SMC_RawLine func","default":null}]}],"methodmaps":[{"name":"SMCParser","docStart":5364,"docEnd":5681,"docs":{"brief":"An SMCParser is a callback-driven parser for SourceMod configuration files.\nSMC files are similar to Valve KeyValues format, with two key differences:\n(1) SMC cannot handle single-item entries (that is, a key with no value).\n(2) SMC files can have multi-line comment blocks, whereas KeyValues cannot.","tags":[{"tag":"","text":"An SMCParser is a callback-driven parser for SourceMod configuration files.\nSMC files are similar to Valve KeyValues format, with two key differences:\n(1) SMC cannot handle single-item entries (that is, a key with no value).\n(2) SMC files can have multi-line comment blocks, whereas KeyValues cannot."}]},"parent":"Handle","methods":[{"name":"SMCParser","docStart":5717,"docEnd":5756,"docs":{"brief":"Create a new SMC file format parser.","tags":[{"tag":"","text":"Create a new SMC file format parser."}]},"kind":"native","returnType":"SMCParser","arguments":[]},{"name":"ParseFile","docStart":5790,"docEnd":6097,"docs":{"brief":"Parses an SMC file.","tags":[{"tag":"","text":"Parses an SMC file."},{"tag":"param:file","text":"A string containing the file path."},{"tag":"param:line","text":"An optional variable to store the last line number read."},{"tag":"param:col","text":"An optional variable to store the last column number read."},{"tag":"return","text":"An SMCParseError result."}]},"kind":"native","returnType":"SMCError","arguments":[{"type":"const char[]","name":"file","decl":"const char[] file","default":null},{"type":"int&","name":"line","decl":"int& line","default":"0"},{"type":"int&","name":"col","decl":"int& col","default":"0"}]},{"name":"GetErrorString","docStart":7052,"docEnd":7369,"docs":{"brief":"Gets an error string for an SMCError code.","tags":[{"tag":"","text":"Gets an error string for an SMCError code."},{"tag":"param:error","text":"The SMCParseError code."},{"tag":"param:buffer","text":"A string buffer for the error (contents undefined on failure)."},{"tag":"param:buf_max","text":"The maximum size of the buffer."},{"tag":"return","text":"The number of characters written to buffer."}]},"kind":"native","returnType":"void","arguments":[{"type":"SMCError","name":"error","decl":"SMCError error","default":null},{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"buf_max","decl":"int buf_max","default":null}]}],"properties":[{"name":"OnStart","docStart":6186,"docEnd":6243,"docs":{"brief":"Sets the callback for receiving SMC_ParseStart events.","tags":[{"tag":"","text":"Sets the callback for receiving SMC_ParseStart events."}]},"type":"SMC_ParseStart","getter":false,"setter":true},{"name":"OnEnd","docStart":6331,"docEnd":6386,"docs":{"brief":"Sets the callback for receiving SMC_ParseEnd events.","tags":[{"tag":"","text":"Sets the callback for receiving SMC_ParseEnd events."}]},"type":"SMC_ParseEnd","getter":false,"setter":true},{"name":"OnEnterSection","docStart":6468,"docEnd":6525,"docs":{"brief":"Sets the callback for receiving SMC_NewSection events.","tags":[{"tag":"","text":"Sets the callback for receiving SMC_NewSection events."}]},"type":"SMC_NewSection","getter":false,"setter":true},{"name":"OnLeaveSection","docStart":6620,"docEnd":6677,"docs":{"brief":"Sets the callback for receiving SMC_EndSection events.","tags":[{"tag":"","text":"Sets the callback for receiving SMC_EndSection events."}]},"type":"SMC_EndSection","getter":false,"setter":true},{"name":"OnKeyValue","docStart":6772,"docEnd":6827,"docs":{"brief":"Sets the callback for receiving SMC_KeyValue events.","tags":[{"tag":"","text":"Sets the callback for receiving SMC_KeyValue events."}]},"type":"SMC_KeyValue","getter":false,"setter":true},{"name":"OnRawLine","docStart":6914,"docEnd":6968,"docs":{"brief":"Sets the callback for receiving SMC_RawLine events.","tags":[{"tag":"","text":"Sets the callback for receiving SMC_RawLine events."}]},"type":"SMC_RawLine","getter":false,"setter":true}]}],"enumstructs":[],"constants":[],"enums":[{"name":"SMCResult","docStart":1974,"docEnd":2010,"docs":{"brief":"Parse result directive.","tags":[{"tag":"","text":"Parse result directive."}]},"entries":[{"name":"SMCParse_Continue","docStart":2060,"docEnd":2084,"docs":{"brief":"Continue parsing","tags":[{"tag":"","text":"Continue parsing"}]},"value":null},{"name":"SMCParse_Halt","docStart":2115,"docEnd":2140,"docs":{"brief":"Stop parsing here","tags":[{"tag":"","text":"Stop parsing here"}]},"value":null},{"name":"SMCParse_HaltFail","docStart":2171,"docEnd":2210,"docs":{"brief":"Stop parsing and return failure","tags":[{"tag":"","text":"Stop parsing and return failure"}]},"value":null}]},{"name":"SMCError","docStart":2218,"docEnd":2249,"docs":{"brief":"Parse error codes.","tags":[{"tag":"","text":"Parse error codes."}]},"entries":[{"name":"SMCError_Okay","docStart":2298,"docEnd":2314,"docs":{"brief":"No error","tags":[{"tag":"","text":"No error"}]},"value":"0"},{"name":"SMCError_StreamOpen","docStart":2345,"docEnd":2374,"docs":{"brief":"Stream failed to open","tags":[{"tag":"","text":"Stream failed to open"}]},"value":null},{"name":"SMCError_StreamError","docStart":2405,"docEnd":2439,"docs":{"brief":"The stream died... somehow","tags":[{"tag":"","text":"The stream died... somehow"}]},"value":null},{"name":"SMCError_Custom","docStart":2470,"docEnd":2509,"docs":{"brief":"A custom handler threw an error","tags":[{"tag":"","text":"A custom handler threw an error"}]},"value":null},{"name":"SMCError_InvalidSection1","docStart":2540,"docEnd":2607,"docs":{"brief":"A section was declared without quotes, and had extra tokens","tags":[{"tag":"","text":"A section was declared without quotes, and had extra tokens"}]},"value":null},{"name":"SMCError_InvalidSection2","docStart":2638,"docEnd":2687,"docs":{"brief":"A section was declared without any header","tags":[{"tag":"","text":"A section was declared without any header"}]},"value":null},{"name":"SMCError_InvalidSection3","docStart":2718,"docEnd":2784,"docs":{"brief":"A section ending was declared with too many unknown tokens","tags":[{"tag":"","text":"A section ending was declared with too many unknown tokens"}]},"value":null},{"name":"SMCError_InvalidSection4","docStart":2815,"docEnd":2865,"docs":{"brief":"A section ending has no matching beginning","tags":[{"tag":"","text":"A section ending has no matching beginning"}]},"value":null},{"name":"SMCError_InvalidSection5","docStart":2896,"docEnd":2946,"docs":{"brief":"A section beginning has no matching ending","tags":[{"tag":"","text":"A section beginning has no matching ending"}]},"value":null},{"name":"SMCError_InvalidTokens","docStart":2977,"docEnd":3039,"docs":{"brief":"There were too many unidentifiable strings on one line","tags":[{"tag":"","text":"There were too many unidentifiable strings on one line"}]},"value":null},{"name":"SMCError_TokenOverflow","docStart":3070,"docEnd":3105,"docs":{"brief":"The token buffer overflowed","tags":[{"tag":"","text":"The token buffer overflowed"}]},"value":null},{"name":"SMCError_InvalidProperty1","docStart":3136,"docEnd":3190,"docs":{"brief":"A property was declared outside of any section","tags":[{"tag":"","text":"A property was declared outside of any section"}]},"value":null}]}],"typesets":[],"typedefs":[{"name":"SMC_ParseStart","docStart":3198,"docEnd":3293,"docs":{"brief":"Called when parsing is started.","tags":[{"tag":"","text":"Called when parsing is started."},{"tag":"param:smc","text":"The SMC Parse Handle."}]},"type":"function void(SMCParser smc)","parsedSignature":{"returnType":"void","arguments":[{"type":"SMCParser","name":"smc","decl":"SMCParser smc","default":null}]}},{"name":"SMC_NewSection","docStart":3354,"docEnd":3721,"docs":{"brief":"Called when the parser is entering a new section or sub-section.\n\nNote: Enclosing quotes are always stripped.","tags":[{"tag":"","text":"Called when the parser is entering a new section or sub-section.\n\nNote: Enclosing quotes are always stripped."},{"tag":"param:smc","text":"The SMC Parser."},{"tag":"param:name","text":"String containing section name."},{"tag":"param:opt_quotes","text":"True if the section name was quote-enclosed in the file."},{"tag":"return","text":"An SMCResult action to take."}]},"type":"function SMCResult(SMCParser smc, const char[] name, bool opt_quotes)","parsedSignature":{"returnType":"SMCResult","arguments":[{"type":"SMCParser","name":"smc","decl":"SMCParser smc","default":null},{"type":"const char[]","name":"name","decl":"const char[] name","default":null},{"type":"bool","name":"opt_quotes","decl":"bool opt_quotes","default":null}]}},{"name":"SMC_KeyValue","docStart":3823,"docEnd":4290,"docs":{"brief":"Called when the parser finds a new key/value pair.\n\nNote: Enclosing quotes are always stripped.","tags":[{"tag":"","text":"Called when the parser finds a new key/value pair.\n\nNote: Enclosing quotes are always stripped."},{"tag":"param:smc","text":"The SMCParser."},{"tag":"param:key","text":"String containing key name."},{"tag":"param:value","text":"String containing value name."},{"tag":"param:key_quotes","text":"Whether or not the key was enclosed in quotes."},{"tag":"param:value_quotes","text":"Whether or not the value was enclosed in quotes."},{"tag":"return","text":"An SMCResult action to take."}]},"type":"function SMCResult(SMCParser smc, const char[] key, const char[] value, bool key_quotes, bool value_quotes)","parsedSignature":{"returnType":"SMCResult","arguments":[{"type":"SMCParser","name":"smc","decl":"SMCParser smc","default":null},{"type":"const char[]","name":"key","decl":"const char[] key","default":null},{"type":"const char[]","name":"value","decl":"const char[] value","default":null},{"type":"bool","name":"key_quotes","decl":"bool key_quotes","default":null},{"type":"bool","name":"value_quotes","decl":"bool value_quotes","default":null}]}},{"name":"SMC_EndSection","docStart":4428,"docEnd":4595,"docs":{"brief":"Called when the parser finds the end of the current section.","tags":[{"tag":"","text":"Called when the parser finds the end of the current section."},{"tag":"param:smc","text":"The SMCParser."},{"tag":"return","text":"An SMCResult action to take."}]},"type":"function SMCResult(SMCParser smc)","parsedSignature":{"returnType":"SMCResult","arguments":[{"type":"SMCParser","name":"smc","decl":"SMCParser smc","default":null}]}},{"name":"SMC_ParseEnd","docStart":4661,"docEnd":4883,"docs":{"brief":"Called when parsing is halted.","tags":[{"tag":"","text":"Called when parsing is halted."},{"tag":"param:smc","text":"The SMCParser."},{"tag":"param:halted","text":"True if abnormally halted, false otherwise."},{"tag":"param:failed","text":"True if parsing failed, false otherwise."}]},"type":"function void(SMCParser smc, bool halted, bool failed)","parsedSignature":{"returnType":"void","arguments":[{"type":"SMCParser","name":"smc","decl":"SMCParser smc","default":null},{"type":"bool","name":"halted","decl":"bool halted","default":null},{"type":"bool","name":"failed","decl":"bool failed","default":null}]}},{"name":"SMC_RawLine","docStart":4968,"docEnd":5270,"docs":{"brief":"Callback for whenever a new line of text is about to be parsed.","tags":[{"tag":"","text":"Callback for whenever a new line of text is about to be parsed."},{"tag":"param:smc","text":"The SMCParser."},{"tag":"param:line","text":"A string containing the raw line from the file."},{"tag":"param:lineno","text":"The line number it occurs on."},{"tag":"return","text":"An SMCResult action to take."}]},"type":"function SMCResult(SMCParser smc, const char[] line, int lineno)","parsedSignature":{"returnType":"SMCResult","arguments":[{"type":"SMCParser","name":"smc","decl":"SMCParser smc","default":null},{"type":"const char[]","name":"line","decl":"const char[] line","default":null},{"type":"int","name":"lineno","decl":"int lineno","default":null}]}}]}