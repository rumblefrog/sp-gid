{"functions":[{"name":"CreateStack","docStart":5224,"docEnd":5971,"docs":{"brief":"Creates a stack structure.  A stack is a LIFO (last in, first out)\nvector (array) of items.  It has O(1) insertion and O(1) removal.\n\nStacks have two operations: Push (adding an item) and Pop (removes\nitems in reverse-push order).\n\nThe contents of the stack are uniform; i.e. storing a string and then\nretrieving it as an integer is NOT the same as StringToInt()!\n\nThe \"blocksize\" determines how many cells each slot has; it cannot\nbe changed after creation.","tags":[{"tag":"","text":"Creates a stack structure.  A stack is a LIFO (last in, first out)\nvector (array) of items.  It has O(1) insertion and O(1) removal.\n\nStacks have two operations: Push (adding an item) and Pop (removes\nitems in reverse-push order).\n\nThe contents of the stack are uniform; i.e. storing a string and then\nretrieving it as an integer is NOT the same as StringToInt()!\n\nThe \"blocksize\" determines how many cells each slot has; it cannot\nbe changed after creation."},{"tag":"param:blocksize","text":"The number of cells each entry in the stack can\nhold.  For example, 32 cells is equivalent to:\nnew Array[X][32]"},{"tag":"return","text":"New stack Handle."}]},"kind":"native","returnType":"ArrayStack","arguments":[{"type":"int","name":"blocksize","decl":"int blocksize","default":"1"}]},{"name":"PushStackCell","docStart":6024,"docEnd":6325,"docs":{"brief":"Pushes a value onto the end of the stack, adding a new index.\n\nThis may safely be used even if the stack has a blocksize\ngreater than 1.","tags":[{"tag":"","text":"Pushes a value onto the end of the stack, adding a new index.\n\nThis may safely be used even if the stack has a blocksize\ngreater than 1."},{"tag":"param:stack","text":"Stack Handle."},{"tag":"param:value","text":"Value to push."},{"tag":"error","text":"Invalid Handle or out of memory."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack","default":null},{"type":"any","name":"value","decl":"any value","default":null}]},{"name":"PushStackString","docStart":6382,"docEnd":6624,"docs":{"brief":"Pushes a copy of a string onto the end of a stack, truncating it if it is\ntoo big.","tags":[{"tag":"","text":"Pushes a copy of a string onto the end of a stack, truncating it if it is\ntoo big."},{"tag":"param:stack","text":"Stack Handle."},{"tag":"param:value","text":"String to push."},{"tag":"error","text":"Invalid Handle or out of memory."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack","default":null},{"type":"const char[]","name":"value","decl":"const char[] value","default":null}]},{"name":"PushStackArray","docStart":6692,"docEnd":7282,"docs":{"brief":"Pushes a copy of an array of cells onto the end of a stack.  The cells\nare pushed as a block (i.e. the entire array takes up one stack slot),\nrather than pushing each cell individually.","tags":[{"tag":"","text":"Pushes a copy of an array of cells onto the end of a stack.  The cells\nare pushed as a block (i.e. the entire array takes up one stack slot),\nrather than pushing each cell individually."},{"tag":"param:stack","text":"Stack Handle."},{"tag":"param:values","text":"Block of values to copy."},{"tag":"param:size","text":"If not set, the number of elements copied from the array\nwill be equal to the blocksize.  If set higher than the\nblocksize, the operation will be truncated."},{"tag":"error","text":"Invalid Handle or out of memory."}]},"kind":"native","returnType":"void","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack","default":null},{"type":"const any[]","name":"values","decl":"const any[] values","default":null},{"type":"int","name":"size","decl":"int size","default":"-1"}]},{"name":"PopStackCell","docStart":7362,"docEnd":7810,"docs":{"brief":"Pops a cell value from a stack.","tags":[{"tag":"","text":"Pops a cell value from a stack."},{"tag":"param:stack","text":"Stack Handle."},{"tag":"param:value","text":"Variable to store the value."},{"tag":"param:block","text":"Optionally specify which block to read from\n(useful if the blocksize > 0)."},{"tag":"param:asChar","text":"Optionally read as a byte instead of a cell."},{"tag":"return","text":"True on success, false if the stack is empty."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack","default":null},{"type":"any&","name":"value","decl":"any& value","default":null},{"type":"int","name":"block","decl":"int block","default":"0"},{"type":"bool","name":"asChar","decl":"bool asChar","default":"false"}]},{"name":"PopStackString","docStart":7899,"docEnd":8202,"docs":{"brief":"Pops a string value from a stack.","tags":[{"tag":"","text":"Pops a string value from a stack."},{"tag":"param:stack","text":"Stack Handle."},{"tag":"param:buffer","text":"Buffer to store string."},{"tag":"param:maxlength","text":"Maximum size of the buffer."},{"tag":"return","text":"True on success, false if the stack is empty."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack","default":null},{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"maxlength","decl":"int maxlength","default":null},{"type":"int&","name":"written","decl":"int& written","default":"0"}]},{"name":"PopStackArray","docStart":8295,"docEnd":8704,"docs":{"brief":"Pops an array of cells from a stack.","tags":[{"tag":"","text":"Pops an array of cells from a stack."},{"tag":"param:stack","text":"Stack Handle."},{"tag":"param:buffer","text":"Buffer to store the array in."},{"tag":"param:size","text":"If not set, assumes the buffer size is equal to the\nblocksize.  Otherwise, the size passed is used."},{"tag":"return","text":"True on success, false if the stack is empty."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack","default":null},{"type":"any[]","name":"buffer","decl":"any[] buffer","default":null},{"type":"int","name":"size","decl":"int size","default":"-1"}]},{"name":"IsStackEmpty","docStart":8777,"docEnd":8961,"docs":{"brief":"Checks if a stack is empty.","tags":[{"tag":"","text":"Checks if a stack is empty."},{"tag":"param:stack","text":"Stack Handle."},{"tag":"return","text":"True if empty, false if not empty."},{"tag":"error","text":"Invalid Handle."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack","default":null}]},{"name":"PopStack","docStart":9006,"docEnd":9224,"docs":{"brief":"Pops a value off a stack, ignoring it completely.","tags":[{"tag":"","text":"Pops a value off a stack, ignoring it completely."},{"tag":"param:stack","text":"Stack Handle."},{"tag":"return","text":"True if something was popped, false otherwise."},{"tag":"error","text":"Invalid Handle."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack","default":null}]},{"name":"GetStackBlockSize","docStart":9319,"docEnd":9517,"docs":{"brief":"Returns the blocksize the stack was created with.","tags":[{"tag":"","text":"Returns the blocksize the stack was created with."},{"tag":"param:stack","text":"Stack Handle."},{"tag":"return","text":"The blocksize of the stack."},{"tag":"error","text":"Invalid Handle"}]},"kind":"native","returnType":"int","arguments":[{"type":"Handle","name":"stack","decl":"Handle stack","default":null}]}],"methodmaps":[{"name":"ArrayStack","docStart":0,"docEnd":0,"docs":null,"parent":"Handle","methods":[{"name":"ArrayStack","docStart":1696,"docEnd":2401,"docs":{"brief":"Creates a stack structure.  A stack is a LIFO (last in, first out)\nvector (array) of items.  It has O(1) insertion and O(1) removal.\n\nStacks have two operations: Push (adding an item) and Pop (removes\nitems in reverse-push order).\n\nThe contents of the stack are uniform; i.e. storing a string and then\nretrieving it as an integer is NOT the same as StringToInt()!\n\nThe \"blocksize\" determines how many cells each slot has; it cannot\nbe changed after creation.","tags":[{"tag":"","text":"Creates a stack structure.  A stack is a LIFO (last in, first out)\nvector (array) of items.  It has O(1) insertion and O(1) removal.\n\nStacks have two operations: Push (adding an item) and Pop (removes\nitems in reverse-push order).\n\nThe contents of the stack are uniform; i.e. storing a string and then\nretrieving it as an integer is NOT the same as StringToInt()!\n\nThe \"blocksize\" determines how many cells each slot has; it cannot\nbe changed after creation."},{"tag":"param:blocksize","text":"The number of cells each entry in the stack can\nhold.  For example, 32 cells is equivalent to:\nnew Array[X][32]"}]},"kind":"native","returnType":"ArrayStack","arguments":[{"type":"int","name":"blocksize","decl":"int blocksize","default":"1"}]},{"name":"Clone","docStart":2451,"docEnd":2775,"docs":{"brief":"Clones an stack, returning a new handle with the same size and data.\nThis should NOT be confused with CloneHandle. This is a completely new\nhandle with the same data but no relation to the original. It should\nclosed when no longer needed.","tags":[{"tag":"","text":"Clones an stack, returning a new handle with the same size and data.\nThis should NOT be confused with CloneHandle. This is a completely new\nhandle with the same data but no relation to the original. It should\nclosed when no longer needed."},{"tag":"return","text":"New handle to the cloned stack object"}]},"kind":"native","returnType":"ArrayStack","arguments":[]},{"name":"Push","docStart":2816,"docEnd":3014,"docs":{"brief":"Pushes a value onto the end of the stack, adding a new index.\n\nThis may safely be used even if the stack has a blocksize\ngreater than 1.","tags":[{"tag":"","text":"Pushes a value onto the end of the stack, adding a new index.\n\nThis may safely be used even if the stack has a blocksize\ngreater than 1."},{"tag":"param:value","text":"Value to push."}]},"kind":"native","returnType":"void","arguments":[{"type":"any","name":"value","decl":"any value","default":null}]},{"name":"PushString","docStart":3057,"docEnd":3193,"docs":{"brief":"Pushes a copy of a string onto the end of a stack, truncating it if it\nis too big.","tags":[{"tag":"","text":"Pushes a copy of a string onto the end of a stack, truncating it if it\nis too big."},{"tag":"param:value","text":"String to push."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"value","decl":"const char[] value","default":null}]},{"name":"PushArray","docStart":3251,"docEnd":3775,"docs":{"brief":"Pushes a copy of an array of cells onto the end of a stack. The cells\nare pushed as a block (i.e. the entire array takes up one stack slot),\nrather than pushing each cell individually.","tags":[{"tag":"","text":"Pushes a copy of an array of cells onto the end of a stack. The cells\nare pushed as a block (i.e. the entire array takes up one stack slot),\nrather than pushing each cell individually."},{"tag":"param:stack","text":"Stack Handle."},{"tag":"param:values","text":"Block of values to copy."},{"tag":"param:size","text":"If not set, the number of elements copied from the array\nwill be equal to the blocksize.  If set higher than the\nblocksize, the operation will be truncated."}]},"kind":"native","returnType":"void","arguments":[{"type":"const any[]","name":"values","decl":"const any[] values","default":null},{"type":"int","name":"size","decl":"int size","default":"-1"}]},{"name":"Pop","docStart":3845,"docEnd":4178,"docs":{"brief":"Pops a cell value from a stack.","tags":[{"tag":"","text":"Pops a cell value from a stack."},{"tag":"param:block","text":"Optionally specify which block to read from\n(useful if the blocksize > 0)."},{"tag":"param:asChar","text":"Optionally read as a byte instead of a cell."},{"tag":"return","text":"Value popped from the stack."},{"tag":"error","text":"The stack is empty."}]},"kind":"native","returnType":"any","arguments":[{"type":"int","name":"block","decl":"int block","default":"0"},{"type":"bool","name":"asChar","decl":"bool asChar","default":"false"}]},{"name":"PopString","docStart":4240,"docEnd":4553,"docs":{"brief":"Pops a string value from a stack.","tags":[{"tag":"","text":"Pops a string value from a stack."},{"tag":"param:buffer","text":"Buffer to store string."},{"tag":"param:maxlength","text":"Maximum size of the buffer."},{"tag":"param:written","text":"Number of characters written to buffer, not including\nthe null terminator."},{"tag":"error","text":"The stack is empty."}]},"kind":"native","returnType":"void","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"maxlength","decl":"int maxlength","default":null},{"type":"int&","name":"written","decl":"int& written","default":"0"}]},{"name":"PopArray","docStart":4638,"docEnd":4932,"docs":{"brief":"Pops an array of cells from a stack.","tags":[{"tag":"","text":"Pops an array of cells from a stack."},{"tag":"param:buffer","text":"Buffer to store the array in."},{"tag":"param:size","text":"If not set, assumes the buffer size is equal to the\nblocksize.  Otherwise, the size passed is used."},{"tag":"error","text":"The stack is empty."}]},"kind":"native","returnType":"void","arguments":[{"type":"any[]","name":"buffer","decl":"any[] buffer","default":null},{"type":"int","name":"size","decl":"int size","default":"-1"}]}],"properties":[{"name":"Empty","docStart":4995,"docEnd":5050,"docs":{"brief":"Returns true if the stack is empty, false otherwise.","tags":[{"tag":"","text":"Returns true if the stack is empty, false otherwise."}]},"type":"bool","getter":true,"setter":false},{"name":"BlockSize","docStart":5108,"docEnd":5161,"docs":{"brief":"Retrieve the blocksize the stack was created with.","tags":[{"tag":"","text":"Retrieve the blocksize the stack was created with."}]},"type":"int","getter":true,"setter":false}]}],"enumstructs":[],"constants":[],"enums":[],"typesets":[],"typedefs":[]}