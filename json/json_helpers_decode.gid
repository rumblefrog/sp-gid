{"functions":[{"name":"json_is_whitespace","docStart":1780,"docEnd":2028,"docs":{"brief":"Checks whether the character at the beginning\nof the buffer is whitespace.","tags":[{"tag":"","text":"Checks whether the character at the beginning\nof the buffer is whitespace."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if the first character in the buffer\nis whitespace, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_string","docStart":2201,"docEnd":2624,"docs":{"brief":"Checks whether the character at the beginning\nof the buffer is the start of a string.","tags":[{"tag":"","text":"Checks whether the character at the beginning\nof the buffer is the start of a string."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"param:allow_single_quotes","text":"Should strings wrapped in\nsingle quotes be accepted?"},{"tag":"returns","text":"True if the first character in the buffer\nis the start of a string, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"bool","name":"allow_single_quotes","decl":"bool allow_single_quotes","default":"false"}]},{"name":"json_is_int","docStart":2786,"docEnd":2963,"docs":{"brief":"Checks whether the buffer provided contains an int.","tags":[{"tag":"","text":"Checks whether the buffer provided contains an int."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if buffer contains an int, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_float","docStart":3864,"docEnd":4043,"docs":{"brief":"Checks whether the buffer provided contains a float.","tags":[{"tag":"","text":"Checks whether the buffer provided contains a float."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if buffer contains a float, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_at_end","docStart":7367,"docEnd":7773,"docs":{"brief":"Checks whether the character at the beginning of the buffer\nis considered a valid 'end point' for some data, such as a\ncolon (indicating a key), a comma (indicating a new element),\nor the end of an object or array.","tags":[{"tag":"","text":"Checks whether the character at the beginning of the buffer\nis considered a valid 'end point' for some data, such as a\ncolon (indicating a key), a comma (indicating a new element),\nor the end of an object or array."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if the first character in the buffer\nis a valid data end point, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"bool","name":"is_array","decl":"bool is_array","default":null}]},{"name":"json_skip_whitespace","docStart":8020,"docEnd":8385,"docs":{"brief":"Moves the position until it reaches a non-whitespace\ncharacter or the end of the buffer's maximum size.","tags":[{"tag":"","text":"Moves the position until it reaches a non-whitespace\ncharacter or the end of the buffer's maximum size."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"param:max_size","text":"Maximum size of string buffer."},{"tag":"param:pos","text":"Position to increment."},{"tag":"returns","text":"True if pos has not reached the end\nof the buffer, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"int","name":"max_size","decl":"int max_size","default":null},{"type":"int&","name":"pos","decl":"int& pos","default":null}]},{"name":"json_extract_until_end_size","docStart":8584,"docEnd":9160,"docs":{"brief":"Calculates the size of the buffer required to store the next\nJSON cell stored in the provided buffer at the provided position.\nThis function is quite forgiving of malformed input and shouldn't be\nrelied upon as proof that the input is valid.","tags":[{"tag":"","text":"Calculates the size of the buffer required to store the next\nJSON cell stored in the provided buffer at the provided position.\nThis function is quite forgiving of malformed input and shouldn't be\nrelied upon as proof that the input is valid."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"param:max_size","text":"Maximum size of string buffer."},{"tag":"param:pos","text":"Position to increment."},{"tag":"param:is_array","text":"Whether the decoder is processing an array."},{"tag":"returns","text":"The size of the buffer required to store the cell."}]},"kind":"stock","returnType":"int","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"int","name":"max_size","decl":"int max_size","default":null},{"type":"int","name":"pos","decl":"int pos","default":null},{"type":"bool","name":"is_array","decl":"bool is_array","default":null}]},{"name":"json_extract_until_end","docStart":9607,"docEnd":10178,"docs":{"brief":"Extracts a JSON cell from the buffer until\na valid end point is reached.","tags":[{"tag":"","text":"Extracts a JSON cell from the buffer until\na valid end point is reached."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"param:max_size","text":"Maximum size of string buffer."},{"tag":"param:pos","text":"Position to increment."},{"tag":"param:output","text":"String buffer to store output."},{"tag":"param:output_max_size","text":"Maximum size of output string buffer."},{"tag":"param:is_array","text":"Whether the decoder is processing an array."},{"tag":"returns","text":"True if pos has not reached the end\nof the buffer, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"int","name":"max_size","decl":"int max_size","default":null},{"type":"int&","name":"pos","decl":"int& pos","default":null},{"type":"char[]","name":"output","decl":"char[] output","default":null},{"type":"int","name":"output_max_size","decl":"int output_max_size","default":null},{"type":"bool","name":"is_array","decl":"bool is_array","default":null}]},{"name":"json_extract_string_size","docStart":11143,"docEnd":11723,"docs":{"brief":"Calculates the size of the buffer required to store the next\nJSON string stored in the provided buffer at the provided position.\nThis function is quite forgiving of malformed input and shouldn't be\nrelied upon as proof that the input is valid.","tags":[{"tag":"","text":"Calculates the size of the buffer required to store the next\nJSON string stored in the provided buffer at the provided position.\nThis function is quite forgiving of malformed input and shouldn't be\nrelied upon as proof that the input is valid."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"param:max_size","text":"Maximum size of string buffer."},{"tag":"param:pos","text":"Position to increment."},{"tag":"param:is_array","text":"Whether the decoder is processing an array."},{"tag":"returns","text":"The size of the buffer required to store the string."}]},"kind":"stock","returnType":"int","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"int","name":"max_size","decl":"int max_size","default":null},{"type":"int","name":"pos","decl":"int pos","default":null},{"type":"bool","name":"is_array","decl":"bool is_array","default":null}]},{"name":"json_extract_string","docStart":12655,"docEnd":13228,"docs":{"brief":"Extracts a JSON string from the buffer until\na valid end point is reached.","tags":[{"tag":"","text":"Extracts a JSON string from the buffer until\na valid end point is reached."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"param:max_size","text":"Maximum size of string buffer."},{"tag":"param:pos","text":"Position to increment."},{"tag":"param:output","text":"String buffer to store output."},{"tag":"param:output_max_size","text":"Maximum size of output string buffer."},{"tag":"param:is_array","text":"Whether the decoder is processing an array."},{"tag":"returns","text":"True if pos has not reached the end\nof the buffer, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"int","name":"max_size","decl":"int max_size","default":null},{"type":"int&","name":"pos","decl":"int& pos","default":null},{"type":"char[]","name":"output","decl":"char[] output","default":null},{"type":"int","name":"output_max_size","decl":"int output_max_size","default":null},{"type":"bool","name":"is_array","decl":"bool is_array","default":null}]}],"methodmaps":[],"enumstructs":[],"constants":[],"enums":[],"typesets":[],"typedefs":[]}