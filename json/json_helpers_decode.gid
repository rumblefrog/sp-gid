{"functions":[{"name":"json_is_whitespace","docStart":1782,"docEnd":2030,"docs":{"brief":"Checks whether the character at the beginning\nof the buffer is whitespace.","tags":[{"tag":"","text":"Checks whether the character at the beginning\nof the buffer is whitespace."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if the first character in the buffer\nis whitespace, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_string","docStart":2203,"docEnd":2473,"docs":{"brief":"Checks whether the character at the beginning\nof the buffer is the start of a string.","tags":[{"tag":"","text":"Checks whether the character at the beginning\nof the buffer is the start of a string."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if the first character in the buffer\nis the start of a string, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_int","docStart":2606,"docEnd":2783,"docs":{"brief":"Checks whether the buffer provided contains an int.","tags":[{"tag":"","text":"Checks whether the buffer provided contains an int."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if buffer contains an int, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_float","docStart":3791,"docEnd":3970,"docs":{"brief":"Checks whether the buffer provided contains a float.","tags":[{"tag":"","text":"Checks whether the buffer provided contains a float."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if buffer contains a float, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_bool","docStart":7315,"docEnd":7492,"docs":{"brief":"Checks whether the buffer provided contains a bool.","tags":[{"tag":"","text":"Checks whether the buffer provided contains a bool."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if buffer contains a bool, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_null","docStart":7609,"docEnd":7782,"docs":{"brief":"Checks whether the buffer provided contains null.","tags":[{"tag":"","text":"Checks whether the buffer provided contains null."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if buffer contains null, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_object","docStart":7870,"docEnd":8142,"docs":{"brief":"Checks whether the character at the beginning\nof the buffer is the start of an object.","tags":[{"tag":"","text":"Checks whether the character at the beginning\nof the buffer is the start of an object."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if the first character in the buffer is\nthe start of an object, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_object_end","docStart":8224,"docEnd":8492,"docs":{"brief":"Checks whether the character at the beginning\nof the buffer is the end of an object.","tags":[{"tag":"","text":"Checks whether the character at the beginning\nof the buffer is the end of an object."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if the first character in the buffer is\nthe end of an object, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_array","docStart":8578,"docEnd":8848,"docs":{"brief":"Checks whether the character at the beginning\nof the buffer is the start of an array.","tags":[{"tag":"","text":"Checks whether the character at the beginning\nof the buffer is the start of an array."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if the first character in the buffer is\nthe start of an array, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_array_end","docStart":8929,"docEnd":9195,"docs":{"brief":"Checks whether the character at the beginning\nof the buffer is the end of an array.","tags":[{"tag":"","text":"Checks whether the character at the beginning\nof the buffer is the end of an array."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if the first character in the buffer is\nthe end of an array, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_at_end","docStart":9280,"docEnd":9686,"docs":{"brief":"Checks whether the character at the beginning of the buffer\nis considered a valid 'end point' for some data, such as a\ncolon (indicating a key), a comma (indicating a new element),\nor the end of an object or array.","tags":[{"tag":"","text":"Checks whether the character at the beginning of the buffer\nis considered a valid 'end point' for some data, such as a\ncolon (indicating a key), a comma (indicating a new element),\nor the end of an object or array."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if the first character in the buffer\nis a valid data end point, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"bool","name":"is_array","decl":"bool is_array","default":null}]},{"name":"json_skip_whitespace","docStart":9958,"docEnd":10323,"docs":{"brief":"Moves the position until it reaches a non-whitespace\ncharacter or the end of the buffer's maximum size.","tags":[{"tag":"","text":"Moves the position until it reaches a non-whitespace\ncharacter or the end of the buffer's maximum size."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"param:max_size","text":"Maximum size of string buffer."},{"tag":"param:pos","text":"Position to increment."},{"tag":"returns","text":"True if pos has not reached the end\nof the buffer, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"int","name":"max_size","decl":"int max_size","default":null},{"type":"int&","name":"pos","decl":"int& pos","default":null}]},{"name":"json_extract_until_end","docStart":10519,"docEnd":11090,"docs":{"brief":"Extracts a JSON cell from the buffer until\na valid end point is reached.","tags":[{"tag":"","text":"Extracts a JSON cell from the buffer until\na valid end point is reached."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"param:max_size","text":"Maximum size of string buffer."},{"tag":"param:pos","text":"Position to increment."},{"tag":"param:output","text":"String buffer to store output."},{"tag":"param:output_max_size","text":"Maximum size of output string buffer."},{"tag":"param:is_array","text":"Whether the decoder is processing an array."},{"tag":"returns","text":"True if pos has not reached the end\nof the buffer, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"int","name":"max_size","decl":"int max_size","default":null},{"type":"int&","name":"pos","decl":"int& pos","default":null},{"type":"char[]","name":"output","decl":"char[] output","default":null},{"type":"int","name":"output_max_size","decl":"int output_max_size","default":null},{"type":"bool","name":"is_array","decl":"bool is_array","default":null}]},{"name":"json_extract_string","docStart":12052,"docEnd":12625,"docs":{"brief":"Extracts a JSON string from the buffer until\na valid end point is reached.","tags":[{"tag":"","text":"Extracts a JSON string from the buffer until\na valid end point is reached."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"param:max_size","text":"Maximum size of string buffer."},{"tag":"param:pos","text":"Position to increment."},{"tag":"param:output","text":"String buffer to store output."},{"tag":"param:output_max_size","text":"Maximum size of output string buffer."},{"tag":"param:is_array","text":"Whether the decoder is processing an array."},{"tag":"returns","text":"True if pos has not reached the end\nof the buffer, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"int","name":"max_size","decl":"int max_size","default":null},{"type":"int&","name":"pos","decl":"int& pos","default":null},{"type":"char[]","name":"output","decl":"char[] output","default":null},{"type":"int","name":"output_max_size","decl":"int output_max_size","default":null},{"type":"bool","name":"is_array","decl":"bool is_array","default":null}]},{"name":"json_extract_int","docStart":14671,"docEnd":14805,"docs":{"brief":"Extracts an int from the buffer.","tags":[{"tag":"","text":"Extracts an int from the buffer."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"Int value of the buffer."}]},"kind":"stock","returnType":"int","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_extract_float","docStart":14891,"docEnd":15028,"docs":{"brief":"Extracts a float from the buffer.","tags":[{"tag":"","text":"Extracts a float from the buffer."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"Float value of the buffer."}]},"kind":"stock","returnType":"float","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_extract_bool","docStart":15120,"docEnd":15255,"docs":{"brief":"Extracts a bool from the buffer.","tags":[{"tag":"","text":"Extracts a bool from the buffer."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"Bool value of the buffer."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]}],"methodmaps":[],"enumstructs":[],"constants":[],"enums":[],"typesets":[],"typedefs":[]}