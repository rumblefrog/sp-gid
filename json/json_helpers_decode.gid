{"functions":[{"name":"json_is_whitespace","docStart":1780,"docEnd":2028,"docs":{"brief":"Checks whether the character at the beginning\nof the buffer is whitespace.","tags":[{"tag":"","text":"Checks whether the character at the beginning\nof the buffer is whitespace."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if the first character in the buffer\nis whitespace, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_string","docStart":2201,"docEnd":2624,"docs":{"brief":"Checks whether the character at the beginning\nof the buffer is the start of a string.","tags":[{"tag":"","text":"Checks whether the character at the beginning\nof the buffer is the start of a string."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"param:allow_single_quotes","text":"Should strings wrapped in\nsingle quotes be accepted?"},{"tag":"returns","text":"True if the first character in the buffer\nis the start of a string, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"bool","name":"allow_single_quotes","decl":"bool allow_single_quotes","default":"false"}]},{"name":"json_is_int","docStart":2786,"docEnd":2963,"docs":{"brief":"Checks whether the buffer provided contains an int.","tags":[{"tag":"","text":"Checks whether the buffer provided contains an int."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if buffer contains an int, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_float","docStart":3864,"docEnd":4043,"docs":{"brief":"Checks whether the buffer provided contains a float.","tags":[{"tag":"","text":"Checks whether the buffer provided contains a float."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if buffer contains a float, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_bool","docStart":7367,"docEnd":7544,"docs":{"brief":"Checks whether the buffer provided contains a bool.","tags":[{"tag":"","text":"Checks whether the buffer provided contains a bool."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if buffer contains a bool, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_null","docStart":7661,"docEnd":7834,"docs":{"brief":"Checks whether the buffer provided contains null.","tags":[{"tag":"","text":"Checks whether the buffer provided contains null."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if buffer contains null, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_object_start","docStart":7922,"docEnd":8194,"docs":{"brief":"Checks whether the character at the beginning\nof the buffer is the start of an object.","tags":[{"tag":"","text":"Checks whether the character at the beginning\nof the buffer is the start of an object."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if the first character in the buffer is\nthe start of an object, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_object_end","docStart":8282,"docEnd":8550,"docs":{"brief":"Checks whether the character at the beginning\nof the buffer is the end of an object.","tags":[{"tag":"","text":"Checks whether the character at the beginning\nof the buffer is the end of an object."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if the first character in the buffer is\nthe end of an object, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_array_start","docStart":8636,"docEnd":8906,"docs":{"brief":"Checks whether the character at the beginning\nof the buffer is the start of an array.","tags":[{"tag":"","text":"Checks whether the character at the beginning\nof the buffer is the start of an array."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if the first character in the buffer is\nthe start of an array, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_array_end","docStart":8993,"docEnd":9259,"docs":{"brief":"Checks whether the character at the beginning\nof the buffer is the end of an array.","tags":[{"tag":"","text":"Checks whether the character at the beginning\nof the buffer is the end of an array."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if the first character in the buffer is\nthe end of an array, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null}]},{"name":"json_is_at_end","docStart":9344,"docEnd":9750,"docs":{"brief":"Checks whether the character at the beginning of the buffer\nis considered a valid 'end point' for some data, such as a\ncolon (indicating a key), a comma (indicating a new element),\nor the end of an object or array.","tags":[{"tag":"","text":"Checks whether the character at the beginning of the buffer\nis considered a valid 'end point' for some data, such as a\ncolon (indicating a key), a comma (indicating a new element),\nor the end of an object or array."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"returns","text":"True if the first character in the buffer\nis a valid data end point, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"bool","name":"is_array","decl":"bool is_array","default":null}]},{"name":"json_skip_whitespace","docStart":10022,"docEnd":10387,"docs":{"brief":"Moves the position until it reaches a non-whitespace\ncharacter or the end of the buffer's maximum size.","tags":[{"tag":"","text":"Moves the position until it reaches a non-whitespace\ncharacter or the end of the buffer's maximum size."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"param:max_size","text":"Maximum size of string buffer."},{"tag":"param:pos","text":"Position to increment."},{"tag":"returns","text":"True if pos has not reached the end\nof the buffer, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"int","name":"max_size","decl":"int max_size","default":null},{"type":"int&","name":"pos","decl":"int& pos","default":null}]},{"name":"json_extract_until_end_size","docStart":10586,"docEnd":11041,"docs":{"brief":"Calculates the size of the buffer required to store the next\nJSON cell stored in the provided buffer at the provided position.","tags":[{"tag":"","text":"Calculates the size of the buffer required to store the next\nJSON cell stored in the provided buffer at the provided position."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"param:max_size","text":"Maximum size of string buffer."},{"tag":"param:pos","text":"Position to increment."},{"tag":"param:is_array","text":"Whether the decoder is processing an array."},{"tag":"returns","text":"The size of the buffer required to store the cell."}]},"kind":"stock","returnType":"int","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"int","name":"max_size","decl":"int max_size","default":null},{"type":"int","name":"pos","decl":"int pos","default":null},{"type":"bool","name":"is_array","decl":"bool is_array","default":null}]},{"name":"json_extract_until_end","docStart":11488,"docEnd":12059,"docs":{"brief":"Extracts a JSON cell from the buffer until\na valid end point is reached.","tags":[{"tag":"","text":"Extracts a JSON cell from the buffer until\na valid end point is reached."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"param:max_size","text":"Maximum size of string buffer."},{"tag":"param:pos","text":"Position to increment."},{"tag":"param:output","text":"String buffer to store output."},{"tag":"param:output_max_size","text":"Maximum size of output string buffer."},{"tag":"param:is_array","text":"Whether the decoder is processing an array."},{"tag":"returns","text":"True if pos has not reached the end\nof the buffer, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"int","name":"max_size","decl":"int max_size","default":null},{"type":"int&","name":"pos","decl":"int& pos","default":null},{"type":"char[]","name":"output","decl":"char[] output","default":null},{"type":"int","name":"output_max_size","decl":"int output_max_size","default":null},{"type":"bool","name":"is_array","decl":"bool is_array","default":null}]},{"name":"json_extract_string_size","docStart":13024,"docEnd":13483,"docs":{"brief":"Calculates the size of the buffer required to store the next\nJSON string stored in the provided buffer at the provided position.","tags":[{"tag":"","text":"Calculates the size of the buffer required to store the next\nJSON string stored in the provided buffer at the provided position."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"param:max_size","text":"Maximum size of string buffer."},{"tag":"param:pos","text":"Position to increment."},{"tag":"param:is_array","text":"Whether the decoder is processing an array."},{"tag":"returns","text":"The size of the buffer required to store the string."}]},"kind":"stock","returnType":"int","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"int","name":"max_size","decl":"int max_size","default":null},{"type":"int","name":"pos","decl":"int pos","default":null},{"type":"bool","name":"is_array","decl":"bool is_array","default":null}]},{"name":"json_extract_string","docStart":14737,"docEnd":15310,"docs":{"brief":"Extracts a JSON string from the buffer until\na valid end point is reached.","tags":[{"tag":"","text":"Extracts a JSON string from the buffer until\na valid end point is reached."},{"tag":"param:buffer","text":"String buffer of data."},{"tag":"param:max_size","text":"Maximum size of string buffer."},{"tag":"param:pos","text":"Position to increment."},{"tag":"param:output","text":"String buffer to store output."},{"tag":"param:output_max_size","text":"Maximum size of output string buffer."},{"tag":"param:is_array","text":"Whether the decoder is processing an array."},{"tag":"returns","text":"True if pos has not reached the end\nof the buffer, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"buffer","decl":"const char[] buffer","default":null},{"type":"int","name":"max_size","decl":"int max_size","default":null},{"type":"int&","name":"pos","decl":"int& pos","default":null},{"type":"char[]","name":"output","decl":"char[] output","default":null},{"type":"int","name":"output_max_size","decl":"int output_max_size","default":null},{"type":"bool","name":"is_array","decl":"bool is_array","default":null}]}],"methodmaps":[],"enumstructs":[],"constants":[],"enums":[],"typesets":[],"typedefs":[]}