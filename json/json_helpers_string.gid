{"functions":[{"name":"json_escape_string","docStart":1963,"docEnd":2101,"docs":{"brief":"Escapes a string in-place in a buffer.","tags":[{"tag":"","text":"Escapes a string in-place in a buffer."},{"tag":"param:buffer","text":"String buffer."},{"tag":"param:max_size","text":"Maximum size of string buffer."}]},"kind":"stock","returnType":"void","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"max_size","decl":"int max_size","default":null}]},{"name":"json_unescape_string","docStart":3609,"docEnd":3749,"docs":{"brief":"Unescapes a string in-place in a buffer.","tags":[{"tag":"","text":"Unescapes a string in-place in a buffer."},{"tag":"param:buffer","text":"String buffer."},{"tag":"param:max_size","text":"Maximum size of string buffer."}]},"kind":"stock","returnType":"void","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer","default":null},{"type":"int","name":"max_size","decl":"int max_size","default":null}]},{"name":"json_string_startswith","docStart":5610,"docEnd":5919,"docs":{"brief":"Checks if a string starts with another string.","tags":[{"tag":"","text":"Checks if a string starts with another string."},{"tag":"param:haystack","text":"String to check that starts with needle."},{"tag":"param:max_size","text":"Maximum size of string buffer."},{"tag":"param:needle","text":"String to check that haystack starts with."},{"tag":"returns","text":"True if haystack begins with needle, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"haystack","decl":"const char[] haystack","default":null},{"type":"const char[]","name":"needle","decl":"const char[] needle","default":null}]},{"name":"json_string_endswith","docStart":6308,"docEnd":6609,"docs":{"brief":"Checks if a string ends with another string.","tags":[{"tag":"","text":"Checks if a string ends with another string."},{"tag":"param:haystack","text":"String to check that ends with needle."},{"tag":"param:max_size","text":"Maximum size of string buffer."},{"tag":"param:needle","text":"String to check that haystack ends with."},{"tag":"returns","text":"True if haystack ends with needle, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"haystack","decl":"const char[] haystack","default":null},{"type":"const char[]","name":"needle","decl":"const char[] needle","default":null}]},{"name":"json_char_is_hex","docStart":7030,"docEnd":7222,"docs":{"brief":"Checks whether the provided character is a valid hexadecimal character.","tags":[{"tag":"","text":"Checks whether the provided character is a valid hexadecimal character."},{"tag":"param:c","text":"Character to check."},{"tag":"returns","text":"True if c is a hexadecimal character, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"int","name":"c","decl":"int c","default":null}]},{"name":"json_cell_string_size","docStart":7382,"docEnd":7584,"docs":{"brief":"Calculates the maximum buffer length required to\nstore the JSON cell representation of a string.","tags":[{"tag":"","text":"Calculates the maximum buffer length required to\nstore the JSON cell representation of a string."},{"tag":"param:length","text":"The length of the string."},{"tag":"returns","text":"Maximum buffer length."}]},"kind":"stock","returnType":"int","arguments":[{"type":"int","name":"length","decl":"int length","default":null}]},{"name":"json_cell_string","docStart":7742,"docEnd":7959,"docs":{"brief":"Generates the JSON cell representation of a string.","tags":[{"tag":"","text":"Generates the JSON cell representation of a string."},{"tag":"param:input","text":"Value to generate output for."},{"tag":"param:output","text":"String buffer to store output."},{"tag":"param:max_size","text":"Maximum size of string buffer."}]},"kind":"stock","returnType":"void","arguments":[{"type":"const char[]","name":"input","decl":"const char[] input","default":null},{"type":"char[]","name":"output","decl":"char[] output","default":null},{"type":"int","name":"max_size","decl":"int max_size","default":null}]}],"methodmaps":[],"enumstructs":[],"constants":[],"enums":[],"typesets":[],"typedefs":[]}