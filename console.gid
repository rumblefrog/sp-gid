{"functions":[{"name":"ServerCommand","docStart":6577,"docEnd":6771,"docs":{"brief":"Executes a server command as if it were on the server console (or RCON)","tags":[{"tag":"","text":"Executes a server command as if it were on the server console (or RCON)"},{"tag":"param:format","text":"Formatting rules."},{"tag":"param:...","text":"Variable number of format parameters."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"ServerCommandEx","docStart":6833,"docEnd":7422,"docs":{"brief":"Executes a server command as if it were on the server console (or RCON)\nand stores the printed text into buffer.\n\nWarning: This calls ServerExecute internally and may have issues if\ncertain commands are in the buffer, only use when you really need\nthe response.\nAlso, on L4D2 this will not print the command output to the server console.","tags":[{"tag":"","text":"Executes a server command as if it were on the server console (or RCON)\nand stores the printed text into buffer.\n\nWarning: This calls ServerExecute internally and may have issues if\ncertain commands are in the buffer, only use when you really need\nthe response.\nAlso, on L4D2 this will not print the command output to the server console."},{"tag":"param:buffer","text":"String to store command result into."},{"tag":"param:maxlen","text":"Length of buffer."},{"tag":"param:format","text":"Formatting rules."},{"tag":"param:...","text":"Variable number of format parameters."}]},"kind":"native","returnType":"void","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlen","decl":"int maxlen"},{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"InsertServerCommand","docStart":7513,"docEnd":7707,"docs":{"brief":"Inserts a server command at the beginning of the server command buffer.","tags":[{"tag":"","text":"Inserts a server command at the beginning of the server command buffer."},{"tag":"param:format","text":"Formatting rules."},{"tag":"param:...","text":"Variable number of format parameters."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"ServerExecute","docStart":7775,"docEnd":7870,"docs":{"brief":"Executes every command in the server's command buffer, rather than once per frame.","tags":[{"tag":"","text":"Executes every command in the server's command buffer, rather than once per frame."}]},"kind":"native","returnType":"void","arguments":[]},{"name":"ClientCommand","docStart":7904,"docEnd":8263,"docs":{"brief":"Executes a client command.  Note that this will not work on clients unless\nthey have cl_restrict_server_commands set to 0.","tags":[{"tag":"","text":"Executes a client command.  Note that this will not work on clients unless\nthey have cl_restrict_server_commands set to 0."},{"tag":"param:client","text":"Index of the client."},{"tag":"param:fmt","text":"Format of the client command."},{"tag":"param:...","text":"Format parameters"},{"tag":"error","text":"Invalid client index, or client not connected."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"client","decl":"int client"},{"type":"const char[]","name":"fmt","decl":"const char[] fmt"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"FakeClientCommand","docStart":8334,"docEnd":8979,"docs":{"brief":"Executes a client command on the server without being networked.\n\nFakeClientCommand() overwrites the command tokenization buffer.  This can\ncause undesired effects because future calls to GetCmdArg* will return\ndata from the FakeClientCommand(), not the parent command.  If you are in\na hook where this matters (for example, a \"say\" hook), you should use\nFakeClientCommandEx() instead.","tags":[{"tag":"","text":"Executes a client command on the server without being networked.\n\nFakeClientCommand() overwrites the command tokenization buffer.  This can\ncause undesired effects because future calls to GetCmdArg* will return\ndata from the FakeClientCommand(), not the parent command.  If you are in\na hook where this matters (for example, a \"say\" hook), you should use\nFakeClientCommandEx() instead."},{"tag":"param:client","text":"Index of the client."},{"tag":"param:fmt","text":"Format of the client command."},{"tag":"param:...","text":"Format parameters"},{"tag":"error","text":"Invalid client index, or client not connected."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"client","decl":"int client"},{"type":"const char[]","name":"fmt","decl":"const char[] fmt"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"FakeClientCommandEx","docStart":9054,"docEnd":9501,"docs":{"brief":"Executes a client command on the server without being networked.  The\nexecution of the client command is delayed by one frame to prevent any\nre-entrancy issues that might surface with FakeClientCommand().","tags":[{"tag":"","text":"Executes a client command on the server without being networked.  The\nexecution of the client command is delayed by one frame to prevent any\nre-entrancy issues that might surface with FakeClientCommand()."},{"tag":"param:client","text":"Index of the client."},{"tag":"param:fmt","text":"Format of the client command."},{"tag":"param:...","text":"Format parameters"},{"tag":"error","text":"Invalid client index, or client not connected."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"client","decl":"int client"},{"type":"const char[]","name":"fmt","decl":"const char[] fmt"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"FakeClientCommandKeyValues","docStart":9578,"docEnd":9893,"docs":{"brief":"Executes a KeyValues client command on the server without being networked.","tags":[{"tag":"","text":"Executes a KeyValues client command on the server without being networked."},{"tag":"param:client","text":"Index of the client."},{"tag":"param:kv","text":"KeyValues data to be sent."},{"tag":"error","text":"Invalid client index, client not connected,\nor unsupported on current game."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"client","decl":"int client"},{"type":"KeyValues","name":"kv","decl":"KeyValues kv"}]},{"name":"PrintToServer","docStart":9964,"docEnd":10125,"docs":{"brief":"Sends a message to the server console.","tags":[{"tag":"","text":"Sends a message to the server console."},{"tag":"param:format","text":"Formatting rules."},{"tag":"param:...","text":"Variable number of format parameters."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"PrintToConsole","docStart":10187,"docEnd":10468,"docs":{"brief":"Sends a message to a client's console.","tags":[{"tag":"","text":"Sends a message to a client's console."},{"tag":"param:client","text":"Client index."},{"tag":"param:format","text":"Formatting rules."},{"tag":"param:...","text":"Variable number of format parameters."},{"tag":"error","text":"If the client is not connected an error will be thrown."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"client","decl":"int client"},{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"PrintToConsoleAll","docStart":10545,"docEnd":10710,"docs":{"brief":"Sends a message to every client's console.","tags":[{"tag":"","text":"Sends a message to every client's console."},{"tag":"param:format","text":"Formatting rules."},{"tag":"param:...","text":"Variable number of format parameters."}]},"kind":"stock","returnType":"void","arguments":[{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"ReplyToCommand","docStart":11001,"docEnd":11460,"docs":{"brief":"Replies to a message in a command.\n\nA client index of 0 will use PrintToServer().\nIf the command was from the console, PrintToConsole() is used.\nIf the command was from chat, PrintToChat() is used.","tags":[{"tag":"","text":"Replies to a message in a command.\n\nA client index of 0 will use PrintToServer().\nIf the command was from the console, PrintToConsole() is used.\nIf the command was from chat, PrintToChat() is used."},{"tag":"param:client","text":"Client index, or 0 for server."},{"tag":"param:format","text":"Formatting rules."},{"tag":"param:...","text":"Variable number of format parameters."},{"tag":"error","text":"If the client is not connected or invalid."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"client","decl":"int client"},{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"GetCmdReplySource","docStart":11535,"docEnd":11642,"docs":{"brief":"Returns the current reply source of a command.","tags":[{"tag":"","text":"Returns the current reply source of a command."},{"tag":"return","text":"ReplySource value."}]},"kind":"native","returnType":"ReplySource","arguments":[]},{"name":"SetCmdReplySource","docStart":11687,"docEnd":11966,"docs":{"brief":"Sets the current reply source of a command.\n\nOnly use this if you know what you are doing.  You should save the old value\nand restore it once you are done.","tags":[{"tag":"","text":"Sets the current reply source of a command.\n\nOnly use this if you know what you are doing.  You should save the old value\nand restore it once you are done."},{"tag":"param:source","text":"New ReplySource value."},{"tag":"return","text":"Old ReplySource value."}]},"kind":"native","returnType":"ReplySource","arguments":[{"type":"ReplySource","name":"source","decl":"ReplySource source"}]},{"name":"IsChatTrigger","docStart":12029,"docEnd":12238,"docs":{"brief":"Returns whether the current say hook is a chat trigger.\n\nThis function is only meaningful inside say or say_team hooks.","tags":[{"tag":"","text":"Returns whether the current say hook is a chat trigger.\n\nThis function is only meaningful inside say or say_team hooks."},{"tag":"return","text":"True if a chat trigger, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[]},{"name":"ShowActivity2","docStart":12272,"docEnd":12791,"docs":{"brief":"Displays usage of an admin command to users depending on the\nsetting of the sm_show_activity cvar.  All users receive a message\nin their chat text, except for the originating client, who receives\nthe message based on the current ReplySource.","tags":[{"tag":"","text":"Displays usage of an admin command to users depending on the\nsetting of the sm_show_activity cvar.  All users receive a message\nin their chat text, except for the originating client, who receives\nthe message based on the current ReplySource."},{"tag":"param:client","text":"Client index doing the action, or 0 for server."},{"tag":"param:tag","text":"Tag to prepend to the message."},{"tag":"param:format","text":"Formatting rules."},{"tag":"param:...","text":"Variable number of format parameters."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"client","decl":"int client"},{"type":"const char[]","name":"tag","decl":"const char[] tag"},{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"ShowActivity","docStart":12883,"docEnd":13452,"docs":{"brief":"Displays usage of an admin command to users depending on the\nsetting of the sm_show_activity cvar.\n\nThis version does not display a message to the originating client\nif used from chat triggers or menus.  If manual replies are used\nfor these cases, then this function will suffice.  Otherwise,\nShowActivity2() is slightly more useful.","tags":[{"tag":"","text":"Displays usage of an admin command to users depending on the\nsetting of the sm_show_activity cvar.\n\nThis version does not display a message to the originating client\nif used from chat triggers or menus.  If manual replies are used\nfor these cases, then this function will suffice.  Otherwise,\nShowActivity2() is slightly more useful."},{"tag":"param:client","text":"Client index doing the action, or 0 for server."},{"tag":"param:format","text":"Formatting rules."},{"tag":"param:...","text":"Variable number of format parameters."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"client","decl":"int client"},{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"ShowActivityEx","docStart":13525,"docEnd":13898,"docs":{"brief":"Same as ShowActivity(), except the tag parameter is used instead of\n\"[SM] \" (note that you must supply any spacing).","tags":[{"tag":"","text":"Same as ShowActivity(), except the tag parameter is used instead of\n\"[SM] \" (note that you must supply any spacing)."},{"tag":"param:client","text":"Client index doing the action, or 0 for server."},{"tag":"param:tag","text":"Tag to display with."},{"tag":"param:format","text":"Formatting rules."},{"tag":"param:...","text":"Variable number of format parameters."}]},"kind":"native","returnType":"void","arguments":[{"type":"int","name":"client","decl":"int client"},{"type":"const char[]","name":"tag","decl":"const char[] tag"},{"type":"const char[]","name":"format","decl":"const char[] format"},{"type":"any...","name":"...","decl":"any... ..."}]},{"name":"FormatActivitySource","docStart":13991,"docEnd":14847,"docs":{"brief":"Given an originating client and a target client, returns the string\nthat describes the originating client according to the sm_show_activity cvar.\n\nFor example, \"ADMIN\", \"PLAYER\", or a player's name could be placed in this buffer.","tags":[{"tag":"","text":"Given an originating client and a target client, returns the string\nthat describes the originating client according to the sm_show_activity cvar.\n\nFor example, \"ADMIN\", \"PLAYER\", or a player's name could be placed in this buffer."},{"tag":"param:client","text":"Originating client; may be 0 for server console."},{"tag":"param:target","text":"Targeted client."},{"tag":"param:namebuf","text":"Name buffer."},{"tag":"param:maxlength","text":"Maximum size of the name buffer."},{"tag":"return","text":"True if activity should be shown.  False otherwise.  In either\ncase, the name buffer is filled.  The return value can be used\nto broadcast a \"safe\" name to all players regardless of the\nsm_show_activity filters."},{"tag":"error","text":"Invalid client index or client not connected."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"client","decl":"int client"},{"type":"int","name":"target","decl":"int target"},{"type":"const char[]","name":"namebuf","decl":"const char[] namebuf"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"RegServerCmd","docStart":15282,"docEnd":15788,"docs":{"brief":"Creates a server-only console command, or hooks an already existing one.\n\nServer commands are case sensitive.","tags":[{"tag":"","text":"Creates a server-only console command, or hooks an already existing one.\n\nServer commands are case sensitive."},{"tag":"param:cmd","text":"Name of the command to hook or create."},{"tag":"param:callback","text":"A function to use as a callback for when the command is invoked."},{"tag":"param:description","text":"Optional description to use for command creation."},{"tag":"param:flags","text":"Optional flags to use for command creation."},{"tag":"error","text":"Command name is the same as an existing convar."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"cmd","decl":"const char[] cmd"},{"type":"SrvCmd","name":"callback","decl":"SrvCmd callback"},{"type":"const char[]","name":"description","decl":"const char[] description"},{"type":"int","name":"flags","decl":"int flags"}]},{"name":"RegConsoleCmd","docStart":16313,"docEnd":17017,"docs":{"brief":"Creates a console command, or hooks an already existing one.\n\nConsole commands are case sensitive.  However, if the command already exists in the game,\na client may enter the command in any case.  SourceMod corrects for this automatically,\nand you should only hook the \"real\" version of the command.","tags":[{"tag":"","text":"Creates a console command, or hooks an already existing one.\n\nConsole commands are case sensitive.  However, if the command already exists in the game,\na client may enter the command in any case.  SourceMod corrects for this automatically,\nand you should only hook the \"real\" version of the command."},{"tag":"param:cmd","text":"Name of the command to hook or create."},{"tag":"param:callback","text":"A function to use as a callback for when the command is invoked."},{"tag":"param:description","text":"Optional description to use for command creation."},{"tag":"param:flags","text":"Optional flags to use for command creation."},{"tag":"error","text":"Command name is the same as an existing convar."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"cmd","decl":"const char[] cmd"},{"type":"ConCmd","name":"callback","decl":"ConCmd callback"},{"type":"const char[]","name":"description","decl":"const char[] description"},{"type":"int","name":"flags","decl":"int flags"}]},{"name":"RegAdminCmd","docStart":17126,"docEnd":18020,"docs":{"brief":"Creates a console command as an administrative command.  If the command does not exist,\nit is created.  When this command is invoked, the access rights of the player are\nautomatically checked before allowing it to continue.\n\nAdmin commands are case sensitive from both the client and server.","tags":[{"tag":"","text":"Creates a console command as an administrative command.  If the command does not exist,\nit is created.  When this command is invoked, the access rights of the player are\nautomatically checked before allowing it to continue.\n\nAdmin commands are case sensitive from both the client and server."},{"tag":"param:cmd","text":"String containing command to register."},{"tag":"param:callback","text":"A function to use as a callback for when the command is invoked."},{"tag":"param:adminflags","text":"Administrative flags (bitstring) to use for permissions."},{"tag":"param:description","text":"Optional description to use for help."},{"tag":"param:group","text":"String containing the command group to use.  If empty,\nthe plugin's filename will be used instead."},{"tag":"param:flags","text":"Optional console flags."},{"tag":"error","text":"Command name is the same as an existing convar."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"cmd","decl":"const char[] cmd"},{"type":"ConCmd","name":"callback","decl":"ConCmd callback"},{"type":"int","name":"adminflags","decl":"int adminflags"},{"type":"const char[]","name":"description","decl":"const char[] description"},{"type":"const char[]","name":"group","decl":"const char[] group"},{"type":"int","name":"flags","decl":"int flags"}]},{"name":"GetCmdArgs","docStart":18201,"docEnd":18442,"docs":{"brief":"Returns the number of arguments from the current console or server command.","tags":[{"tag":"","text":"Returns the number of arguments from the current console or server command."},{"tag":"note","text":"Unlike the HL2 engine call, this does not include the command itself."},{"tag":"return","text":"Number of arguments to the current command."}]},"kind":"native","returnType":"int","arguments":[]},{"name":"GetCmdArg","docStart":18472,"docEnd":18885,"docs":{"brief":"Retrieves a command argument given its index, from the current console or\nserver command.","tags":[{"tag":"","text":"Retrieves a command argument given its index, from the current console or\nserver command."},{"tag":"note","text":"Argument indexes start at 1; 0 retrieves the command name."},{"tag":"param:argnum","text":"Argument number to retrieve."},{"tag":"param:buffer","text":"Buffer to use for storing the string."},{"tag":"param:maxlength","text":"Maximum length of the buffer."},{"tag":"return","text":"Length of string written to buffer."}]},"kind":"native","returnType":"int","arguments":[{"type":"int","name":"argnum","decl":"int argnum"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"GetCmdArgString","docStart":18954,"docEnd":19255,"docs":{"brief":"Retrieves the entire command argument string in one lump from the current\nconsole or server command.","tags":[{"tag":"","text":"Retrieves the entire command argument string in one lump from the current\nconsole or server command."},{"tag":"param:buffer","text":"Buffer to use for storing the string."},{"tag":"param:maxlength","text":"Maximum length of the buffer."},{"tag":"return","text":"Length of string written to buffer."}]},"kind":"native","returnType":"int","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlength","decl":"int maxlength"}]},{"name":"GetCommandIterator","docStart":20751,"docEnd":20876,"docs":{"brief":"Gets a command iterator.  Must be freed with CloseHandle().","tags":[{"tag":"","text":"Gets a command iterator.  Must be freed with CloseHandle()."},{"tag":"return","text":"A new command iterator."}]},"kind":"native","returnType":"Handle","arguments":[]},{"name":"ReadCommandIterator","docStart":20917,"docEnd":21436,"docs":{"brief":"Reads a command iterator, then advances to the next command if any.\nOnly SourceMod specific commands are returned.","tags":[{"tag":"","text":"Reads a command iterator, then advances to the next command if any.\nOnly SourceMod specific commands are returned."},{"tag":"param:iter","text":"Command iterator Handle."},{"tag":"param:name","text":"Name buffer."},{"tag":"param:nameLen","text":"Name buffer size."},{"tag":"param:eflags","text":"Effective default flags of a command."},{"tag":"param:desc","text":"Command description buffer."},{"tag":"param:descLen","text":"Command description buffer size."},{"tag":"return","text":"True on success, false if there are no more commands."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"iter","decl":"Handle iter"},{"type":"char[]","name":"name","decl":"char[] name"},{"type":"int","name":"nameLen","decl":"int nameLen"},{"type":"int&","name":"eflags","decl":"int& eflags"},{"type":"char[]","name":"desc","decl":"char[] desc"},{"type":"int","name":"descLen","decl":"int descLen"}]},{"name":"CheckCommandAccess","docStart":21609,"docEnd":22540,"docs":{"brief":"Returns whether a client has access to a given command string.  The string\ncan be any override string, as overrides can be independent of\ncommands.  This feature essentially allows you to create custom\nflags using the override system.","tags":[{"tag":"","text":"Returns whether a client has access to a given command string.  The string\ncan be any override string, as overrides can be independent of\ncommands.  This feature essentially allows you to create custom\nflags using the override system."},{"tag":"param:client","text":"Client index."},{"tag":"param:command","text":"Command name.  If the command is not found, the default\nflags are used."},{"tag":"param:flags","text":"Flag string to use as a default, if the command or override\nis not found."},{"tag":"param:override_only","text":"If true, SourceMod will not attempt to find a matching\ncommand, and it will only use the default flags specified.\nOtherwise, SourceMod will ignore the default flags if\nthere is a matching admin command."},{"tag":"return","text":"True if the client has access, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"int","name":"client","decl":"int client"},{"type":"const char[]","name":"command","decl":"const char[] command"},{"type":"int","name":"flags","decl":"int flags"},{"type":"bool","name":"override_only","decl":"bool override_only"}]},{"name":"CheckAccess","docStart":22682,"docEnd":23619,"docs":{"brief":"Returns whether an admin has access to a given command string.  The string\ncan be any override string, as overrides can be independent of\ncommands.  This feature essentially allows you to create custom flags\nusing the override system.","tags":[{"tag":"","text":"Returns whether an admin has access to a given command string.  The string\ncan be any override string, as overrides can be independent of\ncommands.  This feature essentially allows you to create custom flags\nusing the override system."},{"tag":"param:id","text":"AdminId of the admin."},{"tag":"param:command","text":"Command name.  If the command is not found, the default\nflags are used."},{"tag":"param:flags","text":"Flag string to use as a default, if the command or override\nis not found."},{"tag":"param:override_only","text":"If true, SourceMod will not attempt to find a matching\ncommand, and it will only use the default flags specified.\nOtherwise, SourceMod will ignore the default flags if\nthere is a matching admin command."},{"tag":"return","text":"True if the admin has access, false otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"AdminId","name":"id","decl":"AdminId id"},{"type":"const char[]","name":"command","decl":"const char[] command"},{"type":"int","name":"flags","decl":"int flags"},{"type":"bool","name":"override_only","decl":"bool override_only"}]},{"name":"GetCommandFlags","docStart":23754,"docEnd":24015,"docs":{"brief":"Returns the bitstring of flags of a command.","tags":[{"tag":"","text":"Returns the bitstring of flags of a command."},{"tag":"param:name","text":"Name of the command."},{"tag":"return","text":"A bitstring containing the FCVAR_* flags that are enabled\nor INVALID_FCVAR_FLAGS if command not found."}]},"kind":"native","returnType":"int","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"}]},{"name":"SetCommandFlags","docStart":24067,"docEnd":24307,"docs":{"brief":"Sets the bitstring of flags of a command.","tags":[{"tag":"","text":"Sets the bitstring of flags of a command."},{"tag":"param:name","text":"Name of the command."},{"tag":"param:flags","text":"A bitstring containing the FCVAR_* flags to enable."},{"tag":"return","text":"True on success, otherwise false."}]},"kind":"native","returnType":"bool","arguments":[{"type":"const char[]","name":"name","decl":"const char[] name"},{"type":"int","name":"flags","decl":"int flags"}]},{"name":"FindFirstConCommand","docStart":24371,"docEnd":25546,"docs":{"brief":"Starts a ConCommandBase search, traversing the list of ConVars and\nConCommands.  If a Handle is returned, the next entry must be read\nvia FindNextConCommand().  The order of the list is undefined.","tags":[{"tag":"","text":"Starts a ConCommandBase search, traversing the list of ConVars and\nConCommands.  If a Handle is returned, the next entry must be read\nvia FindNextConCommand().  The order of the list is undefined."},{"tag":"param:buffer","text":"Buffer to store entry name."},{"tag":"param:max_size","text":"Maximum size of the buffer."},{"tag":"param:isCommand","text":"Variable to store whether the entry is a command.\nIf it is not a command, it is a ConVar."},{"tag":"param:flags","text":"Variable to store entry flags."},{"tag":"param:description","text":"Buffer to store the description, empty if no description present."},{"tag":"param:descrmax_size","text":"Maximum size of the description buffer."},{"tag":"return","text":"On success, a ConCmdIter Handle is returned, which\ncan be read via FindNextConCommand(), and must be\nclosed via CloseHandle().  Additionally, the output\nparameters will be filled with information of the\nfirst ConCommandBase entry.\nOn failure, INVALID_HANDLE is returned, and the\ncontents of outputs is undefined."}]},"kind":"native","returnType":"Handle","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"max_size","decl":"int max_size"},{"type":"bool&","name":"isCommand","decl":"bool& isCommand"},{"type":"int&","name":"flags","decl":"int& flags"},{"type":"char[]","name":"description","decl":"char[] description"},{"type":"int","name":"descrmax_size","decl":"int descrmax_size"}]},{"name":"FindNextConCommand","docStart":25690,"docEnd":26562,"docs":{"brief":"Reads the next entry in a ConCommandBase iterator.","tags":[{"tag":"","text":"Reads the next entry in a ConCommandBase iterator."},{"tag":"param:search","text":"ConCmdIter Handle to search."},{"tag":"param:buffer","text":"Buffer to store entry name."},{"tag":"param:max_size","text":"Maximum size of the buffer."},{"tag":"param:isCommand","text":"Variable to store whether the entry is a command.\nIf it is not a command, it is a ConVar."},{"tag":"param:flags","text":"Variable to store entry flags."},{"tag":"param:description","text":"Buffer to store the description, empty if no description present."},{"tag":"param:descrmax_size","text":"Maximum size of the description buffer."},{"tag":"return","text":"On success, the outputs are filled, the iterator is\nadvanced to the next entry, and true is returned.\nIf no more entries exist, false is returned, and the\ncontents of outputs is undefined."}]},"kind":"native","returnType":"bool","arguments":[{"type":"Handle","name":"search","decl":"Handle search"},{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"max_size","decl":"int max_size"},{"type":"bool&","name":"isCommand","decl":"bool& isCommand"},{"type":"int&","name":"flags","decl":"int& flags"},{"type":"char[]","name":"description","decl":"char[] description"},{"type":"int","name":"descrmax_size","decl":"int descrmax_size"}]},{"name":"AddServerTag","docStart":26718,"docEnd":27048,"docs":{"brief":"Adds an informational string to the server's public \"tags\".\nThis string should be a short, unique identifier.\n\nNote: Tags are automatically removed when a plugin unloads.\nNote: Currently, this function does nothing because of bugs in the Valve master.","tags":[{"tag":"","text":"Adds an informational string to the server's public \"tags\".\nThis string should be a short, unique identifier.\n\nNote: Tags are automatically removed when a plugin unloads.\nNote: Currently, this function does nothing because of bugs in the Valve master."},{"tag":"param:tag","text":"Tag string to append."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"tag","decl":"const char[] tag"}]},{"name":"RemoveServerTag","docStart":27097,"docEnd":27214,"docs":{"brief":"Removes a tag previously added by the calling plugin.","tags":[{"tag":"","text":"Removes a tag previously added by the calling plugin."},{"tag":"param:tag","text":"Tag string to remove."}]},"kind":"native","returnType":"void","arguments":[{"type":"const char[]","name":"tag","decl":"const char[] tag"}]},{"name":"AddCommandListener","docStart":28551,"docEnd":29329,"docs":{"brief":"Adds a callback that will fire when a command is sent to the server.\n\nRegistering commands is designed to create a new command as part of the UI,\nwhereas this is a lightweight hook on a command string, existing or not.\nUsing Reg*Cmd to intercept is in poor practice, as it physically creates a\nnew command and can slow down dispatch in general.\n\nTo see if this feature is available, use FeatureType_Capability and\nFEATURECAP_COMMANDLISTENER.","tags":[{"tag":"","text":"Adds a callback that will fire when a command is sent to the server.\n\nRegistering commands is designed to create a new command as part of the UI,\nwhereas this is a lightweight hook on a command string, existing or not.\nUsing Reg*Cmd to intercept is in poor practice, as it physically creates a\nnew command and can slow down dispatch in general.\n\nTo see if this feature is available, use FeatureType_Capability and\nFEATURECAP_COMMANDLISTENER."},{"tag":"param:callback","text":"Callback."},{"tag":"param:command","text":"Command, or if not specified, a global listener.\nThe command is case insensitive."},{"tag":"return","text":"True if this feature is available on the current game,\nfalse otherwise."}]},"kind":"native","returnType":"bool","arguments":[{"type":"CommandListener","name":"callback","decl":"CommandListener callback"},{"type":"const char[]","name":"command","decl":"const char[] command"}]},{"name":"RemoveCommandListener","docStart":29417,"docEnd":29737,"docs":{"brief":"Removes a previously added command listener, in reverse order of being added.","tags":[{"tag":"","text":"Removes a previously added command listener, in reverse order of being added."},{"tag":"param:callback","text":"Callback."},{"tag":"param:command","text":"Command, or if not specified, a global listener.\nThe command is case insensitive."},{"tag":"error","text":"Callback has no active listeners."}]},"kind":"native","returnType":"void","arguments":[{"type":"CommandListener","name":"callback","decl":"CommandListener callback"},{"type":"const char[]","name":"command","decl":"const char[] command"}]},{"name":"CommandExists","docStart":29828,"docEnd":29999,"docs":{"brief":"Returns true if the supplied command exists.","tags":[{"tag":"","text":"Returns true if the supplied command exists."},{"tag":"param:command","text":"Command to find."},{"tag":"return","text":"True if command is found, false otherwise."}]},"kind":"stock","returnType":"bool","arguments":[{"type":"const char[]","name":"command","decl":"const char[] command"}]},{"name":"OnClientSayCommand","docStart":30115,"docEnd":30500,"docs":{"brief":"Global listener for the chat commands.","tags":[{"tag":"","text":"Global listener for the chat commands."},{"tag":"param:client","text":"Client index."},{"tag":"param:command","text":"Command name."},{"tag":"param:sArgs","text":"Chat argument string."},{"tag":"return","text":"An Action value. Returning Plugin_Handled bypasses the game function call.\nReturning Plugin_Stop bypasses the post hook as well as the game function."}]},"kind":"forward","returnType":"Action","arguments":[{"type":"int","name":"client","decl":"int client"},{"type":"const char[]","name":"command","decl":"const char[] command"},{"type":"const char[]","name":"sArgs","decl":"const char[] sArgs"}]},{"name":"OnClientSayCommand_Post","docStart":30594,"docEnd":30779,"docs":{"brief":"Global post listener for the chat commands.","tags":[{"tag":"","text":"Global post listener for the chat commands."},{"tag":"param:client","text":"Client index."},{"tag":"param:command","text":"Command name."},{"tag":"param:sArgs","text":"Chat argument string."}]},"kind":"forward","returnType":"void","arguments":[{"type":"int","name":"client","decl":"int client"},{"type":"const char[]","name":"command","decl":"const char[] command"},{"type":"const char[]","name":"sArgs","decl":"const char[] sArgs"}]}],"methodmaps":[{"name":"CommandIterator","docStart":0,"docEnd":0,"docs":null,"methods":[{"name":"CommandIterator","docStart":19357,"docEnd":19665,"docs":{"brief":"Creates a new CommandIterator. Must be freed with delete or\nCloseHandle().\n\nThe CommandIterator can be used to iterate commands created by\nSourceMod plugins and allows inspection of properties associated\nwith the command.","tags":[{"tag":"","text":"Creates a new CommandIterator. Must be freed with delete or\nCloseHandle().\n\nThe CommandIterator can be used to iterate commands created by\nSourceMod plugins and allows inspection of properties associated\nwith the command."},{"tag":"return","text":"New CommandIterator Handle."}]},"kind":null,"returnType":"CommandIterator","arguments":[]},{"name":"Next","docStart":19705,"docEnd":19871,"docs":{"brief":"Determines if there is a next command. If one is found, the\niterator is advanced to it.","tags":[{"tag":"","text":"Determines if there is a next command. If one is found, the\niterator is advanced to it."},{"tag":"return","text":"true if found and iterator is advanced."}]},"kind":null,"returnType":"bool","arguments":[]},{"name":"GetDescription","docStart":19905,"docEnd":20101,"docs":{"brief":"Retrieves the command's description.","tags":[{"tag":"","text":"Retrieves the command's description."},{"tag":"param:buffer","text":"Buffer to copy to."},{"tag":"param:maxlen","text":"Maximum size of the buffer."},{"tag":"error","text":"Invalid iterator position."}]},"kind":null,"returnType":"void","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlen","decl":"int maxlen"}]},{"name":"GetName","docStart":20170,"docEnd":20359,"docs":{"brief":"Retrieves the command's name.","tags":[{"tag":"","text":"Retrieves the command's name."},{"tag":"param:buffer","text":"Buffer to copy to."},{"tag":"param:maxlen","text":"Maximum size of the buffer."},{"tag":"error","text":"Invalid iterator position."}]},"kind":null,"returnType":"void","arguments":[{"type":"char[]","name":"buffer","decl":"char[] buffer"},{"type":"int","name":"maxlen","decl":"int maxlen"}]}],"properties":[{"name":"Plugin","docStart":20421,"docEnd":20534,"docs":{"brief":"Retrieves the plugin handle of the command's creator","tags":[{"tag":"","text":"Retrieves the plugin handle of the command's creator"},{"tag":"error","text":"Invalid iterator position."}]},"type":"Handle","getter":true,"setter":false},{"name":"Flags","docStart":20594,"docEnd":20693,"docs":{"brief":"Retrieves the command's default flags","tags":[{"tag":"","text":"Retrieves the command's default flags"},{"tag":"error","text":"Invalid iterator position."}]},"type":"int","getter":true,"setter":false}]}],"constants":[],"enums":[{"name":"QueryCookie","docStart":1676,"docEnd":1726,"docs":{"brief":"Console variable query helper values.","tags":[{"tag":"","text":"Console variable query helper values."}]},"entries":[{"name":"QUERYCOOKIE_FAILED","docStart":0,"docEnd":0,"docs":null}]},{"name":"ReplySource","docStart":1780,"docEnd":1820,"docs":{"brief":"Reply sources for commands.","tags":[{"tag":"","text":"Reply sources for commands."}]},"entries":[{"name":"SM_REPLY_TO_CONSOLE","docStart":0,"docEnd":0,"docs":null},{"name":"SM_REPLY_TO_CHAT","docStart":0,"docEnd":0,"docs":null}]}],"typesets":[],"typedefs":[{"name":"SrvCmd","docStart":14947,"docEnd":15232,"docs":{"brief":"Called when a server-only command is invoked.","tags":[{"tag":"","text":"Called when a server-only command is invoked."},{"tag":"param:args","text":"Number of arguments that were in the argument string."},{"tag":"return","text":"An Action value.  Not handling the command\nmeans that Source will report it as \"not found.\""}]},"type":"function Action(int args)"},{"name":"ConCmd","docStart":15896,"docEnd":16251,"docs":{"brief":"Called when a generic console command is invoked.","tags":[{"tag":"","text":"Called when a generic console command is invoked."},{"tag":"param:client","text":"Index of the client, or 0 from the server."},{"tag":"param:args","text":"Number of arguments that were in the argument string."},{"tag":"return","text":"An Action value.  Not handling the command\nmeans that Source will report it as \"not found.\""}]},"type":"function Action(int client, int args)"},{"name":"CommandListener","docStart":27266,"docEnd":28400,"docs":{"brief":"Callback for command listeners. This is invoked whenever any command\nreaches the server, from the server console itself or a player.\n\nClients may be in the process of connecting when they are executing commands\nIsClientConnected(client) is not guaranteed to return true.  Other functions\nsuch as GetClientIP() may not work at this point either.\n\nReturning Plugin_Handled or Plugin_Stop will prevent the original,\nbaseline code from running.\n\n-- TEXT BELOW IS IMPLEMENTATION, AND NOT GUARANTEED --\nEven if returning Plugin_Handled or Plugin_Stop, some callbacks will still\ntrigger. These are:\n* C++ command dispatch hooks from Metamod:Source plugins\n* Reg*Cmd() hooks that did not create new commands.","tags":[{"tag":"","text":"Callback for command listeners. This is invoked whenever any command\nreaches the server, from the server console itself or a player.\n\nClients may be in the process of connecting when they are executing commands\nIsClientConnected(client) is not guaranteed to return true.  Other functions\nsuch as GetClientIP() may not work at this point either.\n\nReturning Plugin_Handled or Plugin_Stop will prevent the original,\nbaseline code from running.\n\n-- TEXT BELOW IS IMPLEMENTATION, AND NOT GUARANTEED --\nEven if returning Plugin_Handled or Plugin_Stop, some callbacks will still\ntrigger. These are:\n* C++ command dispatch hooks from Metamod:Source plugins\n* Reg*Cmd() hooks that did not create new commands."},{"tag":"param:client","text":"Client, or 0 for server.\nClient may not be connected or in game."},{"tag":"param:command","text":"Command name, lower case. To get name as typed, use\nGetCmdArg() and specify argument 0."},{"tag":"param:argc","text":"Argument count."},{"tag":"return","text":"Action to take (see extended notes above)."}]},"type":"function Action(int client, const char[] command, int argc)"}]}